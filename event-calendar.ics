BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//researchr.org//conf.researchr.org//EN
CALSCALE:GREGORIAN

BEGIN:VEVENT
DTSTART:20231022T080000Z
DTEND:20231022T083000Z
DTSTAMP:20231021T100631Z
UID:f00c334d-27a0-494e-a3ef-12d599b9e75c@conf.researchr.org
CREATED:20230916T195536Z
SUMMARY:[PPDP] A Calculus of Delayed Reductions - Steffen van Bakel\, Nicolas Wu\, Emma Tye
DESCRIPTION:We introduce the Calculus of Delayed Reduction (CDR)\, that expresses that redexes can only be contracted when brought to the right position in a term\, and will show that Call by Name or Value (CBN\, CBV) reduction for the lambda calculus can be modelled through reduction in CDR\, and that the CBN fragment of the lambdabar-mu-mutilde-calculus can model reduction in CDR. CDR is a Call by Push Value calculus (CBPV) in that it separates terms in computations and values\, with their corresponding types. Some simulation results were already achieved by others for CBPV\, but only up to equality for CBV\; for CBN the results are rather weak. \nIn order to achieve a single-step reduction respecting mapping for the CBN lambda-calculus\, we allow forcing only for variables\, thunking only for computations that are not forced variables\, and change the nature of term substitution\, and abolish the U-reduction rule. We will show that\, by changing the standard interpretation\, we can achieve a reduction respecting mapping for the CBV lambda-calculus as well. Moreover\, these changes make it possible to establish a strong relation between CDR and lambdabar-mu-mutilde\, allowing to simulate CDR reduction in lambdabar-mu-mutilde\, and preserving assignable types.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053012Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T083000Z
DTEND:20231022T090000Z
DTSTAMP:20231021T100631Z
UID:ba55c364-d483-4b0c-bce1-a2f90d112bc9@conf.researchr.org
CREATED:20230916T195536Z
SUMMARY:[PPDP] Typed Equivalence of Labeled Effect Handlers and Labeled Delimited Control Operators - Kazuki Ikemori\, Youyou Cong\, Hidehiko Masuhara
DESCRIPTION:Algebraic effect handlers and delimited control operations are abstractions of computational effects. Originally proposed without labels\, their labeled extensions can express multiple kinds of exceptions\, multiple states\, and so on. We show that the two abstractions have equal expressive power. To do this\, we first develop a type system for each abstraction with each label extension. We then define macro translations between two abstractions with the same label extension. The equivalences establish a strong connection between the two abstractions with labels\, which can be used to understand and implement one abstraction in terms of the other.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053012Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T090000Z
DTEND:20231022T093000Z
DTSTAMP:20231021T100631Z
UID:82bd6566-5653-4503-8dbd-70b34cea72dd@conf.researchr.org
CREATED:20230916T195536Z
SUMMARY:[PPDP] Comprehending queries over finite maps - Wilmer Ricciotti
DESCRIPTION:Recent programming languages research has developed language-integrated query\, a convenient technique to seamlessly embed a domain-specific database query language into a general-purpose host programming language\; such queries are then automatically converted to the language understood by the target DBMS (e.g. SQL) while at the same time taking advantage of the host language’s type-checker to prevent failure at run-time. The embedded query language is often equipped with a rewrite system which normalizes queries to a form that can be directly translated to the DBMS query language. \nHowever\, the theoretical foundations of such rewrite systems have not been explored to their full extent\, particularly when constructs like grouping and aggregation\, which are ubiquitous in real-world database queries\, are involved. In this work\, we propose an extension of the nested relational calculus with grouping and aggregation which can provide such foundations. Along with strong normalization and translatability to SQL we show that\, remarkably\, this extension can also blend with shredding techniques proposed in the literature to allow queries with a nested relational type to be executed on the DBMS.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053012Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T080000Z
DTEND:20231022T080500Z
DTSTAMP:20231021T100631Z
UID:bfc8dd02-7c9a-4d3b-8693-eaf891d2916d@conf.researchr.org
CREATED:20230918T155436Z
SUMMARY:[SAS ] Opening - Manuel Hermenegildo\, José Morales
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T235542Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T080500Z
DTEND:20231022T090500Z
DTSTAMP:20231021T100631Z
UID:194e6c22-d584-4244-b03b-5f765ca14dc8@conf.researchr.org
CREATED:20230918T142329Z
SUMMARY:[SAS ] Goal-Directed Abstract Interpretation and Event-Driven Frameworks - Bor-Yuh Evan Chang
DESCRIPTION:Static analysis is typically about computing a global over-approxi- mation of a program’s behavior from its source code. But what if most of the program code is missing or unknown to the analyzer? What if even where the program starts is unknown? This fundamentally thorny situation arises when attempting to analyze interactive applications (apps) developed against modern\, event-driven software frameworks. Rich event-driven software frameworks enable software engineers to create complex applications on sophisticated computing platforms (e.g.\, smartphones with a broad range of sensors and rich interactivity) with relatively little code by simply implementing callbacks to respond to events. But developing apps against them is also notoriously difficult. To create apps that behave as expected\, devel- opers must follow the complex and opaque asynchronous programming protocols imposed by the framework. So what makes static analysis of apps hard is essen- tially what makes programming them hard: the specification of the programming protocol is unclear and the possible control flow between callbacks is largely un- known. While the typical workaround to perform static analysis with an unknown framework implementation is to either assume it to be arbitrary or attempt to eagerly specify all possible callback control flow\, this solution can be too pes- simistic to prove properties of interest or too burdensome and tricky to get right. In this talk\, I argue for a rethinking of how to analyze app code in the context of an unknown framework implementation. In particular\, I present some benefits from taking a goal-directed or backward-from-error formulation to prove just the assertions of interest and from designing semantics\, program logics\, specification logics\, and abstract domains to reason about the app-framework boundary in a first-class manner. What follows are hopefully lines of work that make ana- lyzing modern interactive applications more targeted\, more compositional\, and ultimately more trustworthy.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052430Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T090500Z
DTEND:20231022T093500Z
DTSTAMP:20231021T100631Z
UID:6ba594ea-21bc-4caf-be39-88d3738ecebb@conf.researchr.org
CREATED:20230918T142329Z
SUMMARY:[SAS ] A Product of Shape and Sequence Abstractions - Josselin Giet\, Félix Ridoux\, Xavier Rival
DESCRIPTION:Traditional separation logic-based shape analyses utilize inductive summarizing predicates so as to capture general properties of the layout of data-structures\, to verify accurate manipulations of\, e.g.\, various forms of lists or trees. However\, they also usually abstract away content properties\, so that they may only verify memory safety and invariance of data-structure shapes. In this paper\, we introduce a novel abstract domain to describe sequences of values of unbounded size\, and track constraints on their length and on extremal values contained in them. We define a reduced product of such a sequence abstraction together with an existing shape abstraction so as to infer both shape and content properties of data-structures. We report on the implementation of the sequence domain\, its integration into a static analyzer for C code\, and we evaluate its ability to verify partial functional correctness properties for list and tree algorithms.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052430Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T080000Z
DTEND:20231022T080500Z
DTSTAMP:20231021T100631Z
UID:230c5d88-2cfe-428c-a15f-bdb36355ab02@conf.researchr.org
CREATED:20230911T225127Z
SUMMARY:[MPLR] Welcome from the Chairs - Rodrigo Bruno\, Eliot Moss
DESCRIPTION:Welcome to MPLR 2023\, the 20th International Conference on Managed Programming Languages and Runtimes\, held in Cacais\, Portugal on Sunday 22 October 2023\, co-located with SPLASH 2023. MPLR is a successor to the conference series on Managed Languages and Runtimes (ManLang). It is a premier forum for presenting and discussing novel results in all aspects of managed programming languages and runtime systems\, which serve as building blocks for some of the most important computing systems around\, ranging from small-scale (embedded and real-time systems) to large-scale (cloud-computing and big-data platforms) and anything in between (mobile\, IoT\, and wearable applications).
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T182806Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T080500Z
DTEND:20231022T090000Z
DTSTAMP:20231021T100631Z
UID:3d34e63d-f75c-4e6c-8c57-fa45483a45b2@conf.researchr.org
CREATED:20230911T225700Z
SUMMARY:[MPLR] Is Wasm Becoming Garbage? (Keynote) - Andreas Rossberg
DESCRIPTION:WebAssembly (a.k.a. Wasm) is a low-level virtual machine that is designed to be lightweight\, close to the metal and agnostic to any source languages' opinions about how to construct programs. This is the defining characteristic of Wasm that distinguishes it from other popular virtual machines. Yet we recently finalised a new feature addition bringing direct support for garbage collection to Wasm. In this talk\, I explain why we did that and how the GC extension is designed to preserve the low-level spirit of Wasm to the extent possible. I will show how it can be targeted by compilers for typical object-oriented and functional languages and where we left room for future improvements.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T181259Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T090000Z
DTEND:20231022T091500Z
DTSTAMP:20231021T100631Z
UID:47ee989a-d13a-4033-b733-6d8e047a46ed@conf.researchr.org
CREATED:20230911T230243Z
SUMMARY:[MPLR] On the Applicability of Annotation-Based Source Code Modification in Kotlin (Work in Progress) - Daniel Pfeffer\, Markus Weninger
DESCRIPTION:Annotations add metadata to source code entities such as classes or functions\, which later can be processed by so-called annotation processors to\, for example\, modify the annotated program's source code. While annotation processing has been well-explored in Java\, the Kotlin community still lacks a comprehensive summary. Thus\, in this paper\, we summarize the main approaches available in Kotlin: (1) Compile-time annotation processing using (a)~Kotlin Annotation Processing Tool (KAPT)\, (b) Kotlin Symbolic Processing (KSP)\, or (c) writing a custom Kotlin Compiler plugin\; as well as (2) load-time code modification using an agent or a custom class loader. We provide proof-of-concept implementations\, discuss advantages and disadvantages\, and specifically focus on how well each approach supports modifying the annotated source code. This should help developers and researchers to better decide when to use which approach.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T181523Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T091500Z
DTEND:20231022T093000Z
DTSTAMP:20231021T100631Z
UID:a4f83c49-2cc3-4c94-98f1-e161926f6ef9@conf.researchr.org
CREATED:20230911T230243Z
SUMMARY:[MPLR] CloudJIT: A Just-in-Time FaaS Optimizer (Work in Progress) - Serhii Ivanenko\, Rodrigo Bruno\, Jovan Stevanovic\, Luís Veiga\, Vojin Jovanovic
DESCRIPTION:Function-as-a-Service has emerged as a trending paradigm that provides attractive solutions to execute fine-grained and short-lived workloads referred to as functions. Functions are typically developed in a managed language such as Java and execute atop a language runtime. However\, traditional language runtimes such as the HotSpot JVM are designed for peak performance as considerable time is spent profiling and Just-in-Time compiling code. As a consequence\, warmup time and memory footprint are impacted. We observe that FaaS workloads\, which are short-lived\, do not fit this profile. \nWe propose CloudJIT\, a self-optimizing FaaS platform that takes advantage of Ahead-of-Time compilation to achieve reduced startup latency and instantaneous peak performance with a smaller memory footprint. While AOT compilation is an expensive operation\, the platform automatically detects which functions will benefit from it the most\, performs all prerequisite preparation procedures\, and compiles selected functions into native binaries. Our preliminary analysis\, based on a public FaaS invocations trace\, shows that optimizing a small fraction of all functions positively affects a vast majority of all cold starts.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T181614Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T081500Z
DTEND:20231022T093000Z
DTSTAMP:20231021T100631Z
UID:62436d4c-14fe-4954-9d26-0e57db701029@conf.researchr.org
CREATED:20230914T172519Z
SUMMARY:[FTSCS] Opening\, Keynote: Bounded STL Model Checking for Hybrid Systems - Kyungmin Bae
DESCRIPTION:Signal temporal logic (STL) is a temporal logic formalism for specifying properties of continuous signals. STL has been widely used for specifying\, monitoring\, and testing properties of hybrid systems that exhibit both discrete and continuous behavior. However\, model checking techniques for hybrid systems have been primarily limited to invariant and reachability properties. This is mainly due to the intrinsic nature of hybrid systems\, which involve uncountably many signals that continuously change over time. For hybrid systems\, checking whether all possible behaviors satisfy an STL formula requires a certain form of abstraction and discretization\, which has not been developed for general STL properties. \nIn this talk\, I introduce bounded model checking algorithms and tools for general STL properties of hybrid systems. Central to our technique is a novel logical foundation for STL: (i) a syntactic separation of STL\, which decomposes an STL formula into components\, with each component relying exclusively on separate segments of a signal\, and (ii) a signal discretization\, which ensures a complete abstraction of a signal\, given by a set of discrete elements. With this new foundation\, the STL model checking problem can be reduced to the satisfiability of a first-order logic formula. This allows us to develop the first model checking algorithm for STL that can guarantee the correctness of STL up to given bound parameters\, and a pioneering bounded model checker for hybrid systems\, called STLmc. \n \nKyungmin Bae is an associate professor in the Department of Computer Science and Engineering at POSTECH (Pohang University of Science and Technology) in Korea. He received his Ph.D. in Computer Science from the University of Illinois at Urbana-Champaign. Before joining POSTECH\, he worked as a postdoctoral researcher at Carnegie-Mellon University and SRI International. His current research interests are algorithmic verification techniques for cyber-physical systems\, based on model checking\, rewriting logic\, and SMT.
LOCATION:Room IV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052802Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T080000Z
DTEND:20231022T083000Z
DTSTAMP:20231021T100631Z
UID:96e8fe3e-ac6e-4530-80c7-036aeee680fb@conf.researchr.org
CREATED:20230929T183609Z
SUMMARY:[ST30 ] A silent semantics for isorecursive session types - Janek Spaderna\, Peter Thiemann\, Vasco T. Vasconcelos
DESCRIPTION:Almost all formalizations of recursive session types rely on equirecursion because the explicit isomorphism to roll/unroll the recursive type is said to give rise to additional communication and synchronization. We examine this statement from first principles and find mild conditions under which these communications can be elided.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230929T183609Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T083000Z
DTEND:20231022T090000Z
DTSTAMP:20231021T100631Z
UID:41111313-14f1-4da6-b1f9-3d9bf36c85c0@conf.researchr.org
CREATED:20230929T183609Z
SUMMARY:[ST30 ] Mechanising Multiparty Session Types: A Sound and Complete Projection - Marco Carbone
DESCRIPTION:Multiparty session types is a typing discipline used to write specifications\, known as global types\, for branching and recursive message-passing systems. A necessary operation on global types is projection to abstractions of local behaviour\, called local types. Typically\, this is a computable partial function that given a global type and a role erases all details irrelevant to this role. Computable projection functions in the literature are either unsound or too restrictive when dealing with recursion and branching. Recent work has taken a more general approach to projection defining it as a coinductive\, but not computable\, relation. Our work defines a new computable projection function that is sound and complete with respect to its coinductive counterpart and\, hence\, equally expressive. All results have been mechanised in the Coq proof assistant. \nThis work is part of the ongoing attempt to mechanise in Coq the results of the original paper on Multiparty Asynchronous Session Types. This is joint work with my PhD student (Dawit Tirore) and my colleague (Jesper Bengtson). The results are to appear in the proceedings of the Fourteenth Conference on Interactive Theorem Proving (ITP’23).
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230929T183609Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T090000Z
DTEND:20231022T093000Z
DTSTAMP:20231021T100631Z
UID:41938973-07ef-411f-94d3-74ed3394fe2a@conf.researchr.org
CREATED:20230929T183609Z
SUMMARY:[ST30 ] The Concurrent Calculi Formalisation Benchmark - Marco Carbone\, David Castro-Perez\, Francisco Ferreira\, Lorenzo Gheri\, Frederik Krogsdal Jacobsen\, Alberto Momigliano\, Luca Padovani\, Alceste Scalas\, Martin Vassor\, Nobuko Yoshida
DESCRIPTION:The POPLMark challenge sparked a flurry of work on machine-checked proofs. However\, POPLMark (and its follow-up POPLMark Reloaded) were explicitly limited in scope\, with benchmark problems that do not address concurrency. For this reason\, we propose a new collection of benchmark problems with a focus on the issues encountered when mechanising message-passing concurrency using process calculi. Our benchmark problems concern linear handling of environments\, scope extrusion\, and coinductive reasoning. Our goal is to clarify\, compare and advance the state of the art.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230929T183609Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T100000Z
DTEND:20231022T113000Z
DTSTAMP:20231021T100631Z
UID:dee90ffa-19d8-4255-b479-03ebdef8ce05@conf.researchr.org
CREATED:20230916T195626Z
SUMMARY:[PPDP] Embedding Quantitative Properties of Call-by-Name and Call-by-Value in a Unifying Framework - Delia Kesner
DESCRIPTION:This talk explores how the (untyped and typed) theories of Call-by-Name (CBN)and Call-by-Value (CBV) can be unified in a more general framework provided by a Call-by-Push-Value (CBPV) like calculus. Indeed\, we first present an untyped calculus\, called lambda-bang\, which encodes untyped CNB and CBV\, both from a static and a dynamic point of view. We then explore these encodings in a typed framework\, specified by quantitative (aka non-idempotent intersection) types. Three different (quantitative) properties are discussed. The first one is related to upper bounds for reduction lengths\, the second one concerns exact measures for reduction lengths and sizes of normal forms\, and the last one is about the inhabitation problem. In all these cases\, explained and discussed in the talk\, the (quantitative) property for CBN/CBV is inherited from the corresponding one in the lambda-bang calculus.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053019Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T100000Z
DTEND:20231022T103000Z
DTSTAMP:20231021T100631Z
UID:aa35e6c5-fab1-427e-b897-895dcaa4f43a@conf.researchr.org
CREATED:20230918T141924Z
SUMMARY:[SAS ] How fitting is your abstract domain? - Roberto Giacobazzi\, Isabella Mastroeni\, Elia Perantoni
DESCRIPTION:Abstract interpretation offers sound and decidable approximations for undecidable queries related to program behavior. The effectiveness of an abstract domain is entirely reliant on the abstract domain itself\, and the worst-case scenario is when the abstract interpreter provides a response of “don’t know\,” indicating that anything could happen during runtime. Conversely\, a desirable outcome is when the abstract interpreter provides information that exceeds a specified level of precision\, resulting in a more precise answer. The concept of completeness relates to the level of precision that is forfeited when performing computations within the abstract domain. Our focus is on the domain’s ability to express program behaviour\, which is referred to as adequacy. In this paper\, we present a simple proof system for adequacy\, designed to determine whether an abstract domain is capable of providing satisfactory responses to specified program queries. The proof system is sound and capable of detecting instances where the response generated by the abstract interpreter falls below a specified threshold. Notably\, this proof system is both language and domain agnostic\, and can be readily incorporated to support static program analysis.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052440Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T103000Z
DTEND:20231022T110000Z
DTSTAMP:20231021T100631Z
UID:ddae6441-2251-4464-986d-ab549943c673@conf.researchr.org
CREATED:20230918T141924Z
SUMMARY:[SAS ] Domain Precision in Galois Connection-less Abstract Interpretation - Isabella Mastroeni\, Michele Pasqua
DESCRIPTION:The ever growing pervasiveness of software systems in modern days technology results in an increasing need of (software) program correctness proofs. The latter\, allow developers to spot software failures before production\, hence preventing potentially catastrophic repercussions on our society\, as in the case of safety-critical infrastructures. Unfortunately\, correctness proofs may fail\, even when software is actually correct\, due to program analysis imprecision\, which pays the price of losing information for gaining decidability. In standard abstract interpretation-based static analyses\, such imprecision is “measured” in terms of completeness of the chosen observation (i.e.\, of the abstract domain) w.r.t. the programming language semantics. In this setting\, fixed the language to analyze\, it is crucial to have decidable techniques to determine whether the chosen abstraction is precise enough for the program under analysis. In this paper\, we explore abstract domain precision characterization from a novel point of view\, providing a formal framework for characterizing and (statically) verifying abstract domain precision\, that can be adopted also in the case of ``weakened''\, Galois Connection-less\, static analysis frameworks. Distinctive examples adopting such frameworks are the Convex Polyhedra and Automata domains\, for which standard approaches to reason about analysis precision\, referred as completeness\, cannot be applied.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052440Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T110000Z
DTEND:20231022T113000Z
DTSTAMP:20231021T100631Z
UID:31dddbee-68d4-4fc9-85bd-c06e5a311f3a@conf.researchr.org
CREATED:20230918T141924Z
SUMMARY:[SAS ] A Formal Framework to Measure the Incompleteness of Abstract Interpretations - Marco Campion\, Caterina Urban\, Mila Dalla Preda\, Roberto Giacobazzi
DESCRIPTION:In program analysis by abstract interpretation\, backward-completeness represents no loss of precision between the result of the analysis and the abstraction of the concrete execution\, while forward-completeness stands for no imprecision between the concretization of the analysis result and the concrete execution. Program analyzers satisfying one of the two properties (or both) are considered precise. Regrettably\, as for all approximation methods\, the presence of false-alarms is most of the time unavoidable and therefore we need to deal somehow with incompleteness of both. To this end\, a new property called partial completeness has recently been formalized as a relaxation of backward-completeness allowing a limited amount of imprecision measured by quasi-metrics. However\, the use of quasi-metrics enforces distance functions to adhere precisely the abstract domain ordering\, thus not suitable to be used to weaken the forward-completeness property which considers also abstract domains that are not necessarily based on Galois Connections. In this paper\, we formalize a weaker form of quasi-metric\, called pre-metric\, which can be defined on all domains equipped with a pre-order relation. We show how this newly defined notion of pre-metric allows us to derive other pre-metrics on other domains by exploiting the concretization and\, when available\, the abstraction maps\, according to the information and the corresponding level of approximation that we want to measure. Finally\, by exploiting pre-metrics as our imprecision meter\, we introduce the partial forward/backward-completeness properties.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052440Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T100000Z
DTEND:20231022T102230Z
DTSTAMP:20231021T100631Z
UID:213de52d-2f68-4dcb-a91c-060e4269e338@conf.researchr.org
CREATED:20230911T230707Z
SUMMARY:[MPLR] Evaluating YJIT’s Performance in a Production Context: A Pragmatic Approach - Maxime Chevalier-Boisvert\, Takashi Kokubun\, Noah Gibbs\, Si Xing "Alan" Wu\, Aaron Patterson\, Jemma Issroff
DESCRIPTION:Ruby is a dynamically-typed programming language with a large breadth of features which has grown in popularity with the rise of the modern web\, and remains at the core of the implementation of widely-used online platforms such as Shopify\, GitHub\, Discourse\, and Mastodon. \nThere have been many attempts to integrate JIT compilation into Ruby implementations\, but until recently\, despite impressive performance on benchmarks\, none had seen widespread adoption. This has changed with the arrival of YJIT\, a new JIT compiler based on a Lazy Basic Block Versioning (LBBV) architecture which has recently been upstreamed into CRuby\, and has since seen multiple large-scale production deployments. \nThis paper extends on previous work on YJIT and takes a pragmatic approach towards evaluating YJIT's performance in a production context. We evaluate and compare its performance on benchmarks as well as a large-scale real-world production deployment\, and we look not only at peak performance\, but also at memory usage and warm-up time. \nOn all of our benchmarks\, YJIT is able to consistently outperform the CRuby interpreter by a wide margin. It offers consistent speedups\, full compatibility with existing Ruby code\, much less memory overhead and faster warm-up compared to JRuby and TruffleRuby. We also show that YJIT is able to deliver significant speedups on a real-world deployment on Shopify's worldwide StoreFront Renderer infrastructure\, an application for which it is currently the only viable JIT compiler.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T181643Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T102230Z
DTEND:20231022T104500Z
DTSTAMP:20231021T100631Z
UID:f03e1752-5b30-401d-a8b1-3dbf1c8a541a@conf.researchr.org
CREATED:20230911T230750Z
SUMMARY:[MPLR] CacheIR: The Benefits of a Structured Representation for Inline Caches - Jan de Mooij\, Matthew Gaudet\, Iain Ireland\, Nathan Henderson\, Jose Nelson Amaral
DESCRIPTION:Inline Caching is an important technique used to accelerate operations in dynamically typed language implementations by creating fast paths based on observed program behaviour. Most software stacks that support inline caching use low-level\, often ad-hoc\, Inline-Cache (ICs) data structures for code generation. This work presents CacheIR\, a design for inline caching built entirely around an intermediate representation (IR) which: (i) simplifies the development of ICs by raising the abstraction level\; and (ii) enables reusing compiled native code through IR matching techniques. Moreover\, this work describes WarpBuilder\, a novel design for a Just-In-Time (JIT) compiler front-end that directly generates type-specialized code by lowering the CacheIR contained in ICs\; and Trial Inlining\, an extension to the inline-caching system that allows for context-sensitive inlining of context-sensitive ICs. The combination of CacheIR and WarpBuilder have been powerful performance tools for the SpiderMonkey team\, and have been key in providing improved performance with less security risk.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T181655Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T104500Z
DTEND:20231022T110730Z
DTSTAMP:20231021T100631Z
UID:fac643d6-5247-4a12-99f9-082d7e0f4a3e@conf.researchr.org
CREATED:20230911T230804Z
SUMMARY:[MPLR] Diagnosing Compiler Performance by Comparing Optimization Decisions - Andrej Pečimúth\, David Leopoldseder\, Petr Tuma
DESCRIPTION:Modern compilers apply a set of optimization passes aiming to speed up the generated code. The combined effect of individual optimizations is difficult to predict. Thus\, changes to a compiler's code may hinder the performance of generated code as an unintended consequence. \nPerformance regressions in compiled code are often related to misapplied optimizations. The regressions are hard to investigate\, considering the vast number of compilation units and applied optimizations. A compilation unit consists of a root method and inlined methods. Thus\, a method may be part of several compilation units and may be optimized differently in each. Moreover\, inlining decisions are not invariant across runs of the virtual machine (VM). \nWe propose to solve the problem of diagnosing performance regressions by capturing the compiler's optimization decisions. We do so by representing the applied optimization phases\, optimization decisions\, and inlining decisions in the form of trees. This paper introduces an approach utilizing tree edit distance (TED) to detect optimization differences in a semi-automated way. We present an approach to compare optimization decisions in differently inlined methods. We employ these techniques to pinpoint the causes of performance problems in various benchmarks of the Graal compiler.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T181710Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T110730Z
DTEND:20231022T113000Z
DTSTAMP:20231021T100631Z
UID:a2a764d1-7892-4f80-a7d3-c4b674bfd529@conf.researchr.org
CREATED:20230911T230813Z
SUMMARY:[MPLR] Morello MicroPython: A Python Interpreter for CHERI - Duncan Lowther\, Dejice Jacob\, Jeremy Singer
DESCRIPTION:Arm Morello is a prototype system that supports CHERI hardware capabilities for improving runtime security. As Morello becomes more widely available\, there is a growing effort to port open source code projects to this novel platform. Although high-level applications generally need minimal code refactoring for CHERI compatibility\, low-level systems code bases require significant modification to comply with the stringent memory safety constraints that are dynamically enforced by Morello. In this paper\, we describe our work on porting the MicroPython interpreter to Morello with the CheriBSD OS. Our key contribution is to present a set of generic lessons for adapting managed runtime execution environments to CHERI\, including (1) a characterization of necessary source code changes\, (2) an evaluation of runtime performance of the interpreter on Morello\, and (3) a demonstration of pragmatic memory safety bug detection. Although MicroPython is a lightweight interpreter\, mostly written in C\, we believe that the changes we have implemented and the lessons we have learned are more widely applicable. To the best of our knowledge\, this is the first published description of meaningful experience for scripting language runtime engineering with CHERI and Morello.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T181734Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T100000Z
DTEND:20231022T103000Z
DTSTAMP:20231021T100631Z
UID:65a182c1-64ce-4d67-adb9-2076f02797df@conf.researchr.org
CREATED:20230915T203716Z
SUMMARY:[FTSCS] Probabilistic Risk Assessment of an Obstacle Detection System for GoA 4 Freight Trains - Mario Gleirscher\, Anne Haxthausen\, Jan Peleska
DESCRIPTION:We propose a quantitative risk assessment approach for the design of an obstacle detection function for low-speed freight trains with grade of automation 4. In this five-step approach\, starting with single detection channels and ending with a three-out-of-three model constructed of three independent dual-channel modules and a voter\, we exemplify a probabilistic assessment\, using a combination of statistical methods and parametric stochastic model checking. We illustrate that\, under certain not unreasonable assumptions\, the resulting hazard rate becomes acceptable for specific application settings. The statistical approach for assessing the residual risk of misclassifications in convolutional neural networks and conventional image processing software suggests that high confidence can be placed into the safety-critical obstacle detection function\, even though its implementation involves realistic machine learning uncertainties.
LOCATION:Room IV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052806Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T103000Z
DTEND:20231022T110000Z
DTSTAMP:20231021T100631Z
UID:aee9fa06-43c9-4db4-8124-728a5afc0ab7@conf.researchr.org
CREATED:20230915T203716Z
SUMMARY:[FTSCS] Solving Queries for Boolean Fault Tree Logic via Quantified SAT - Caz Saaltink\, Stefano M. Nicoletti\, Matthias Volk\, Ernst Moritz Hahn\, Marielle Stoelinga
DESCRIPTION:Fault trees (FTs) are hierarchical diagrams used to model the propagation of faults in a system. Fault tree analysis (FTA) is a widespread technique that allows to identify the key factors that contribute to system failure. In recent work we introduced BFL\, a Boolean Logic for Fault trees. BFL can be used to formally define simple yet expressive properties for FTA\, e.g.: 1) we can set evidence to analyse what-if scenarios\; 2) check whether two elements are independent or if they share a child that can influence their status\; 3) and set upper/lower boundaries for failed elements. Furthermore\, we provided algorithms based on binary decision diagrams (BDDs) to check BFL properties on FTs. In this work\, we evaluate usability of a different approach by employing quantified Boolean formulae (QBFs) instead of BDDs. We present a translation from BFL to QBF and provide an implementation—making it the first tool for checking BFL properties—that builds on top of the Z3 solver. We further demonstrate its usability on a case study FT and investigate runtime\, memory consumption and scalability on a number of benchmark FTs. Lastly\, qualitative differences from a BDD-based approach are discussed.
LOCATION:Room IV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052806Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T110000Z
DTEND:20231022T113000Z
DTSTAMP:20231021T100631Z
UID:e59075f1-41fb-453d-b505-3de320281577@conf.researchr.org
CREATED:20230915T203716Z
SUMMARY:[FTSCS] Symbolic analysis by using folding narrowing with irreducibility and SMT constraints - Santiago Escobar\, Raul Lopez\, Julia Sapiña
DESCRIPTION:Symbolic reachability analysis using rewriting with Satisfiability Modulo Theories (SMT) has been used to model different systems\, including a variety of security protocols. Recently\, it has also been used to analyze Parametric Timed Automata (PTAs). These techniques are based on reachability in a finite state graph generated from concrete initial states where each generated state is constrained by a SMT expression checked for satisfiability. In this work\, we propose to generate a finite state graph not by rewriting with SMT but by narrowing with SMT. Narrowing with SMT allows a greater generalization\, since (i) an infinite number of initial states can be represented by a finite number of states with variables\, not only SMT variables\, and (ii) an infinite state graph from a concrete initial state may be represented by a finite state graph from an initial state with variables. We use graph search pruning techniques via irreducible terms and SMT constraints on conditional rules. This is supported by a novel folding SMT narrowing technique to represent infinite computations in a finite way. Additionally\, we present a new textual user interface that allows the use of the algorithm in a simpler and more readable way.
LOCATION:Room IV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052806Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T100000Z
DTEND:20231022T103000Z
DTSTAMP:20231021T100631Z
UID:95b759f9-7dfc-42d5-a504-c9e69147573e@conf.researchr.org
CREATED:20230913T185126Z
SUMMARY:[HATRA] Diagrammatic notations for interactive theorem proving - Shardul Chiplunkar\, Clément Pit-Claudel
DESCRIPTION:Diagrams are ubiquitous in the development and presentation of proofs\, yet surprisingly uncommon in computerized mathematics. Instead\, authors and developers rely almost exclusively on line-oriented notations (textual abbreviations and symbols). How might we enrich interactive theorem provers with on-the-fly visual aids that are just as usable? We answer this question by identifying a key challenge: designing declarative languages for composable diagram templates\, that provide good-looking implementations of common patterns\, and allow for rapid prototyping of diagrams that remain stable across transformations and proof steps.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053158Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T103000Z
DTEND:20231022T110000Z
DTSTAMP:20231021T100631Z
UID:2c2c6af8-68d3-498f-b12d-d8624c37f44f@conf.researchr.org
CREATED:20230913T185126Z
SUMMARY:[HATRA] Exploratory Study on Multi-User Program Synthesis: A Multi-Wizard Approach - Tyler Holloway\, Nada Amin\, Elena Glassman
DESCRIPTION:Program synthesis is a research area focused on automatically generating computer programs that meet specific specifications or requirements. Despite its potential applications in various domains\, including biological discovery and program repair\, current program synthesis systems face a limitation: they primarily rely on input from a single user\, neglecting the collaborative and distributed nature of software engineering. In this paper\, we introduce a design experiment aimed at exploring the collaborative potential and effectiveness of multi-user program synthesis. This experiment is part of our ongoing research\, and we plan to conduct it in the future.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053158Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T110000Z
DTEND:20231022T113000Z
DTSTAMP:20231021T100631Z
UID:7d9dcfe1-a417-472d-bfe9-12b515ddbe69@conf.researchr.org
CREATED:20230913T185126Z
SUMMARY:[HATRA] Latte: Lightweight Aliasing Tracking for Java - Conrad Zimmerman\, Catarina Gamboa\, Alcides Fonseca\, Jonathan Aldrich
DESCRIPTION:Many existing systems track aliasing and uniqueness\, each with their own trade-off between expressiveness and developer effort. \nWe propose Latte\, which aims to minimize both the amount of annotations and the complexity of invariants necessary for reasoning about aliasing in an object-oriented language with mutation. Our approach only requires annotations for parameters and fields\, while annotations for local variables are inferred. Furthermore\, it relaxes uniqueness to allow aliasing among local variables\, as long as this aliasing can be precisely determined. This enables support for destructive reads without changes to the language or its run-time semantics. \nDespite this simplicity\, we show how this design can still be used for tracking uniqueness and aliasing in a local sequential setting\, with practical applications\, such as modeling a stack.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053158Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T100000Z
DTEND:20231022T113000Z
DTSTAMP:20231021T100631Z
UID:df15c48c-3cbf-4ef9-94c9-9870241f22d7@conf.researchr.org
CREATED:20230929T194834Z
SUMMARY:[ST30 ] Beyond Types for Dyadic Interaction - Nobuko Yoshida
DESCRIPTION:In this talk\, I give the origin and 30 years journey of session types using Kohei Honda’s slides on types for interactions. I then give a tribute to the Princess of Session Types. The talk also poses the question–why the session types are continuously studied and developed among other behavioural types.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231010T201452Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T100000Z
DTEND:20231022T103000Z
DTSTAMP:20231021T100631Z
UID:b19f12aa-1ca3-453d-9852-ee215ff465b0@conf.researchr.org
CREATED:20231012T174134Z
SUMMARY:[GPCE] GPCE Welcome by Chairs - Amir Shaikhha\, Coen De Roover
DESCRIPTION:
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T140850Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T103000Z
DTEND:20231022T110000Z
DTSTAMP:20231021T100631Z
UID:d3410e0a-3653-40d8-97f3-757a8dfb3354@conf.researchr.org
CREATED:20231012T174134Z
SUMMARY:[GPCE] Generating Conforming Programs With Xsmith - William G Hatch\, Pierce Darragh\, Sorawee Porncharoenwase\, Guy Watson\, Eric Eide
DESCRIPTION:Fuzz testing is an effective tool for finding bugs in software\, including programming language compilers and interpreters. Advanced fuzz testers can find deep semantic bugs in language implementations through differential testing. However\, input programs used for differential testing must not only be syntactically and semantically valid\, but also be free from nondeterminism and undefined or unspecified behaviors. Developing a fuzzer that produces such programs can require tens of thousands of lines of code and hundreds of person-hours. Despite this significant investment\, fuzzers designed for differential testing of different languages include many of the same features and analyses in their implementations. To make the implementation of language fuzz testers for differential testing easier\, we introduce Xsmith. \nXsmith is a Racket library and domain-specific language that provides mechanisms for implementing a feature-complete fuzz tester in only a few hundred lines of code. By sharing infrastructure\, allowing declarative language specification\, and by allowing procedural extensions\, Xsmith allows developers to write correct fuzzers for differential testing with little effort. We have developed fuzzers for several languages\, and found bugs in implementations of Racket\, Dafny\, Standard ML\, and WebAssembly.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231012T174428Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T110000Z
DTEND:20231022T113000Z
DTSTAMP:20231021T100631Z
UID:284eeee4-d8e8-4373-9628-4938fe2a826a@conf.researchr.org
CREATED:20231012T174134Z
SUMMARY:[GPCE] Multi-Stage Vertex-Centric Programming for Agent-Based Simulations - Zilu Tian
DESCRIPTION:In vertex-centric programming\, users express a graph algorithm as a vertex program and specify the iterative behavior of a vertex in a ${compute}$ function\, which is executed by all vertices in a graph in parallel\, synchronously in a sequence of supersteps. While this programming model is straightforward for simple algorithms where vertices behave the same in each superstep\, for complex vertex programs where vertices have different behavior across supersteps\, a vertex needs to frequently dispatch on the value of supersteps in ${compute}$\, which suffers from unnecessary interpretation overhead and complicates the control flow. \nWe address this using meta-programming: Instead of branching on the value of a superstep\, users separate instructions that should be executed in different supersteps via a staging-time ${wait}$ instruction. When a superstep starts\, computations in a vertex program resume from the last execution point\, and continue executing until the next $wait$. We implement this in CloudCity and show that avoiding the interpretation overhead caused by dispatching on the value of a superstep can improve the performance by up to 20%.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231012T174350Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T130000Z
DTEND:20231022T143000Z
DTSTAMP:20231021T100631Z
UID:cc9f4e87-02ad-4a11-95a9-1954a3a3a1a8@conf.researchr.org
CREATED:20230916T195650Z
SUMMARY:[PPDP] 10-Year Most Influential Paper Talk: Coq: the world's best macro assembler? - Andrew Kennedy\, Nick Benton\, Jonas Jensen\, Pierre-Evariste Dagand
DESCRIPTION:We describe a Coq formalization of a subset of the x86 architecture. One emphasis of the model is brevity: using dependent types\, type classes and notation we give the x86 semantics a makeover that counters its reputation for baroqueness. We model bits\, bytes\, and memory concretely using functions that can be computed inside Coq itself\; concrete representations are mapped across to mathematical objects in the SSReflect library (naturals\, and integers modulo 2n) to prove theorems. Finally\, we use notation to support conventional assembly code syntax inside Coq\, including lexically-scoped labels. Ordinary Coq definitions serve as a powerful “macro” feature for everything from simple conditionals and loops to stack-allocated local variables and procedures with parameters. Assembly code can be assembled within Coq\, producing a sequence of hex bytes. The assembler enjoys a correctness theorem relating machine code in memory to a separation-logic formula suitable for program verification.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053023Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T130000Z
DTEND:20231022T133000Z
DTSTAMP:20231021T100631Z
UID:2b1d8a56-2f4f-434c-82c8-1d725671f113@conf.researchr.org
CREATED:20230918T142032Z
SUMMARY:[SAS ] Generalized Program Sketching by Abstract Interpretation and Logical Abduction - Aleksandar S. Dimovski
DESCRIPTION:This paper presents a new approach for synthesizing missing parts from imperative programs by using abstract interpretation and logical abduction. Given a partial program with missing arbitrary expressions\, our approach synthesizes concrete expressions that are strong enough to prove the assertions in the given program. Furthermore\, the synthesized elements by our approach are the simplest and the weakest among all possible that guarantee the validity of assertions. In particular\, we use a combination of forward and backward numerical analyses based on abstract interpretation to generate constraints that are solved by using the logical abduction technique. \nWe have implemented our approach in a prototype synthesis tool for C programs\, and we show that the proposed approach is able to successfully synthesize arithmetic and boolean expressions for various C programs.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T174014Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T133000Z
DTEND:20231022T140000Z
DTSTAMP:20231021T100631Z
UID:d074b2b0-1e40-45ac-9ff6-bcaaae7f2d44@conf.researchr.org
CREATED:20230918T142032Z
SUMMARY:[SAS ] Reverse Template Processing using Abstract Interpretation - Matthieu Lemerre
DESCRIPTION:Template languages transform tree-structured data into text. We study the reverse problem\, transforming the template into a parser that returns all the tree-structured data that can produce a given text. Programs written in template languages are generally not injective (they have multiple preimages)\, not affine (some input variables can appear at several locations in the output)\, and erasing (they provide only a partial view of the source)\, which makes the problem challenging. We propose to solve this problem using concepts from abstract interpretation\, like the denotational style of abstract semantics\, soundness\, exactness\, or reduction\, to reason about the precision and the recovery of all the preimages. This work shows that Abstract Interpretation is a very useful theory when reasoning about the reversal of non-injective programs.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052444Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T140000Z
DTEND:20231022T143000Z
DTSTAMP:20231021T100631Z
UID:a17c04ba-761e-4557-9790-cb40e9c63b78@conf.researchr.org
CREATED:20230918T142032Z
SUMMARY:[SAS ] BREWasm: A General Static Binary Rewriting Framework for WebAssembly - Shangtong Cao\, Ningyu He\, Yao Guo\, Haoyu Wang
DESCRIPTION:Binary rewriting is a widely adopted technique in software analysis. WebAssembly (Wasm)\, as an emerging bytecode format\, has attracted great attention from our community. Unfortunately\, there is no general-purpose binary rewriting framework for Wasm\, and existing effort on Wasm binary modification is error-prone and tedious. In this paper\, we present BREWasm\, the first general purpose static binary rewriting framework for Wasm\, which has addressed inherent challenges of Wasm rewriting including high complicated binary structure\, strict static syntax verification\, and coupling among sections. We perform extensive evaluation on diverse Wasm applications to show the efficiency\, correctness and effectiveness of BREWasm. We further show the promising direction of implementing a diverse set of binary rewriting tasks based on BREWasm in an effortless and user-friendly manner.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052444Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T130000Z
DTEND:20231022T132230Z
DTSTAMP:20231021T100631Z
UID:1f6120d0-ca91-4577-b92f-cedcbf079b33@conf.researchr.org
CREATED:20230911T230927Z
SUMMARY:[MPLR] A Multifaceted Memory Analysis of Java Benchmarks - Orion Papadakis\, Andreas Andronikakis\, Nikos Foutris\, Michail Papadimitriou\, Athanasios Stratikopoulos\, Foivos S. Zakkak\, Polychronis Xekalakis\, Christos Kotselidis
DESCRIPTION:Java benchmarking suites like Dacapo and Renaissance are employed by the research community to evaluate the performance of novel features in managed runtime systems. These suites encompass various applications with diverse behaviors in order to stress test different subsystems of a managed runtime. Therefore\, understanding and characterizing the behavior of these benchmarks is important when trying to interpret experimental results. \nThis paper presents an in-depth study of the memory behavior of 30 Dacapo and Renaissance applications. To realize the study\, a characterization methodology based on a two-faceted profiling process of the Java applications is employed. The two-faceted profiling offers comprehensive insights into the memory behavior of Java applications\, as it is composed of high-level and low-level metrics obtained through a Java object profiler (NUMAProfiler) and a microarchitectural event profiler (PerfUtil) of MaxineVM\, respectively. By using this profiling methodology we classify the Dacapo and Renaissance applications regarding their intensity in object allocations\, object accesses\, LLC\, and main memory pressure. In addition\, several other aspects such as the JVM impact on the memory behavior of the application are discussed.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T181747Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T132230Z
DTEND:20231022T134500Z
DTSTAMP:20231021T100631Z
UID:f0841c73-7703-4571-a1c5-fc59c0364e02@conf.researchr.org
CREATED:20230911T231032Z
SUMMARY:[MPLR] Improving Garbage Collection Observability with Performance Tracing - Claire Huang\, Stephen M. Blackburn\, Zixian Cai
DESCRIPTION:Debugging garbage collectors for performance and correctness is notoriously difficult. Among the arsenal of tools available to systems engineers\, support for one of the most powerful\, tracing\, is lacking in most garbage collectors. Instead\, engineers must rely on counting\, sampling\, and logging. Counting and sampling are limited to statistical analyses while logging is limited to hard-wired metrics. This results in cognitive friction\, curtailing innovation and optimization. \nWe demonstrate that tracing is well suited to GC performance debugging. We leverage the modular design of MMTk to deliver a powerful VM and collector-neutral tool. We find that tracing allows: cheap insertion of tracepoints—just 14 lines of code and no measurable run-time overhead\, decoupling of the declaration of tracepoints from tracing logic\, high fidelity measurement able to detect subtle performance regressions\, while also allowing interrogation of a running binary. \nOur tools crisply highlight several classes of performance bug\, such as poor scalability in multi-threaded GCs\, and lock contention in the allocation sequence. These observations uncover optimization opportunities in collectors\, and even reveal bugs in application programs. \nWe showcase tracing as a powerful tool for GC designers and practitioners. Tracing can uncover missed opportunities and lead to novel algorithms and new engineering practices.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T182052Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T134500Z
DTEND:20231022T140730Z
DTSTAMP:20231021T100631Z
UID:64d5a2e2-7af6-4521-9e87-654aa2e8c6da@conf.researchr.org
CREATED:20230911T231044Z
SUMMARY:[MPLR] Don’t Trust Your Profiler: An Empirical Study on the Precision and Accuracy of Java Profilers - Humphrey Burchell\, Octave Larose\, Sophie Kaleba\, Stefan Marr
DESCRIPTION:To identify optimisation opportunities\, Java developers often use sampling profilers that attribute a percentage of run time to the methods of a program. Even so these profilers use sampling\, are probabilistic in nature\, and may suffer for instance from safepoint bias\, they are normally considered to be relatively reliable. However\, unreliable or inaccurate profiles may misdirect developers in their quest to resolve performance issues by not correctly identifying the program parts that would benefit most from optimisations. \nWith the wider adoption of profilers such as async-profiler and Honest Profiler\, which are designed to avoid the safepoint bias\, we wanted to investigate how precise and accurate Java sampling profilers are today. We investigate the precision\, reliability\, accuracy\, and overhead of async-profiler\, Honest Profiler\, Java Flight Recorder\, JProfiler\, perf\, and YourKit\, which are all actively maintained. We assess them on the fully deterministic Are We Fast Yet benchmarks to have a stable foundation for the probabilistic profilers. \nWe find that profilers are relatively reliable over 30 runs and normally report the same hottest method. Unfortunately\, this is not true for all benchmarks\, which suggests their reliability may be application-specific. Different profilers also report different methods as hottest and cannot reliably agree on the set of top 5 hottest methods. On the positive side\, the average run time overhead is in the range of 1% to 5.4% for the different profilers. \nFuture work should investigate how results can become more reliable\, perhaps by reducing the observer effect of profilers by using optimisation decisions of unprofiled runs or by developing a principled approach of combining multiple profiles that explore different dynamic optimisations.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T182120Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T140730Z
DTEND:20231022T143000Z
DTSTAMP:20231021T100631Z
UID:50410fab-e5d3-4a93-9e74-0ce72a733c86@conf.researchr.org
CREATED:20230915T183551Z
SUMMARY:[MPLR] Heap Size Adjustment with CPU Control - Sanaz Tavakolisomeh\, Marina Shimchenko\, Erik Österlund\, Rodrigo Bruno\, Paulo Ferreira\, Tobias Wrigstad
DESCRIPTION:This paper explores automatic heap sizing where developers let the frequency of GC expressed as a target overhead of the application's CPU utilisation\, control the size of the heap\, as opposed to the other way around. Given enough headroom and spare CPU\, a concurrent garbage collector should be able to keep up with the application's allocation rate\, and neither the frequency nor duration of GC should impact throughput and latency. Because of the inverse relationship between time spent performing garbage collection and the minimal size of the heap\, this enables trading memory for computation and conversely\, neutral to an application's performance. \nWe describe our proposal for automatically adjusting the size of a program's heap based on the CPU overhead of GC. We show how our idea can be relatively easily integrated into ZGC\, a concurrent collector in OpenJDK\, and study the impact of our approach on memory requirements\, throughput\, latency\, and energy.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T182139Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T130000Z
DTEND:20231022T133000Z
DTSTAMP:20231021T100631Z
UID:7b3ebce4-c9f4-4c16-ba36-16b01947309c@conf.researchr.org
CREATED:20230915T203735Z
SUMMARY:[FTSCS] Does Rust SPARK Joy? Safe Bindings from Rust to SPARK\, Applied to the BBQueue Library - Aïssata Maiga\, Cyrille Artho\, Florian Gilcher\, Yannick Moy
DESCRIPTION:Both Rust and SPARK are memory-safe programming languages and feature stronger safety guarantees than other popular programming languages for embedded software. However\, modern systems often combine software written in multiple programming languages using the Foreign Function Interface (FFI). When using safety-oriented programming languages such as Rust and SPARK\, maintaining compile-time safety guarantees across a language boundary is a challenge. The objective of this study is to explore if/how the inherent safety guarantees of these languages are preserved\, and their potential benefits when establishing a library interface between them. In particular\, we apply our method to the BBQueue circular buffer library that features complex ownership hand-over patterns when using FFI. Results reveal that most of the inherent consistency and safety features of these languages can be maintained. Yet\, special caution is required at the FFI boundary to prevent potential vulnerabilities.
LOCATION:Room IV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052810Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T133000Z
DTEND:20231022T140000Z
DTSTAMP:20231021T100631Z
UID:9c80c55d-09e9-43f3-a304-8a3535b33f64@conf.researchr.org
CREATED:20230915T203735Z
SUMMARY:[FTSCS] Formal Verification of a Mechanical Ventilator using UPPAAL - Jaime Cuartas\, David Cortés\, Joan S Betancourt\, Jesus Aranda\, Jose Garcia\, Andres Valencia\, James Ortiz
DESCRIPTION:Mechanical ventilators are increasingly used for life support of critically ill patients. In this sense\, despite recent technological advances\, the accurate specification of their properties remains challenging\, and the use of formal tools is limited. This work focuses on verifying the properties of the architecture of a mechanical ventilator using UPPAAL as a modeling tool. As a result\, the system requirements and specification of a functional prototype were verified and improved using the formal model of a mechanical ventilator. This approach provides a valuable means of ensuring the correctness and reliability of mechanical ventilator systems.
LOCATION:Room IV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052810Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T140000Z
DTEND:20231022T143000Z
DTSTAMP:20231021T100631Z
UID:523c1562-5b99-4f22-9f20-24f938ca2173@conf.researchr.org
CREATED:20230915T203837Z
SUMMARY:[FTSCS] Discussions\, Closing - Peter Ölveczky\, Cyrille Artho
DESCRIPTION:
LOCATION:Room IV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052810Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T130000Z
DTEND:20231022T133000Z
DTSTAMP:20231021T100631Z
UID:98e20bf7-347b-4a63-8b64-080d4ab42ab7@conf.researchr.org
CREATED:20230913T184528Z
SUMMARY:[HATRA] Debugging Trait Errors as Logic Programs - Gavin Gray\, Will Crichton
DESCRIPTION:Rust uses traits to define units of shared behavior. Trait constraints build up an implicit set of first-order hereditary Harrop clauses which is executed by a powerful logic programming engine in the trait system. But that power comes at a cost: the number of traits in Rust libraries is increasing\, which puts a growing burden on the trait system to help programmers diagnose errors. Beyond a certain size of trait constraints\, compiler diagnostics fall off the edge of a complexity cliff\, leading to useless error messages. Crate maintainers have created ad-hoc solutions to diagnose common domain-specific errors\, but the problem of diagnosing trait errors in general is still open. We propose a trait debugger as a means of getting developers the information necessary to diagnose trait errors in any domain and at any scale. Our proposed tool will extract proof trees from the trait solver\, and it will interactively visualize these proof trees to facilitate debugging of trait errors.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053203Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T133000Z
DTEND:20231022T140000Z
DTSTAMP:20231021T100631Z
UID:0ebef689-5178-4644-9968-7fc1177f0563@conf.researchr.org
CREATED:20230913T184528Z
SUMMARY:[HATRA] Totally Live Programming with Hazel (Progress Report) - Cyrus Omar\, Andrew Blinn\, David Moon
DESCRIPTION:The proposed talk will review progress on the Hazel programming environment and its underlying theoretical developments. Hazel is the first totally live typed general-purpose programming environment\, meaning that it deploys error localization and recovery mechanisms\, rooted in language-theoretic developments\, that ensure that every editor state is syntactically well-structured and statically and dynamically meaningful. The talk will review the underlying theory and include a live demonstration of Hazel’s various features. Hazel has been deployed in an educational setting\, and we will review both the educational technology aspects and the preliminary results of using Hazel with humans for the first time. The talk will also discuss various ongoing and future directions.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053203Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T140000Z
DTEND:20231022T143000Z
DTSTAMP:20231021T100631Z
UID:8ae6046f-8e4f-4580-9997-cf52e2805798@conf.researchr.org
CREATED:20230913T184528Z
SUMMARY:[HATRA] REVIS: An Error Visualization Tool for Rust - Ruochen Wang\, Molly MacLaren\, Michael Coblenz
DESCRIPTION:Rust is a programming language that uses a concept of ownership to guarantee memory safety without the use of a garbage collector. However\, some error messages related to ownership can be difficult to understand and fix\, particularly those that depend on value lifetimes. To help developers fix lifetime-related errors\, we developed REVIS\, a VSCode extension that visualizes lifetime-related Rust compiler errors. We describe the design and implementation of the VSCode extension\, along with a preliminary evaluation of its efficacy for student learners of Rust. Although the number of participants was too low to enable evaluation of the efficacy of REVIS\, we gathered data regarding the prevalence and time to fix the compiler errors that the participants encountered.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T043458Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T130000Z
DTEND:20231022T133000Z
DTSTAMP:20231021T100631Z
UID:07c1c989-dfe7-41c5-886c-99ce079d2b98@conf.researchr.org
CREATED:20230913T164935Z
SUMMARY:[ST30 ] CAPABLE: A Mechanised Imperative Language with Native Multiparty Session Types - Jan de Muijnck-Hughes\, Cristian Urlea\, Adriana Laura Voinea\, Wim Vanderbauwhede
DESCRIPTION:CAPABLE is lightweight mechanised imperative language that provides native support for Multiparty Session Types (MPSTs). Through mechanisation\, we can explore and catalogue the changes required to extend similar languages with native support for MPSTs\, as well as the interplay between the existing type-system and other novel extensions. Principally\, our demo shows CAPABLE in action and what a language with native MPSTs can look like. We also look beneath the surface syntax and offer insight over how we created intrinsically typed sessions (and session types) within a dependently typed language. We show a compact well-scoped encoding of session types\, mechanised proofs of soundness and completeness for projection\, and how dependent types help with bidirectional type checking of typed sessions.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230913T174216Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T133000Z
DTEND:20231022T140000Z
DTSTAMP:20231021T100631Z
UID:360a730c-45ec-4b79-a0aa-77c944820874@conf.researchr.org
CREATED:20230913T164935Z
SUMMARY:[ST30 ] Complete Multiparty Session Type Projection with Automata - Felix Stutz
DESCRIPTION:Multiparty session types (MSTs) are an efficient approach to verifying (asynchronous) communication protocols. In this work\, we consider MST frameworks with a projection operator\, i.e. a partial function that maps protocols represented as global types to correct-by-construction implementations for each participant. Existing projection operators trade efficiency for completeness. Our work provides the first projection operator that is sound\, complete\, and efficient. Our approach to projection separates synthesis from checking implementability. For synthesis\, we use a simple automata-theoretic construction\; for checking implementability\, we present succinct conditions that summarize insights into the property of implementability. We use these conditions to show that asynchronous MST implementability is PSPACE-complete. Our prototype implementation demonstrates the effectiveness of our approach and handles global types not supported by previous work without sacrificing performance. \nThis is joint work with Elaine Li (New York University)\, Thomas Wies (New York University)\, and Damien Zufferey (Sonar Source) and appeared in the proceedings of the 35th International Conference on Computer Aided Verification (CAV 2023).
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230913T174216Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T140000Z
DTEND:20231022T143000Z
DTSTAMP:20231021T100631Z
UID:3da8b4ed-a603-46cf-9716-6289a8639905@conf.researchr.org
CREATED:20230913T164935Z
SUMMARY:[ST30 ] Multiparty Reactive Sessions - Ilaria Castellani\, Cinzia Di Giusto\, Jorge A. Pérez
DESCRIPTION:Ensuring that message-passing systems interact according to an intended protocol is a challenging problem\, particularly for systems with some reactive or timed components. To rise to this challenge\, we study the integration of session-based concurrency and Synchronous Reactive Programming (SRP). We propose MRS\, a new process calculus for multiparty sessions enriched with features from SRP. In MRS\, protocol participants may broadcast messages\, suspend themselves while waiting for a message\, and react to events. Our main contribution is a session type system for MRS\, which enforces session correctness (protocol conformance) and additionally ensures input timeliness\, a time-related property that entails livelock-freedom. As a result\, our type system departs significantly from existing ones\, specifically as it captures the notion of “logical instant” typical of SRP.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230913T174216Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T130000Z
DTEND:20231022T133000Z
DTSTAMP:20231021T100631Z
UID:b5527b6e-4d83-4aaf-91ae-16e04ea202ba@conf.researchr.org
CREATED:20230918T135704Z
SUMMARY:[GPCE] A pred-LL(*) Parsable Typed Higher-Order Macro System for Architecture Description Languages - Christoph Hochrainer\, Andreas Krall
DESCRIPTION:Macro systems are powerful language extension tools for Architecture Description Languages (ADLs). Their generative power in combination with the simplicity of specification languages allows for a substantial reduction of repetitive specification sections. This paper explores how the introduction of function- and record types in a template-based macro system impacts the specification of ADLs. We present design and implementation of a pattern-based syntax macro system for the Vienna Architecture Description Language (VADL). The macro system is directly integrated into the language and is analyzed at parse time using a context-sensitive pred-LL(*) parser. The usefulness of the macro system is illustrated by some typical macro application design patterns. The effectiveness is shown by a detailed evaluation of the Instruction Set Architecture (ISA) specification of five different processor architectures. The observed specification reduction can be up to 90 times\, leading to improved maintainability\, readability and runtime performance of the specifications.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231014T172844Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T133000Z
DTEND:20231022T140000Z
DTSTAMP:20231021T100631Z
UID:b6d430ab-d865-465e-a3b9-b3b55bf5d8db@conf.researchr.org
CREATED:20230918T135704Z
SUMMARY:[GPCE] A Monadic Framework for Name Resolution in Multi-Phased Type Checkers - Casper Bach Poulsen\, Aron Zwaan\, Paul Hübner
DESCRIPTION:An important aspect of type checking is name resolution—i.e.\, determining the types of names by resolving them to a matching declaration. For most languages\, we can give typing rules that define name resolution in a way that abstracts from what order different units of code should be checked in. However\, implementations of type checkers in practice typically use multiple phases to ensure that declarations of resolvable names are available before names are resolved. This gives rise to a gap between typing rules that abstract from order of type checking and multi-phased type checkers that rely on explicit ordering. \nThis paper introduces techniques that reduce this gap. First\, we introduce a monadic interface for phased name resolution which detects and rejects type checking runs with name resolution phasing errors where names were wrongly resolved because some declarations were not available when they were supposed to be. Second\, building on recent work by Gibbons et al.\, we use applicative functors to compositionally map abstract syntax trees onto (phased) monadic computations that represent typing constraints. These techniques reduce the gap between type checker implementations and typing rules in the sense that (1) both are given by compositional mappings over abstract syntax trees\, and (2) type checker cases consist of computations that roughly correspond to typing rule premises\, except these are composed using monadic combinators. We demonstrate our approach by implementing type checkers for Mini-ML with Damas-Hindley-Milner type inference\, and LM\, a toy module language with a challenging import resolution policy.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231012T174219Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T140000Z
DTEND:20231022T143000Z
DTSTAMP:20231021T100631Z
UID:1f13dd9e-0ed3-43e8-8a34-feaf6c0d71ba@conf.researchr.org
CREATED:20231012T174219Z
SUMMARY:[GPCE] C2TACO: Lifting Tensor Code to TACO - José Wesley De Souza Magalhães\, Jackson Woodruff\, Elizabeth Polgreen\, Michael F. P. O'Boyle
DESCRIPTION:Domain-specific languages (DSLs) promise a significant performance and portability advantage over traditional languages. DSLs are designed to be high-level and platform-independent\, allowing an optimizing compiler significant leeway when targeting a particular device. Such languages are particularly popular with emerging tensor algebra workloads. However\, DSLs present their own challenge: they require programmers to learn new programming languages and put in significant effort to migrate legacy code. \nWe present C2TACO\, a synthesis tool for synthesizing TACO\, a well-known tensor DSL\, from C code. We develop a smart\, enumerative synthesizer that uses automatically generated IO examples and source-code analysis to efficiently generate code. C2TACO is able to synthesize 95% bench marks from a tensor benchmark suite\, out-performing an alternative neural machine translation technique\, and demonstrates substantially higher levels of accuracy when evaluated against two state-of-the-art existing schemes\, TF-Coder and ChatGPT. Our synthesized TACO programs are\, by design\, portable achieving significant performance improvement when evaluated on a multi-core and GPU platform.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231012T174428Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T150000Z
DTEND:20231022T153000Z
DTSTAMP:20231021T100631Z
UID:bc88b793-05e2-4aa7-9849-891ddcd6e2c5@conf.researchr.org
CREATED:20230916T195701Z
SUMMARY:[PPDP] Type-directed Program Transformation for Constant-Time Enforcement - Gautier Raimondi\, Frédéric Besson\, Thomas P. Jensen
DESCRIPTION:Constant-time is a programming discipline which protects cryptographic code against a wide class of timing attacks. This discipline can be formalised as a non-interference property and enforced by an information flow type system which prevents branching and memory accesses over secret data. We propose a relaxed information flow type system which tracks indirect flows but only rejects programs leaking secrets through direct flows. The main result of this paper is that any program that is accepted using this relaxed type system can be transformed automatically into a semantically equivalent constant-time program. Our algorithms are implemented in the jasmin compiler and validated against representative programs.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053029Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T153000Z
DTEND:20231022T160000Z
DTSTAMP:20231021T100631Z
UID:8d735634-214f-4144-b20f-412e3ffe9e60@conf.researchr.org
CREATED:20230916T195701Z
SUMMARY:[PPDP] Data-Dependent Confidentiality in DCR Graphs - Eduardo Geraldo\, João Costa Seco\, Thomas T. Hildebrandt
DESCRIPTION:We present DCRSec\, a confidentially aware declarative process language with data that employs data-dependent security levels and an information flow monitor that prevents the violation of information flow policies. Data-dependent security levels have been used to shape precise information flow policies and properly identify security compartments. We use an illustrative example to show that it also models process instances in a flexible but precise way. The semantics of the language is based on a version of the Dynamic Condition Response Graph language\, which allows for declaring data-aware\, event-based processes with finitary and infinitary computations subject to liveness properties and allowing dynamically spawned sub-processes. The key technical contribution is to provide a termination-insensitive information flow monitor and prove non-interference\, a soundness property\, and transparency in all traces of DCRSec processes.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053029Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T160000Z
DTEND:20231022T163000Z
DTSTAMP:20231021T100631Z
UID:bdf96ed5-56a3-4802-bd25-2c0e175f283f@conf.researchr.org
CREATED:20230916T195800Z
SUMMARY:[PPDP] ---
DESCRIPTION:
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053029Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T150000Z
DTEND:20231022T153000Z
DTSTAMP:20231021T100631Z
UID:66847e60-1ad4-4c8f-ac4a-67787b0aff87@conf.researchr.org
CREATED:20230918T141314Z
SUMMARY:[SAS ] Quantum Constant Propagation - Yanbin Chen\, Yannick Stade
DESCRIPTION:A quantum circuit is often executed on the initial state where each qubit is in the zero state. Therefore\, we propose to perform a symbolic execution of the circuit. Our approach simulates groups of entangled qubits exactly up to a given complexity. Here\, the complexity corresponds to the number of basis states expressing the quantum state of one entanglement group. By doing that\, the groups need neither be determined upfront nor be bound by the number of involved qubits. Still\, we ensure that the simulation runs in polynomial time—opposed to exponential time as required for the simulation of the entire circuit. The information made available at gates is exploited to remove superfluous controls and gates. We implemented our approach in the tool quantum constant propagation (QCP) and evaluated it on the circuits in the benchmark suite MQTBench. By applying our tool\, only the work that cannot be carried out efficiently on a classical computer is left for the quantum computer\, hence exploiting the strengths of both worlds.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052449Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T153000Z
DTEND:20231022T160000Z
DTSTAMP:20231021T100631Z
UID:5b5b7764-74b3-4234-b7fe-430337b60dc5@conf.researchr.org
CREATED:20230918T141314Z
SUMMARY:[SAS ] Boosting Multi-Neuron Convex Relaxation for Neural Network Verification - Xuezhou Tang\, Ye Zheng\, Jiaxiang Liu
DESCRIPTION:Formal verification of neural networks is essential for their deployment in safety-critical real-world applications\, such as autonomous driving and cyber-physical controlling. Multi-neuron convex relaxation is one of the mainstream methods to improve verification precision. However\, existing techniques rely on empirically selecting neuron groups before performing multi-neuron convex relaxation\, which may yield redundant yet expensive convex hull computations. This paper proposes a volume approximation-based approach for selecting neuron groups. We approximate the volumes of convex hulls for all group candidates\, without calculating their convex hulls. The group candidates with small volumes are then selected for convex hull computation\, aiming at ruling out unnecessary convex hulls with loose relaxation. We implement our approach as the neural network verification tool FaGMR\, and evaluate it with state-of-the-art tools on neural networks trained by MNIST and CIFAR-10. The experimental results demonstrate that FaGMR is more efficient than the state-of-the-art works\, yet with better precision in most of the cases.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052449Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T150000Z
DTEND:20231022T152200Z
DTSTAMP:20231021T100631Z
UID:44581138-90dd-453a-8c95-2601227b6917@conf.researchr.org
CREATED:20230911T231134Z
SUMMARY:[MPLR] Comparing Rapid Type Analysis with Points-To Analysis in GraalVM Native Image - David Kozak\, Vojin Jovanovic\, Codrut Stancu\, Tomáš Vojnar\, Christian Wimmer
DESCRIPTION:Whole-program analysis is an essential technique that enables advanced compiler optimizations. An important example of such a method is points-to analysis used by ahead-of-time (AOT) compilers to discover program elements (classes\, methods\, fields) used on at least one program path. GraalVM Native Image uses a points-to analysis to optimize Java applications\, which is a time-consuming step of the build. We explore how much the analysis time can be improved by replacing the points-to analysis with a rapid type analysis (RTA)\, which computes reachable elements faster by allowing more imprecision. We propose several extensions of previous approaches to RTA: making it parallel\, incremental\, and supporting heap snapshotting. We present an extensive experimental evaluation of the effects of using RTA instead of points-to analysis\, in which RTA allowed us to reduce the analysis time for Spring Petclinic (a popular demo application of the Spring framework) by 64% and the overall build time by 35% at the cost of increasing the image size due to the imprecision by 15%.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T182203Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T152200Z
DTEND:20231022T154500Z
DTSTAMP:20231021T100631Z
UID:514f2a4a-dbfa-45d8-a27b-2f020b4ea931@conf.researchr.org
CREATED:20230915T183531Z
SUMMARY:[MPLR] Unified Shared Memory: Friend or Foe? Understanding the Implications of Unified Memory on Managed Heaps - Juan Fumero\, Florin Blanaru\, Athanasios Stratikopoulos\, Steve Dohrmann\, Sandhya Viswanathan\, Christos Kotselidis
DESCRIPTION:Adopting heterogeneous execution on GPUs and FPGAs in managed runtime systems\, such as Java\, is a challenging task due to the complexities of the underlying virtual machine. The majority of the current work has been focusing on compiler toolchains to solve the challenge of transparent just-in-time compilation of different code segments onto the accelerators. However\, apart from providing automatic code generation\, another paramount challenge is the seamless interoperability between the host memory manager and the Garbage Collector (GC). Currently\, heterogeneous programming models that run on top of managed runtime systems\, such as Aparapi and TornadoVM\, need to block the GC when running native code (e.g\, JNI code) in order to prevent the GC from moving data while the native code is still running on the hardware accelerator. \nTo tackle the inefficacy of locking the GC while the GPU operates\, this paper proposes a novel Unified Memory (UM) memory allocator for heterogeneous programming frameworks for managed runtime systems. In this paper\, we show how\, by providing small changes to a Java runtime system\, automatic memory management can be enhanced to perform object reclamation not only on the host\, but also on the device. This is done by allocating the Java Virtual Machine's object heap in unified memory which is visible to all hardware accelerators. In this manner -although explicit data synchronization between the host and the device is still required to ensure data consistency- we enable transparent page migration of Java heap-allocated objects between the host and the accelerator\, since our UM system is aware of pointers and object migration due to GC collections. This technique has been implemented in the context of MaxineVM\, an open source research VM for Java written in Java. We evaluated our approach on a discrete and an integrated GPU\, showcasing under which conditions UM can benefit execution across different benchmarks and configurations.We concluded that when hardware acceleration is not employed\, UM does not pose significant overheads unless memory intensive workloads are encountered which can exhibit up to 12% (worst case) and 2% (average) slowdowns. In addition\, if hardware acceleration is used\, UM can achieve up to 9.3x speedup compared to the non-UM baseline implementation for integrated GPUs.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T182212Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T154500Z
DTEND:20231022T160000Z
DTSTAMP:20231021T100631Z
UID:167dcc1e-4aae-429e-88af-ddd65f1d20ca@conf.researchr.org
CREATED:20230911T231206Z
SUMMARY:[MPLR] Beyond RSS: Towards Intelligent Dynamic Memory Management (Work in Progress) - Christos Lamprakos\, Sotirios Xydis\, Peter Kourzanov\, Manu Perumkunnil\, Francky Catthoor\, Dimitrios Soudris
DESCRIPTION:The main goal of dynamic memory allocators is to minimize memory fragmentation. Fragmentation stems from the interaction between workload behavior and allocator policy. There are\, however\, no works systematically capturing said interaction. We view this gap as responsible for the absence of a standardized\, quantitative fragmentation metric\, the lack of workload dynamic memory behavior characterization techniques\, and the absence of a standardized benchmark suite targeting dynamic memory allocation. Such shortcomings are profoundly asymmetric to the operation's ubiquity. \nThis paper presents a trace-based simulation methodology for constructing representations of workload-allocator interaction. We use two-dimensional rectangular bin packing (2DBP) as our foundation. 2DBP algorithms minimize their products' makespan\, but virtual memory systems employing demand paging deem such a criterion inappropriate. We see an allocator's placement decisions as a solution to a 2DBP instance\, optimizing some unknown criterion particular to that allocator's policy. Our end product is a data structure by design concerned with events residing entirely in virtual memory\; no information on memory accesses\, indexing costs or any other factor is kept. \nWe bootstrap our contribution's utility by exploring its relationship to maximum resident set size (RSS). Our baseline is the assumption that less fragmentation amounts to smaller peak RSS. We thus define a fragmentation metric in the 2DBP substrate and compute it for both single- and multi-threaded workloads linked to 7 modern allocators. We also measure peak RSS for the resulting pairs. Our metric exhibits a monotonic relationship with memory footprint $94%$ of the time\, as inferred via two-tailed statistical hypothesis testing with at least $99%$ confidence.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T182221Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T160000Z
DTEND:20231022T161500Z
DTSTAMP:20231021T100631Z
UID:14d07c08-f24d-4bfe-aad9-0307b3209aae@conf.researchr.org
CREATED:20230911T231217Z
SUMMARY:[MPLR] Towards Safe HPC: Productivity and Performance via Rust Interfaces for a Distributed C++ Actors Library (Work in Progress) - John Parrish\, Nicole Wren\, Tsz Hang Kiang\, Akihiro Hayashi\, Jeffrey Young\, Vivek Sarkar
DESCRIPTION:In this work-in-progress research paper\, we make the case for using Rust to develop applications in the High Performance Computing (HPC) domain which is critically dependent on native C/C++ libraries. This work explores one example of Safe HPC via the design of a Rust interface to an existing distributed C++ Actors library. This existing library has been shown to deliver high performance to C++ developers of irregular Partitioned Global Address Space (PGAS) applications. \nOur key contribution is a proof-of-concept framework to express parallel programs safe-ly in Rust (and potentially other languages/systems)\, along with a corresponding study of the problems solved by our runtime\, the implementation challenges faced\, and user productivity. We also conducted an early evaluation of our approach by converting C++ actor implementations of four applications taken from the Bale kernels to Rust Actors using our framework. Our results show that the productivity benefits of our approach are significant since our Rust-based approach helped catch bugs statically during application development\, without degrading performance relative to the original C++ actor versions.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T182234Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T161500Z
DTEND:20231022T163000Z
DTSTAMP:20231021T100631Z
UID:08bafae4-d48f-4a44-a461-d10cf69b1df7@conf.researchr.org
CREATED:20230911T231223Z
SUMMARY:[MPLR] Generating Java Interfaces for Accessing Foreign Objects in GraalVM (Work in Progress) - Julian Garn\, Florian Angerer\, Hanspeter Mössenböck
DESCRIPTION:Language interoperability (e.g.\, calling Python methods from Java programs) is a critical challenge in software development\, often leading to code inconsistencies\, human errors\, and reduced readability. \nThis paper presents a work-in-progress project aimed at addressing this issue by providing a tool that automates the generation of Java interfaces for accessing data and methods written in other languages. \nUsing existing code analysis techniques the tool aims to produce easy to use abstractions for interop\, intended to reduce human error and to improve code clarity. Although the tool is not yet finished\, it has already shown promising results. Initial evaluations demonstrate its ability to identify language-specific features and automatically generate equivalent Java interfaces. This allows developers to efficiently integrate code written in foreign languages into Java projects while maintaining code readability and minimizing errors.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T182243Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T150000Z
DTEND:20231022T154500Z
DTSTAMP:20231021T100631Z
UID:8f9b008a-2aa5-454c-95f2-b8e59f64466c@conf.researchr.org
CREATED:20230913T184009Z
SUMMARY:[HATRA] Goals of the Luau Type System\, Two Years On - Lily Brown\, Andy Friesen\, Alan Jeffrey
DESCRIPTION:In HATRA 2021\, we presented The Goals Of The Luau Type System\, describing the human factors issues with designing a type system for a language with a heterogeneous developer community. In this extended abstract we provide a progress report on the work so far\, focusing on the unexpected aspects: semantic subtyping and type error suppression.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T043509Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T154500Z
DTEND:20231022T163000Z
DTSTAMP:20231021T100631Z
UID:25aaf669-b817-4f75-b233-d0227688018e@conf.researchr.org
CREATED:20230913T184206Z
SUMMARY:[HATRA] Discussion - Michael Coblenz\, Luke Church\, Jonathan Aldrich\, Will Crichton
DESCRIPTION:This is an opportunity to network\, to discuss what you learned during the workshop\, and to identify new opportunities for research.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053208Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T150000Z
DTEND:20231022T153000Z
DTSTAMP:20231021T100631Z
UID:50b7dd36-9575-48dd-965f-dea63d8075d1@conf.researchr.org
CREATED:20230913T165043Z
SUMMARY:[ST30 ] The Expressiveness of Session Types - Jorge A. Pérez
DESCRIPTION:It is fair to say that expressiveness has been key to the success and impact of session types: enhancing the expressivity of typed processes and/or the properties enforced by typing is often a strong motivation for developing new typed frameworks. Rigorously contrasting different variants of session types from an expressiveness perspective is a pressing and non-trivial challenge. \nThis talk gives a unified overview of some of our works in this direction\; they cover various angles\, including: higher-order communication\, binary and multiparty protocols\, and “propositions-as-sessions”. The proposed talk is meant to elucidate (recent) achievements but also avenues for future exploration
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230913T174216Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T153000Z
DTEND:20231022T160000Z
DTSTAMP:20231021T100631Z
UID:7be6ce41-475a-4554-b579-8491c4eef31a@conf.researchr.org
CREATED:20230913T165043Z
SUMMARY:[ST30 ] What we learned from writing a book about session types - Simon J. Gay\, Vasco T. Vasconcelos
DESCRIPTION:For the last few years we have been working on a book about session types. Thinking about how to present the basic definitions and material has led us to a new understanding of several topics\, including: coinductive definitions of infinite session types\; the definitions of linear and sharable session types\; some small new ideas about subtyping\; the details of the propositions-as-types approach to session types. This talk will summarise and highlight a few insights that we have gained along the way.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230913T174216Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T160000Z
DTEND:20231022T163000Z
DTSTAMP:20231021T100631Z
UID:912fa087-73c4-460c-810f-a1292f19c58f@conf.researchr.org
CREATED:20230913T165043Z
SUMMARY:[ST30 ] So what's the difference between a session type and an ordinary type anyway? - Frank Pfenning
DESCRIPTION:We review the role of types in logic\, mathematics\, and computer science and identify some fundamental principles underlying the design of type systems. This will provide us with a lens through which we can view session types and other modern type system and understand similarities\, differences\, and connections between them.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230913T174216Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T150000Z
DTEND:20231022T154000Z
DTSTAMP:20231021T100631Z
UID:8afdd678-eb06-4de9-8d57-dd6045e6b38e@conf.researchr.org
CREATED:20231009T215432Z
SUMMARY:[GPCE] GPCE 2022 Most Influential Paper - Xbase: Implementing Domain-Specific Languages for Java - Sven Efftinge\, Moritz Eysholdt\, Jan Köhnlein\, Sebastian Zarnekow\, Wilhelm Hasselbring\, Michael Hanus
DESCRIPTION:
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T153051Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T154000Z
DTEND:20231022T162000Z
DTSTAMP:20231021T100631Z
UID:abfdfb73-3ffa-4db6-9458-b59fa92920fd@conf.researchr.org
CREATED:20231009T215432Z
SUMMARY:[GPCE] GPCE 2023 Most Influential Paper - Don’t Underestimate the Importance of Experiments: The Case of Preprocessor Annotations - Sandro Schulze\, Jörg Liebig\, Janet Siegmund\, Sven Apel
DESCRIPTION:
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T153254Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:3a4ed018-d625-441f-9428-dcfd94c03b9e@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] Sui Move: Modern Blockchain Programming with Objects - Adam Welc\, Sam Blackshear
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:493af5fd-3da8-416a-bea9-1af027c09a0a@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] Safe Combination of Data-centric and Operation-centric Consistency - Mirko Köhler\, Guido Salvaneschi
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:5adedc6b-4a92-43d7-93e8-20cc80e87b1d@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] Dynamic Library Compartmentalization - Octave Larose
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:5d3c7d72-8db3-480e-b26c-33f39a984fc7@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] Collabs implements collaborative data structures (CRDTs) with OOP principles - Matthew Weidner
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:662fba4b-dea2-4cb2-b400-38db44712f3b@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] Involving Users in Design of a Widely Used Language: A Case of ECMAScript (JavaScript) Standardization - Mikhail Barash\, Yulia Startsev\, Rolf Martin Glomsrud
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:7aea73f8-138a-4e0a-a033-9ca5d86d1a3d@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] A Functional Reactive Programming Language for Wirelessly Connected Shape-Changeable Chiplet-Based Computers - Yusuke Izawa\, Junichiro Kadomoto\, Hidetsugu Irie\, Shuichi Sakai
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:a6df1c5c-d5dc-49b2-9858-113dfd300900@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] Kind Inference for the FreeST Programming Language - Bernardo Almeida\, Andreia Mordido\, Vasco T. Vasconcelos
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:ad27f130-2248-4845-8a21-bf1085fcc023@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] Extensible Testing for Infrastructure as Code - David Spielmann\, Daniel Sokolowski\, Guido Salvaneschi
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:ce7c8634-4ed3-4574-b63f-eda3d3fd4baa@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] Penrose: Beautiful diagrams from plain text - Sam Estep
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:d8b66bc9-5009-45bf-b99c-725f976f3e73@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] JaMaBuild: Mass Building of Java Projects - Matúš Sulír\, Milan Nosáľ
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:da147884-4563-4280-bcc1-7d12f14ada41@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] Completeness Thresholds for Memory Safety: Unbounded Guarantees Via Bounded Proofs - Tobias Reinhard\, Justus Fasse\, Bart Jacobs
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:db34644d-54fa-4240-872e-7668efe5a1a2@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] Towards Reusable GUI Structures - Knut Anders Stokke\, Mikhail Barash\, Jaakko Järvi
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:e9565539-28f4-492d-819f-313f814c160b@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] ReactCOP: Modular and Scalable Web Development with Context-Oriented Programming - David H. Lorenz\, Ofir Shmuel
DESCRIPTION:We present a library named ReactCOP that extends React’s capabilities with support for Context-Oriented Programming. The library lets developers manage behavioral variations in React applications through layers\, and adapt the application’s behavior dynamically based on different contexts.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T232002Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231022T163000Z
DTEND:20231022T183000Z
DTSTAMP:20231021T100631Z
UID:ea10e4dc-8e1c-4cf6-8eb5-b7e75898cb71@conf.researchr.org
CREATED:20231010T192404Z
SUMMARY:[SPLASH Posters] Generating Domain-Specific Programs for Diagram Authoring with Large Language Models - Rijul Jain\, Wode Ni\, Joshua Sunshine
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T080000Z
DTEND:20231023T083000Z
DTSTAMP:20231021T100631Z
UID:3132d16e-549a-4351-851f-fa92b04ef5d8@conf.researchr.org
CREATED:20230916T195940Z
SUMMARY:[PPDP] Multicompatibility for Multiparty-Session Composition - Franco Barbanera\, Mariangiola Dezani\, Lorenzo Gheri\, Nobuko Yoshida
DESCRIPTION:Modular methodologies for the development and verification of concurrent/distributed systems are increasingly relevant nowadays. We investigate the simultaneous composition of multiple systems in a multiparty-session-type setting\, working on suitable notions of interfacing policy and multicompatibility. The resulting method is conservative (it alters as less as possible the single systems)\, flexible (any system can be looked at as potentially open) and safe (relevant communication properties\, e.g. lock-freedom\, are preserved by composition). We obtain safety\, by proving preservation of typability\, and give a sound and complete type inference algorithm.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053033Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T083000Z
DTEND:20231023T090000Z
DTSTAMP:20231021T100631Z
UID:6a17451c-546e-4ebd-816c-d22a24aad512@conf.researchr.org
CREATED:20230916T195940Z
SUMMARY:[PPDP] Termination in Concurrency\, Revisited - Joseph Paulus\, Daniele Nantes-Sobrinho\, Jorge A. Pérez
DESCRIPTION:Termination (also known as \emph{strong normalization}) is a fundamental property in sequential programming models. A process is terminating if all its reduction sequences are of finite length. Termination is also important in concurrency in general\, and in message-passing programs in particular. Indeed\, a variety of type systems that enforce termination by typing have been developed in the last 20 years. Unfortunately\, the precise relation between those type systems remains scarcely understood. In this paper\, we rigorously compare different type systems for mobile processes from the unifying perspective of termination. Considering session types as a basic reference\, we consider two different type systems that ensure termination: one follows Deng and Sangiorgi’s weight-based type system\; the other is induced by Caires and Pfenning’s Curry-Howard correspondence between linear logic and session types. Our results precisely connect these very different systems and approaches\, and shed light on the nature of (well-behaved) servers and client abstractions in concurrency.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053033Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T090000Z
DTEND:20231023T093000Z
DTSTAMP:20231021T100631Z
UID:7f7f5cdf-84ae-44c5-8ef5-2a76e4ba03dd@conf.researchr.org
CREATED:20230916T195940Z
SUMMARY:[PPDP] Polymorphic Typestate for Session Types - Hannes Saffrich\, Peter Thiemann
DESCRIPTION:Session types provide a principled approach to typed communication protocols that guarantee type safety and protocol fidelity. Formalizations of session-typed communication are typically based on process calculi\, concurrent lambda calculi\, or linear logic. An alternative model based on context-sensitive typing and typestate has not received much attention due to its apparent restrictions. However\, this model is attractive because it does not force programmers into particular patterns like continuation-passing style or channel-passing style\, but rather enables them to treat communication channels like mutable variables. \nPolymorphic typestate is the key that enables a full treatment of session-typed communication. Previous work in this direction was hampered by its setting in a simply-typed lambda calculus. We show that higher-order polymorphism and existential types enable us to lift the restrictions imposed by the previous work\, thus bringing the expressivity of the typestate-based approach on par with the competition. On this basis\, we define PolyVGR\, the system of polymorphic typestate for session types\, establish its basic metatheory\, type preservation and progress\, and present a prototype implementation.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053033Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T080000Z
DTEND:20231023T090000Z
DTSTAMP:20231021T100631Z
UID:a3e823c4-9b97-43f1-8b15-01b3c10584f7@conf.researchr.org
CREATED:20230918T142443Z
SUMMARY:[SAS ] Abstract Interpretation in Industry - Experience and Lessons Learned - Daniel Kaestner
DESCRIPTION:In this article we will give an overview of the development and commercialization of two industry-strength Abstract Interpretation- based static analyzers\, aiT WCET Analyzer and Astrée. We focus on development steps\, adaptations to meet industry requirements and dis- cuss criteria for a successful transfer of formal verification methods to industrial usage.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052455Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T090000Z
DTEND:20231023T093000Z
DTSTAMP:20231021T100631Z
UID:02c503ba-a048-4304-ae1e-162a260e00ae@conf.researchr.org
CREATED:20230918T142443Z
SUMMARY:[SAS ] Lifting On-Demand Analysis to Higher-Order Languages - Daniel Schoepe\, David Seekatz\, Ilina Stoilkovska\, Sandro Stucki\, Daniel Tattersall\, Pauline Bolignano\, Franco Raimondi\, Bor-Yuh Evan Chang
DESCRIPTION:In this paper\, we present an approach to lift on-demand analysis to higher-order languages. Specifically\, our approach bootstraps an on-demand call graph construction by leveraging a pair of on-demand data flow analyses. While static analysis is increasingly applied to find subtle bugs or prove deep properties in large\, industrial code bases\, to effectively find bugs or prove properties at scale\, analyzers both need to resolve function calls in a precise manner (i.e.\, construct a precise call graph) and to examine only the relevant portion of the program (i.e.\, be on-demand). A strawman strategy to this problem is to use fast\, approximate\, whole-program call graph construction algorithms. However\, this strategy is generally not adequate for modern languages like JavaScript that rely heavily on higher-order features\, such as callbacks and closures\, where scalable approximations often introduce unacceptable imprecision. This strategy also limits increasingly sophisticated on-demand analyses\, which scale by analyzing only parts of a program as needed: the scalability advantages of an on-demand analysis may be thwarted by the need to construct a whole-program call graph. The key insight of this paper is that existing on-demand data flow analyses can themselves be applied in a black-box manner to construct call graphs on demand. We propose a soundness condition for the existing on-demand analyses with respect to partial call graphs\, formalize our algorithm as an abstract domain combinator\, and prove it sound in Isabelle/HOL. Furthermore\, we evaluate a prototype implementation of the resulting on-demand call graph construction algorithm for a subset of JavaScript (using the Synchronized Push-Down Systems framework as the underlying data flow analysis) on benchmarks making heavy use of higher-order functions.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052455Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T080000Z
DTEND:20231023T083000Z
DTSTAMP:20231021T100631Z
UID:5b29fc8c-1afe-4694-a897-e1175a7effc9@conf.researchr.org
CREATED:20231003T154539Z
SUMMARY:[SLE] Exceptions all Over the Shop: Modular\, Customizable\, Language-independent Exception Handling Layer - Walter Cazzola\, Luca Favalli
DESCRIPTION:The introduction of better abstractions is at the forefront of research and practice. Among many approaches\, domain-specific languages are subject to an increase in popularity due to the need for easier\, faster and more reliable application development that involves programmers and domain experts alike. To smooth the adoption of such a language-driven development process\, researchers must create new engineering techniques for the development of programming languages and their ecosystems. Traditionally\, programming languages are implemented from scratch and in a monolithic way. Conversely\, modular and reusable language development solutions would improve maintainability\, reusability and extensibility. Many programming languages share similarities that can be leveraged to reuse the same language feature implementations across several programming languages\; recent language workbenches strive to achieve this goal by solving the language composition and language extension problems. Yet\, some features are inherently complex and affect the behavior of several language features. Most notably\, the exception handling mechanism involves varied aspects\, such as the memory layout\, variables\, their scope\, up to the execution of each statement that may cause an exceptional event—e.g.\, a division by zero. In this paper\, we propose an approach to untangle the exception handling mechanism dubbed the exception handling layer: its components are modular and fully independent from one another\, as well as from other language features. The exception handling layer is language-independent\, customizable with regards to the memory layout and supports unconventional exception handling language features. To avoid any assumptions with regards to the host language\, the exception handling layer is a stand-alone framework\, decoupled from the exception handling mechanism offered by the back-end. Then\, we present a full-fledged\, generic Java implementation of the exception handling layer. The applicability of this approach is presented through a language evolution scenario based on a Neverlang implementation of JavaScript and LogLang\, that we extend with conventional and unconventional exception handling language features using the exception handling layer\, with limited impact on their original implementation.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052659Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T083000Z
DTEND:20231023T090000Z
DTSTAMP:20231021T100631Z
UID:534a9bd8-2e12-4558-83e8-83fe0306abe0@conf.researchr.org
CREATED:20231003T154539Z
SUMMARY:[SLE] An Executable Semantics for Faster Development of Optimizing Python Compilers - Olivier Melancon\, Marc Feeley\, Manuel Serrano
DESCRIPTION:Python is a popular programming language whose performance is known to be uncompetitive in comparison to static languages such as C. Although significant efforts have already accelerated implementations of the language\, more efficient ones are still required. The development of such optimized implementations is nevertheless hampered by its complex semantics and the lack of an official formal semantics. We address this issue by presenting an approach to define an executable semantics targeting the development of optimizing compilers. This executable semantics is written in a format that highlights type checks\, primitive values boxing and unboxing\, and function calls which are all known sources of overhead. We also present semPy\, a partial evaluator of our executable semantics that can be used to remove redundant operations when evaluating arithmetic operators. Finally\, we present Zipi\, a Python optimizing compiler prototype developed with the aid of semPy. On some tasks\, Zipi displays performance competitive with that of state of art Python implementations.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052659Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T090000Z
DTEND:20231023T093000Z
DTSTAMP:20231021T100631Z
UID:a8b40ebd-5c1c-4615-9a89-8b795c312cb4@conf.researchr.org
CREATED:20231003T154539Z
SUMMARY:[SLE] Adaptive Structural Operational Semantics - Gwendal Jouneaux\, Damian Frölich\, Olivier Barais\, Benoit Combemale\, Gurvan LE GUERNIC\, Gunter Mussbacher\, L. Thomas van Binsbergen
DESCRIPTION:Software systems evolve more and more in complex and changing environments\, often requiring runtime adaptation to best deliver their services. When self-adaptation is the main concern of the system\, a manual implementation of the underlying feedback loop and trade-off analysis may be desirable. However\, the required expertise and substantial development effort make such implementations prohibitively difficult when it is only a secondary concern for the given domain. In this paper\, we present ASOS\, a metalanguage abstracting the runtime adaptation concern of a given domain in the behavioral semantics of a domain-specific language (DSL)\, freeing the language user from implementing it from scratch for each system in the domain. We demonstrate our approach on RobLANG\, a procedural DSL for robotics\, where we abstract a recurrent energy-saving behavior depending on the context. We provide formal semantics for ASOS and pave the way for checking properties such as determinism\, completeness\, and termination of the resulting self-adaptable language. We provide first results on the performance of our approach compared to a manual implementation of this self-adaptable behavior. We demonstrate\, for RobLANG\, that our approach provides suitable abstractions for specifying sound adaptive operational semantics while being more efficient.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052659Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T080000Z
DTEND:20231023T081000Z
DTSTAMP:20231021T100631Z
UID:abb31328-838f-45f0-9aea-3a23a7c22b54@conf.researchr.org
CREATED:20230918T150154Z
SUMMARY:[SPLASH PLMW] Welcome
DESCRIPTION:
LOCATION:Room III - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072314Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T081000Z
DTEND:20231023T084000Z
DTSTAMP:20231021T100631Z
UID:2fc05eec-6c8f-4454-b35e-59ffac7fa889@conf.researchr.org
CREATED:20230918T150154Z
SUMMARY:[SPLASH PLMW] Ice Breaker / Video Chat
DESCRIPTION:
LOCATION:Room III - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T131620Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T084000Z
DTEND:20231023T093000Z
DTSTAMP:20231021T100631Z
UID:13b59c8a-19cb-4763-8970-941e129eec08@conf.researchr.org
CREATED:20230918T150154Z
SUMMARY:[SPLASH PLMW] A Full Employment Theorem for PL Researchers: Domain-Specific Languages - Nate Foster
DESCRIPTION:
LOCATION:Room III - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072314Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T080000Z
DTEND:20231023T093000Z
DTSTAMP:20231021T100631Z
UID:756d2d7a-b9fa-47f7-add2-62b837973831@conf.researchr.org
CREATED:20231012T155433Z
SUMMARY:[REBLS] Implementing\, verifying and debugging distributed event-based systems - Elisa Gonzalez Boix
DESCRIPTION:Distributed systems are inherently event-based systems communicating over a network. They are challenging to design and implement as they introduce fundamental problems related to latency\, concurrency and partial failures\, as pointed out by Waldo in the seminal article “A note on distributed computing”. To support the development of distributed systems\, we argue that it is essential to provide novel programming abstractions which are explored in tandem with software tools tailored to modern concurrent and distributed software. \nIn this talk\, we first discuss examples of programming language abstraction to support the implementation and verification of distributed systems\, focusing on the challenges of data replication and consistency. We then turn our attention to concrete examples to ease debugging and the difficult task of finding the root cause of bugs in distributed systems. In particular\, we discuss examples of debugging techniques to deal with the event-based nature of those systems\, focusing on recent work on debugging IoT systems. \nBio: \nElisa Gonzalez Boix is a professor at the Vrije Universiteit Brussel (VUB). She leads the Distributed and Concurrency (DisCo) group within the Software Languages Lab of the VUB\, where she and her students investigate language technology to support the design and implementation of programming abstractions and tools for modern concurrent and distributed systems. Her later works focus on web-based distributed systems\, geo-replicated systems and the Internet of Things. She publishes in programming and software engineering venues like ECOOP\, OOPSLA\, and Programming\, and actively contributes to organising events in her area\, like the PaPoc and DEBT workshops and the DARE summer school. She received her PhD in Sciences at the VUB and her bachelor’s and master’s degrees from Universitat Politècnica de Catalunya (UPC). You can find Elisa on Twitter as @elisagboix and find information on her research at: https://soft.vub.ac.be/disco
LOCATION:Room IV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T200956Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T080000Z
DTEND:20231023T083000Z
DTSTAMP:20231021T100631Z
UID:e8c29fea-1595-4c4a-9afa-ee5b33681658@conf.researchr.org
CREATED:20230918T105435Z
SUMMARY:[PAINT] Toward Studying Example-based Live Programming in CS/SE Education - Eva Krebs\, Toni Mattis\, Patrick Rein\, Robert Hirschfeld
DESCRIPTION:Source code is inherently abstract. While this is necessary to capture the generality of a program\, it poses a barrier to understanding and learning to use the underlying concepts. In education\, especially in abstract subjects like maths\, the use of concrete examples is considered instrumental to the acquisition of knowledge and a frequently explored direction for teaching computational concepts. Besides concreteness\, the importance of examples being close to their abstract descriptions as well as the immediacy of feedback has been highlighted. \nBabylonian Programming (BP) is a type of example-based live programming that fulfills all three criteria by introducing concrete values\, moving them as close as possible to the code\, and updating them immediately in response to changes of either the example or the code. This makes BP a promising tool in education\, yet no studies on the suitability of BP in a learning context have been conducted. Hence\, we propose to (1.) investigate usability of state-of-the-art BP to minimize the friction of introducing BP in education\, and (2.) measure the learning effectiveness and quality of experience of a BP environment in undergraduate software engineering education. For these studies\, we will use the Smalltalk-based Babylonian/S as our environment. \nBesides clearer guidelines on the design of BP and example- based systems in general\, we expect to shed light on the qualities that teacher-provided examples need to exhibit and the opportunities for learners to create their own examples during experimentation with unknown concepts.
LOCATION:Room V - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231016T195901Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T083000Z
DTEND:20231023T090000Z
DTSTAMP:20231021T100631Z
UID:b23e6e33-68a6-4032-a6c5-2efb6d8d927d@conf.researchr.org
CREATED:20230918T105435Z
SUMMARY:[PAINT] Branching Compositional Data Transformations in jq\, Visually - Michael Homer
DESCRIPTION:
LOCATION:Room V - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231007T210836Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T090000Z
DTEND:20231023T093000Z
DTSTAMP:20231021T100631Z
UID:0e94abd4-24b0-4a98-938c-ec4ad6cd4ae6@conf.researchr.org
CREATED:20230922T140922Z
SUMMARY:[PAINT] PescaJ: A projectional editor for Java featuring scattered code aggregation - José Lopes\, André L. Santos
DESCRIPTION:
LOCATION:Room V - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231007T210836Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T080000Z
DTEND:20231023T081000Z
DTSTAMP:20231021T100631Z
UID:8eff1b77-87c7-44f6-a1b0-8f95b7dbbab8@conf.researchr.org
CREATED:20230918T131118Z
SUMMARY:[VMIL] Opening Remarks - Andrea Rosà
DESCRIPTION:
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T093622Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T081000Z
DTEND:20231023T083500Z
DTSTAMP:20231021T100631Z
UID:fa37c596-e4b2-4e67-96af-43589de59bae@conf.researchr.org
CREATED:20230918T130853Z
SUMMARY:[VMIL] CHERI Performance Enhancement for a Bytecode Interpreter - Duncan Lowther\, Dejice Jacob\, Jeremy Singer
DESCRIPTION:During our port of the MicroPython bytecode interpreter to the CHERI-based Arm Morello platform\, we encountered a number of serious performance degradations. This paper explores several of these of these performance issues in detail\, in each case characterizing the cause of the problem\, the fix\, and the corresponding performance improvement over a set of standard Python benchmarks. While we recognize that Morello is a prototypical physical instantiation of the CHERI concept\, we show that it is possible to eliminate certain kinds of software-induced runtime overhead that occur due to the larger size of architectural capabilities relative to native pointers. In our case\, we reduce a geometric mean benchmark slowdown from 5x (before optimization) to 2x (after optimization) relative to AArch64 execution. The worst-case slowdowns are greatly improved\, from 100x (before optimization) to 2x (after optimization). The key insight is that pointer size assumptions pervade systems code\; whereas previous CHERI porting projects highlighted compile-time and execution-time errors exposed by pointer size assumptions\, we instead focus on the performance implications of such assumptions.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T093633Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T083500Z
DTEND:20231023T090000Z
DTSTAMP:20231021T100631Z
UID:8d913d76-ffc4-42a0-90bf-70e1099fafba@conf.researchr.org
CREATED:20230918T130853Z
SUMMARY:[VMIL] Revisiting Dynamic Dispatch for Modern Architectures - Dave Mason
DESCRIPTION:Since the 1980’s\, Deutsch-Schiffman dispatch has been the standard method dispatch mechanism for languages like Smalltalk\, Ruby\, and Python. While it is a huge improvement over the simple\, semantic execution model\, it has some significant drawbacks for modern hardware and applications. \nThis paper proposes an alternative dispatch mechanism that addresses these concerns\, with only memory space as a trade-off\, that should demonstrate dynamic performance only slightly worse than the best possible with full type information for the program.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T093646Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T090000Z
DTEND:20231023T091500Z
DTSTAMP:20231021T100631Z
UID:5ff4197f-3eaf-4cd9-b6cd-83f730aa4182@conf.researchr.org
CREATED:20231019T093557Z
SUMMARY:[VMIL] Extraction of Virtual Machine Execution Traces - Daniel Pekarek\, Hanspeter Mössenböck
DESCRIPTION:Debugging virtual machines can be challenging. Advanced debugging techniques using execution trace analysis can simplify debugging\, but they often show only the execution of the virtual machine (in terms of machine instructions) and not the execution of the guest program (in terms of VM instructions). Ideally\, the virtual machine as well as the guest program should be inspectable simultaneously to quickly locate the bug. \nOur approach provides a debugging environment which uses an execution trace of a virtual machine and derives the execution trace of the guest program running on it. The transformation is performed by transformation rules which inspect events from the virtual machine’s execution trace\, collect necessary information\, and then emit the events of the guest program’s execution trace. By linking both traces\, navigation in the virtual machine’s execution trace is greatly simplified. When analyzing a simple virtual machine\, our approach causes a 9.6% slowdown and an increase of 22% in memory consumption of the underlying execution trace analysis tool.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T093708Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T091500Z
DTEND:20231023T093000Z
DTSTAMP:20231021T100631Z
UID:0fae51e9-b822-4796-be82-d4c846aa7e80@conf.researchr.org
CREATED:20230918T131331Z
SUMMARY:[VMIL] Transpiling Slang Methods to C Functions: An Example of Static Polymorphism for Smalltalk VM Objects - Tom Braun\, Marcel Taeumel\, Eliot Miranda\, Robert Hirschfeld
DESCRIPTION:The OpenSmalltalk-VM is written in a subset of Smalltalk which gets transpiled to C. Developing the VM in Smalltalk allows to use the Smalltalk developer tooling and brings a fast feedback cycle. However\, transpiling to C requires mapping Smalltalk constructs\, i.e.\, object-oriented contepts\, to C\, which sometimes requires developers to use different design than they would use when developing purely in Smalltalk. \nWe describe a pragmatic extension for static polymorphism in Slang\, our experience using it as well as the shortcomings of the new approach. While our solution extends the concepts developers can express in Slang\, which reduces the burden of finding alternatives to well-known design patterns and by enabling the use of such patterns the modularity\, it further complicates a fragile\, already complicated system. While our extension solves the task it was designed for\, it needs further enhancements\, as does Slang itself in terms of understandability in the field.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T133823Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T080000Z
DTEND:20231023T083000Z
DTSTAMP:20231021T100631Z
UID:aa5d5bd7-b60a-4053-9d8b-4365c0785a41@conf.researchr.org
CREATED:20230921T111156Z
SUMMARY:[LIVE] LIVE 2023 Opening - Jun Kato\, Peter van Hardenberg
DESCRIPTION:
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T125829Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T083000Z
DTEND:20231023T090000Z
DTSTAMP:20231021T100631Z
UID:06ce11fc-8022-4e20-8211-d55aaba87e9e@conf.researchr.org
CREATED:20231018T123811Z
SUMMARY:[LIVE] PAW: a programmable and visual audio workstation - Xavier Lambein
DESCRIPTION:Most modern music is written and produced with “digital audio workstations” or DAWs\, which are GUI applications for recording\, mixing and producing audio. Like many other graphical applications\, DAWs suffer from several problems\, including hidden state\, complex menus and low discoverability\, limited extensibility\, lack of composability\, and difficulty in versioning and tracking changes. \nA less widespread tradition of music making on the computer comes from live coding\, in which artists write and edit programs live\, with the purpose of making music\, usually generative in nature. However\, live coding\, like the rest of programming\, suffers from its non-visual nature\, which is arguably critical in this context\, and accounts at least in part for the limited success of live coding in the music world. \nHere I present an attempt at bridging this gap. This prototype\, named “PAW” for “Programmable dAW”\, is an exploration of applying concepts from bidirectional and live programming to the context of music making. In PAW\, the author writes a program which produces the piece they’re working on\, and a live GUI is generated from code analysis of that program. Using this GUI\, the author can make immediate changes to both the audio output and the program that generated it.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T125829Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T090000Z
DTEND:20231023T093000Z
DTSTAMP:20231021T100631Z
UID:1263fe70-6ffc-426e-ba7a-f7fff5ee5eb5@conf.researchr.org
CREATED:20231018T123811Z
SUMMARY:[LIVE] CellPond: Spatial programming without escape - Lu Wilson
DESCRIPTION:Spatial programming is a visual and interactive medium that makes use of spatial relationships to craft behavior. But existing approaches rely heavily on escape hatches. They allow the user to return to the traditional land of text to complete their programs\, losing out on the benefits of the paradigm. CellPond is a novel and extreme example that removes the need for these escapes.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T125829Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T080000Z
DTEND:20231023T083000Z
DTSTAMP:20231021T100631Z
UID:30524908-4315-4cca-8a38-ef0397de7530@conf.researchr.org
CREATED:20230918T224417Z
SUMMARY:[ST30 ] Behavioural up/down casting for statically typed languages - Lorenzo Bacchiani\, Mario Bravetti\, Marco Giunti\, João Mota\, António Ravara
DESCRIPTION:To tackle the challenge of finding bugs in object-oriented code\, where objects naturally have protocols\, following previous work on associating behavioural types with object-oriented languages\, we have been developing JaTyC\, a typestate-based checking approach for Java. The recipe is simple: attach protocols (essentially\, allowed orders of method calls) to classes and type check classes (i.e.\, their method bodies) following the protocol\, thus gaining typestate-based nullness checking (ensuring memory-safety)\, protocol compliance\, and protocol completion (under program termination). \nExisting approaches\, like Mungo\, provide very limited support for inheritance and polymorphism. Our initial solution exploited the seminal simulation-based notion of subtyping to check that the protocol of a class is a subtype of the protocol of its superclass. However\, we only allowed upcast and downcast at the beginning of an object’s protocol (i.e.\, just after object creation) or at the end (i.e.\, in the end state). Additionally\, to determine if a typestate is a subtype of another\, the algorithm was only applied to the initial typestates of the protocols. It is fundamental to overcome these limitations to make the typestate approach applicable to real-world scenarios. \nOur solution is language agnostic and applicable to many object-oriented languages. We developed and mechanised the casting theory\, provably showing it is sound. To test its expressiveness\, we extend JaTyC to now support casting in the middle of a class protocol.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230918T224417Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T083000Z
DTEND:20231023T090000Z
DTSTAMP:20231021T100631Z
UID:11105b14-ccdd-44b6-a88c-1e9886d19f23@conf.researchr.org
CREATED:20230918T224417Z
SUMMARY:[ST30 ] Session-Based Typechecking for Elixir Modules Using ElixirST - Adrian Francalanza\, Gerard Tabone
DESCRIPTION:We investigate the adaptation of session types to provide static behavioural guarantees for Elixir modules. We devise a type system\, called ElixirST\, which allows us to describe the behaviour of executing a public function in an Elixir module as a protocol of message interactions. The ElixirST type system also allows us to statically determine whether this function observes its endpoint specification\; a corresponding tool automating the corresponding typechecking on Elixir source code has also been constructed. We also formally validate this type system. An LTS-based operational semantics for the language fragment supported by the type system is developed\, modelling its runtime behaviour when interacting with an arbitrary module client that respects a compatible protocol. This operational semantics is then used to prove a form of session fidelity and progress for ElixirST.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230918T224417Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T090000Z
DTEND:20231023T093000Z
DTSTAMP:20231021T100631Z
UID:6460b5ee-f262-41f7-a31a-9ba91d7e0c8b@conf.researchr.org
CREATED:20230918T224417Z
SUMMARY:[ST30 ] A Semantic Framework for Automatic Composition of Decentralised Industrial Control Schemes - Dimitrios Kouzapas\, Demetrios G. Eliades
DESCRIPTION:Modern factory standards\, such as the Industrial Internet of Things (IIoT) and Industry 4.0 envision industrial processes that are evolving in time. An industrial process evolves following the effort to optimise its Key Performance Indicators (KPIs) as they are monitored by the underlying network. Optimisation is achieved with the addition\, update or removal of assets within the industrial ecosystem\, which\, often\, implies a reconfiguration of the underlying industrial control system. The reconfiguration of the control system of an industrial process\, however\, is a knowledge-intensive\, time-consuming and error-prone task. This talk presents work in progress for a semantic framework based on session types for the automatic (re-)configuration of an industrial control system in the event of system evolution. Software components are described using session semantics that express the decentralised and distributed nature of a cyber-physical network. This implies a better utilisation of the resources with IIoT capabilities. Reasoning over session semantics identifies and synthesises the available network assets into a set of control loop session configurations. Given a of control loop session configuration\, a control loop deployment module can automatically and seamlessly commit and deploy the necessary the control loop resources within the industrial network.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230918T224417Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T080000Z
DTEND:20231023T093000Z
DTSTAMP:20231021T100631Z
UID:89d37fb3-b74b-492b-a291-08b45decaddb@conf.researchr.org
CREATED:20231012T174534Z
SUMMARY:[GPCE] GPCE Tutorial - Compile-time generative programming for OCaml: flexible\, safe and efficient - Jeremy Yallop
DESCRIPTION:MacoCaml is a new design and implementation of compile-time computation for OCaml that features a novel combination of phase separation and quotation-based staging. Together with OCaml’s existing facilities — sophisticated data types\, algebraic effects\, a rich module language — these features provide a flexible and expressive system for generative programming. \nThis interactive tutorial illustrates the development of a generative program using MacoCaml\, and outlines how the key meta-theoretical properties of type soundness and phase distinction offer practical benefits for programmers.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T152856Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T101000Z
DTEND:20231023T111000Z
DTSTAMP:20231021T100631Z
UID:7e7b92c3-2c12-4487-9274-7241c8f5b812@conf.researchr.org
CREATED:20230916T200006Z
SUMMARY:[PPDP] Unification modulo equational theories in languages with binding operators - Maribel Fernandez
DESCRIPTION:Unification (i.e.\, solving equations between terms) is a key step in the implementation of logic programming languages and theorem provers\, and is also used in type inference algorithms for functional languages and as a mechanism to analyse rewrite-based specifications (e.g.\, to find critical pairs). Matching is a version of unification in which only one of the terms in the equation can be instantiated. Often\, operators satisfy equational axioms (e.g.\, associativity\, commutativity)\, which must be taken into account during the unification or matching process. In addition\, when the expressions to be unified involve binding operators (as is the case when representing programs\, logics\, computation models\, etc.)\, unification and matching algorithms must take into account the alpha-equivalence relation generated by the binders. In this talk\, we present matching and unification algorithms for languages that include binding operators as well as operators that satisfy equational axioms\, such as associativity and commutativity.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072914Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T100000Z
DTEND:20231023T103000Z
DTSTAMP:20231021T100631Z
UID:4e8a39c4-cd01-41c3-9c68-0089eeb3e5a7@conf.researchr.org
CREATED:20230918T142646Z
SUMMARY:[SAS ] Symbolic transformation of expressions in modular arithmetic - Jérôme Boillot\, Jerome Feret
DESCRIPTION:We present symbolic methods to improve the precision of static analyses of modular integer expressions based on Abstract Interpretation. Like similar symbolic methods\, the idea is to simplify on-the-fly arithmetic expressions before they are given to abstract transfer functions of underlying abstract domains. When manipulating fixed-length integer data types\, casts and overflows generally act like modulo computations which hinder the use of symbolic techniques. The goal of this article is to formalize how modulo operations can be safely eliminated by abstracting arbitrary arithmetic expressions into sum\, product\, or division of linear forms with integer coefficients\, while simplifying them. A common method\, called “symbolic constant propagation”\, enhances the simplifications of assigned variables by propagating the abstract representation of its occurrences in other expressions. Lastly\, we provide some rules to simplify some expressions that are involved in the computation of linear interpolation\, while ensuring the soundness of the transformation. \nAll these methods have been incorporated within the Astrée static analyzer that checks for the absence of run-time errors in embedded critical software.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052500Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T103000Z
DTEND:20231023T110000Z
DTSTAMP:20231021T100631Z
UID:98de88e3-51c1-4ab3-a64b-a61c7ff786cd@conf.researchr.org
CREATED:20230918T142646Z
SUMMARY:[SAS ] Polynomial Analysis of Modular Arithmetic - Thomas Seed\, Andy King\, Neil Evans\, Chris Coppins
DESCRIPTION:The modular polynomial abstract domain\, MPAD\, is proposed\, whose invariants are systems of polynomial equations that hold modulo a power of 2. Its domain operations are founded on a closure operation\, but unlike conventional polynomial abstractions\, MPAD satisfies the ascending chain condition\, can model both positive and negative polynomial guards\, and can infer invariants previously out of reach.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052500Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T110000Z
DTEND:20231023T113000Z
DTSTAMP:20231021T100631Z
UID:39c45ba1-f3e8-4788-b674-3b64d4f245ee@conf.researchr.org
CREATED:20230918T142646Z
SUMMARY:[SAS ] Octagons Revisited - Elegant Proofs and Simplified Algorithms - Michael Schwarz\, Helmut Seidl
DESCRIPTION:Weakly relational domains such as the Octagon domain have enjoyed tremendous success in the area of program analysis\, since they offer a decent compromise between precision and efficiency. Octagons\, in particular\, have widely been studied to obtain efficient algorithms which\, however\, come with intricate correctness arguments. Here\, we provide simplified cubic time algorithms for computing the closure of Octagon abstract relations both over the rationals and the integers which avoid introducing auxiliary variables. They are based on a more general formulation by means of 2-projective domains which allows for an elegant short correctness proof. The notion of 2-projectivity also lends itself to efficient algorithms for incremental normalization. For the Octagon domain\, we also provide an improved construction for linear programming based best abstract transformers for affine assignments.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052500Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T100000Z
DTEND:20231023T111000Z
DTSTAMP:20231021T100631Z
UID:36a76e27-9f59-427b-a05f-fc58ffc7f71b@conf.researchr.org
CREATED:20231003T160330Z
SUMMARY:[SLE] Coccinelle: Impact and Internals - Julia Lawall
DESCRIPTION:Coccinelle is a program matching and transformation tool for C code that was first developed in the mid 2000s. Coccinelle has been extensively used on the Linux kernel\, in over 9000 commits\, as well as on other C projects. In this talk\, we will present some recent uses of Coccinelle and discuss some of the design decisions that makes these results possible.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082556Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T111000Z
DTEND:20231023T113000Z
DTSTAMP:20231021T100631Z
UID:1bf7f834-a6be-402e-a66a-7489533831e1@conf.researchr.org
CREATED:20231017T082527Z
SUMMARY:[SLE] GPCE/SLE Awards
DESCRIPTION:
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082555Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T100000Z
DTEND:20231023T103000Z
DTSTAMP:20231021T100631Z
UID:40996867-0ba5-4103-a253-abfbd05dddb9@conf.researchr.org
CREATED:20230920T113409Z
SUMMARY:[SPLASH PLMW] A Brief Introduction to the Flix Programming Language - Magnus Madsen
DESCRIPTION:
LOCATION:Room III - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T121149Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T103000Z
DTEND:20231023T113000Z
DTSTAMP:20231021T100631Z
UID:7da8fb00-21ac-47d7-8b4e-17d9532b71b3@conf.researchr.org
CREATED:20230918T150249Z
SUMMARY:[SPLASH PLMW] PhD Panel - Luna Phipps-Costin\, Noam Zilberstein\, Eduardo Geraldo
DESCRIPTION:
LOCATION:Room III - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072320Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T100000Z
DTEND:20231023T104500Z
DTSTAMP:20231021T100631Z
UID:71cdc0fd-653c-4165-bf44-d5377090f145@conf.researchr.org
CREATED:20230916T214807Z
SUMMARY:[REBLS] Periodic and Aperiodic Task Description Mechanisms in an FRP Language for Small-Scale Embedded Systems - Kento Sogo\, Yuta Tsuji\, Sosuke Moriguchi\, Takuo Watanabe
DESCRIPTION:This paper presents mechanisms for describing real-time tasks in functional reactive programming (FRP) languages for small-scale embedded systems. We have designed and implemented Emfrp\, an FRP language for resource-constrained systems\, and demonstrated its usefulness with several applications. However\, the language requires using external clocks as time-varying values when describing time-dependent behaviors. In this work\, we extend the types of time-varying values that express their update timings to describe periodic and aperiodic tasks. The extensions enable concise and precise descriptions of various timed behaviors. We evaluate prototype implementations of the extended languages concerning program size\, execution time\, and power consumption.
LOCATION:Room IV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231014T140435Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T104500Z
DTEND:20231023T113000Z
DTSTAMP:20231021T100631Z
UID:19d64a59-b244-4897-8204-7740d5bdcb89@conf.researchr.org
CREATED:20230916T214807Z
SUMMARY:[REBLS] Thorium: Verifiable\, Dynamic\, Reactive Software - Kevin Baldor\, Jianwei Niu\, Xiaoyin Wang
DESCRIPTION:Developing reliable reactive software is notoriously difficult – particularly when that software reacts by changing its behavior. Some of this difficulty is inherent\; software that must respond to external events as they arrive tends to end up in states that are dependent on the value of that input and its order of arrival. This results in complicated corner cases that can be challenging to recognize. However\, we find that some of the complexity is an accident of the features of the programming languages widely used in industry. The loops and subroutines of structured programming are well-suited to data transformation\, but poorly capture – and sometimes obscure – the flow of data through reactive programs developed using the inversion-of-control paradigm\; an event handler that modifies the data flow tends to be declared closer to the definition of the event that activates it than to the initial definition of the data flow that it modifies. This paper approaches both challenges with a language inspired by the declarative modules of languages SIGNAL and Lustre and the semantics of the SodiumFRP Functional Reactive Programming library with a declarative mechanism for self modification through module substitution. These language features lead to software with a code structure that closely matches the flow of data through the running program and thus makes software easier to understand. Further\, we demonstrate how those language features enable a bounded model checking approach that can verify that a reactor meets its requirements or present a \textit{counterexample trace}\, a series of states and inputs that lead to a violation. We analyze the runtime performance of the verifier as a function of model size and trace length and explore a number of optimizations.
LOCATION:Room IV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230916T214807Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T100000Z
DTEND:20231023T103000Z
DTSTAMP:20231021T100631Z
UID:5802e6c7-bd84-4d0f-b69d-ee965b904480@conf.researchr.org
CREATED:20230918T105454Z
SUMMARY:[PAINT] Game Engine Wizardry for Programming Mischief - Riemer van Rozen
DESCRIPTION:Programming grants individuals the capability to design\, create\, and bring ideas to life. To improve their skills\, programmers require powerful languages and programming environments for understanding the impact of gradual code changes. We investigate how modern game engine technology can be leveraged for creating visual input and feedback mechanisms that drive exploratory and live programming. In this paper\, we report experiences on creating a visual programming environment for Machinations\, a domain-specific language for game design. We share initial findings on how to automate the development of graph- and tree-based editors in Godot\, an open source game engine. Our results show that today’s game engine technology provides a solid foundation for future programming language research.
LOCATION:Room V - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231007T210836Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T103000Z
DTEND:20231023T110000Z
DTSTAMP:20231021T100631Z
UID:6be84336-55a5-4b21-ab22-52729ddcfa74@conf.researchr.org
CREATED:20230918T105454Z
SUMMARY:[PAINT] Visual Replacements: Cross-language Domain-specific Representations in Structured Editors - Tom Beckmann\, Daniel Stachnik\, Jens Lincke\, Robert Hirschfeld
DESCRIPTION:To help developers work at the level of abstraction of their choice\, some editors offer to replace parts of source code with domain-specific representations (DSRs). Typically\, such replacements are language-specific and optimized to limited use-cases. In this paper\, we extend a general-purpose structured editor with visual replacements\, a mechanism to replace code of any programming language with DSRs. A visual replacement consists of language-dependent queries to map arbitrary syntax trees and a language-independent DSR of differing abstraction and interactivity\, ranging from simple images to graphical user interfaces that modify source code. Our extension synchronizes source code and DSR automatically\, while ensuring that language support such as autocompletion and error checking work even inside a replacement. We demonstrate the use and applicability of the replacement mechanism in three case studies.
LOCATION:Room V - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231016T195941Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T110000Z
DTEND:20231023T113000Z
DTSTAMP:20231021T100631Z
UID:93e03b15-835d-471a-9b48-672fe6980ef8@conf.researchr.org
CREATED:20230922T141033Z
SUMMARY:[PAINT] Transforming an internal textual DSL into a Blended Modelling Environment - Aleandro Mifsud\, Georgia Samaritaki\, Ulyana Tikhonova\, Jouke Stoel
DESCRIPTION:
LOCATION:Room V - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231007T210836Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T100000Z
DTEND:20231023T110000Z
DTSTAMP:20231021T100631Z
UID:93dd7e44-3595-4e56-badd-a84713ed7e74@conf.researchr.org
CREATED:20230918T131338Z
SUMMARY:[VMIL] Polyglot Programming through Foreign Function Interfaces - Shigeru Chiba
DESCRIPTION:Software development in multiple languages is getting common. A modern VM such as GraalVM allows mixing multiple languages on a single instance of the VM. C/C++ programs can link libpython to execute Python code from C/C++. This is great\, but this talk will discuss a few missing pieces behind the scenes. \nBio: Shigeru Chiba is Professor at Graduate School of Information Science and Technology\, The University of Tokyo. After internship at XEROX Palo Alto Research Center\, he received his PhD degree from The University of Tokyo in 1996. While doing research on programming languages\, particularly\, reflection\, meta programming\, and aspect orientation\, he has been developing several software products. For example\, his Java bytecode engineering library named Javassist has been widely used in both academia and industry. This work recently won AITO Test of Time Award 2000 in 2020. He is also the author of several Japanese books for practitioners and students
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T094125Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T100000Z
DTEND:20231023T101000Z
DTSTAMP:20231021T100631Z
UID:030e54ea-3709-4416-b45f-32cb847ed407@conf.researchr.org
CREATED:20231004T105313Z
SUMMARY:[LOPSTR] Opening Remarks - Robert Glück
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071824Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T101000Z
DTEND:20231023T111000Z
DTSTAMP:20231021T100631Z
UID:b1480008-c1df-46e6-9b32-e6854126e779@conf.researchr.org
CREATED:20231002T081326Z
SUMMARY:[LOPSTR] Unification Modulo Equational Theories in Languages with Binding Operators - Maribel Fernandez
DESCRIPTION:Unification (i.e.\, solving equations between terms) is a key step in the implementation of logic programming languages and theorem provers\, and is also used in type inference algorithms for functional languages and as a mechanism to analyse rewrite-based specifications (e.g.\, to find critical pairs). Matching is a version of unification in which only one of the terms in the equation can be instantiated. Often\, operators satisfy equational axioms (e.g.\, associativity\, commutativity)\, which must be taken into account during the unification or matching process. In addition\, when the expressions to be unified involve binding operators (as is the case when representing programs\, logics\, computation models\, etc.)\, unification and matching algorithms must take into account the alpha-equivalence relation generated by the binders. In this talk\, we present matching and unification algorithms for languages that include binding operators as well as operators that satisfy equational axioms\, such as associativity and commutativity.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071824Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T111000Z
DTEND:20231023T113000Z
DTSTAMP:20231021T100631Z
UID:7ed83bc7-cd73-4c73-a65c-78b7879ed4d1@conf.researchr.org
CREATED:20231002T124123Z
SUMMARY:[LOPSTR] Towards a Certified Proof Checker for Deep Neural Network Verification - Remi Desmartin\, Omri Isac\, Grant Passmore\, Kathrin Stark\, Guy Katz\, Ekaterina Komandantskaya
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071824Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T100000Z
DTEND:20231023T103000Z
DTSTAMP:20231021T100631Z
UID:09300f00-1b92-4f46-a3bc-ed8d7739536e@conf.researchr.org
CREATED:20230921T105426Z
SUMMARY:[LIVE] Live & Local Schema Change: Challenge Problems - Jonathan Edwards\, Tomas Petricek\, Tijs van der Storm
DESCRIPTION:Schema change is an unsolved problem in both live programming and local-first software. We include in schema change any change to the expected shape of data\, whether that is expressed explicitly in a database schema or type system\, or whether those expectations are implicit in the behavior of the code. Schema changes during live programming can create a mismatch between the code and data in the running environment. Similarly\, schema changes in local-first programming can create mismatches between data in different replicas\, and between data in a replica and the code colocated with it. In all of these situations the problem of schema change is to migrate or translate existing data in coordination with changes to the code. \nThis paper contributes a set of concrete scenarios involving schema change that are offered as challenge problems to the live programming and local-first communities. We hope that these problems will spur progress by providing concrete objectives and a basis for comparing alternative solutions.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T125850Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T103000Z
DTEND:20231023T110000Z
DTSTAMP:20231021T100631Z
UID:f0baa852-acb1-4590-a66c-13eab158f610@conf.researchr.org
CREATED:20230921T105426Z
SUMMARY:[LIVE] CodeProber: Live Compiler Exploration - Anton Risberg Alaküla\, Görel Hedin\, Niklas Fors
DESCRIPTION:This talk presents CodeProber\, a tool for interactive exploration of compilers and static analysis tools. CodeProber allows the user to explore properties on an AST. However\, instead of showing the AST to the user\, most interactions happen in terms of the original source code. This allows for a quick and natural interaction that helps with the development and debugging of language tooling. CodeProber can be a complement to more traditional tools\, like debuggers and print statements. CodeProber works especially well with tools built using the JastAdd metacompiler. In the talk\, usage of CodeProber will be demonstrated together with the Java compiler ExtendJ. The compiler will have been prepared with a bug\, and it will be identified and fixed during the presentation. \nCodeProber has been used in two courses: “Compilers” and “Program Analysis”. Students used CodeProber to help develop and debug features during labs in both courses. Overall feedback has been good. Some of the findings from students will be presented during the talk. \nCodeProber was initially presented in a 2022 SLE paper “Property Probes: Source Code Based Exploration of Program Analysis Results”. Since then\, CodeProber has had significant feature growth. The new features\, and how it relates to our future plans for the tool\, will also be presented.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T125850Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T110000Z
DTEND:20231023T113000Z
DTSTAMP:20231021T100631Z
UID:920f47ad-5cba-4e35-bdb4-c2f6929a4d8f@conf.researchr.org
CREATED:20231018T123903Z
SUMMARY:[LIVE] Language Model Agents Enable Semi-Formal Programming - Josh Pollock\, Arvind Satyanarayan\, Daniel Jackson
DESCRIPTION:In the pursuit of malleable programming environments\, researchers and practitioners have explored different ways to capture semantic information before a user has fully specified their program. To date\, however\, these efforts have required system designers to build their formalisms from parts that are either fully formal or else fully opaque to the system. In this paper\, we sketch how large language models (LLMs) can enable \textit{semi-formal programming}. In a semi-formal program\, some pieces of information are fully formalized in the host language’s data structure\, but other pieces are left informal. Semi-formal information that is semantically meaningful can be executed directly by a language model agent (LMA)\, be used to guide the user in fully formalizing their program\, or serve as a specification for generating a program that captures the user’s intent.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T125850Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T100000Z
DTEND:20231023T103000Z
DTSTAMP:20231021T100631Z
UID:3e754ab4-ba49-4f80-98bf-4e5c8a94dc9a@conf.researchr.org
CREATED:20230913T165324Z
SUMMARY:[ST30 ] Asynchronous and Synchronous Mixed Sessions - Kirstin Peters\, Nobuko Yoshida
DESCRIPTION:Session types provide a flexible programming style for structuring interaction\, and are used to guarantee a safe and consistent composition of distributed processes. Traditional session types include only one-directional input (external) and output (internal) guarded choices. This prevents the session-processes to explore the full expressive power of the pi-calculus where the mixed choices are proved more expressive than the (non-mixed) guarded choices. To account this issue\, recently Casal\, Mordido\, and Vasconcelos proposed the binary session types with mixed choices (CMV+). Our recent paper at EXPRESS/SOS’22 carries a surprising result on (CMV+): in spite of an inclusion of unrestricted channels with mixed choice\, CMV+’s mixed choice is rather separate and not mixed. \nIn this talk\, we present our recent trial to carry out this expressive study for asynchronous mixed sessions (synchronous calculus with FIFO queues) where a naive extension of synchronous mixed sessions breaks the type and communication safety.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230913T174216Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T103000Z
DTEND:20231023T110000Z
DTSTAMP:20231021T100631Z
UID:a48657ff-caa9-437a-becf-3144918cd962@conf.researchr.org
CREATED:20230913T165324Z
SUMMARY:[ST30 ] Classical Processes in modern dress - Vikraman Choudhury\, Simon J. Gay
DESCRIPTION:The Curry-Howard correspondence between linear logic and session types is well-known. In this talk\, I will discuss some attempts to extend this to a Lambek correspondence\, relating categorical models of classical linear logic to the semantics of session types. This crucially relies on an understanding of typed process equivalence or typed bisimulation for session-typed processes\, which is necessary to axiomatize the theory of session types. The work is in progress\, and I will present some preliminary ideas.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230913T174216Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T110000Z
DTEND:20231023T113000Z
DTSTAMP:20231021T100631Z
UID:a3af4710-fe39-40d4-88c6-8c9a7dd8e6fd@conf.researchr.org
CREATED:20230913T165324Z
SUMMARY:[ST30 ] Labelled Tensor Types in Session Based Programming - Luís Caires
DESCRIPTION:The computational interpretation of linear logic as a session-typed pi calculus has motivated many developments\, and can be accepted as a fairly canonical typed model for stateful concurrent computation with linear resources\, pretty much like the lambda calculus is considered a canonical typed model for functional sequential computation with pure values. Building on this logical approach\, in this talk we will discuss labelled tensor session types\, namely record and mutable record types and their duals\, which substantially increase the flexibility in linearly-typed session-based programming. Labelled tensor types support random access paths to ``data-structures-as-processes" and relaxing acyclicity constraints from trees to dags in shared linear data structures. We will also offer further motivation\, formally present labelled tensor types\, their typing rules and metatheory\, compare with recent work on linear type systems for concurrent and message passing programming and demonstrate their expressiveness in realistic concurrent session-based shared-state programs written in an extension of our CLASS implementation.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230913T174216Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T100000Z
DTEND:20231023T113000Z
DTSTAMP:20231021T100631Z
UID:6d5b83d5-d380-4b45-999a-4da41d9e452e@conf.researchr.org
CREATED:20230918T135643Z
SUMMARY:[GPCE] Coccinelle: Impact and Internals - Julia Lawall
DESCRIPTION:Coccinelle is a program matching and transformation tool for C code that was first developed in the mid 2000s. Coccinelle has been extensively used on the Linux kernel\, in over 9000 commits\, as well as on other C projects. In this talk\, we will present some recent uses of Coccinelle and discuss some of the design decisions that makes these results possible.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231009T220029Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T130000Z
DTEND:20231023T133000Z
DTSTAMP:20231021T100631Z
UID:eedd20a2-58d9-4b0c-9c6c-bab6d6546400@conf.researchr.org
CREATED:20230916T200020Z
SUMMARY:[PPDP] Strongly-Typed Multi-View Stack-Based Computations - Pieter Koopman\, Mart Lubbers
DESCRIPTION:High-level language languages are often implemented by transforming them to a stack-based intermediate language. To ensure correctness of the implementation\, it is desirable to have a type-system for the stack-based code that ensures that the required arguments are available on the stack. This is quite challenging since the stack contains values of mixed types. Moreover\, a single stack is shared by all basic stack instructions and the functions implemented with those instructions. Just like basic instructions\, function calls are expected to replace their arguments by the result and to leave the rest of the stack untouched. \nThis paper shows a Domain-Specific Language\, DSL\, for stack-based computations embedded in strongly typed functional programming language. We use heterogeneous lists in the DSL to ensure that the top of the stack contains the required elements for instructions and functions. Type correctness of the composition of instructions and functions is ensured by requiring that the remainder of the stack is unchanged. However\, standard typing restrictions impose that all function applications have identically typed arguments and hence an identical stack layout. We present a simple solution based on data types with universally quantified type variables. The resulting DSL supports multiple views and handles mutually recursive functions of arbitrary arities.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053037Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T133000Z
DTEND:20231023T140000Z
DTSTAMP:20231021T100631Z
UID:1cfa1256-229d-4201-8996-4e8ac6100dea@conf.researchr.org
CREATED:20230916T200020Z
SUMMARY:[PPDP] Closure Conversion in Little Pieces - Zachary Sullivan\, Paul Downen\, Zena M. Ariola
DESCRIPTION:Closure conversion\, an essential step in compiling functional programs\, is traditionally presented as a global transformation from a language with higher-order functions to one without. Optimizing this transformation can be done at any of its three stages with various tradeoffs. After conversion\, optimizations will be in the target language at the cost of a weaker equational theory. During conversion\, optimizations may be embedded into the transformation itself at the cost of increasing its complexity and correctness. And before conversion\, optimizations may be planned and anticipated in a specialized intermediate language (IL) where all the properties of the source program are still known\, with the hope that they will survive the rest of the compilation process. \nBy building on the notion of abstract closures\, we blur the distinctions between these three approaches to closure conversion and optimizations thereof\, by combining all of their strengths and avoiding their weaknesses. Specifically\, we develop an IL that includes closures alongside unclosed higher-order code\, even inhabiting the same type. The IL comes equipped with an equational theory that is shown sound and complete with respect to an environment abstract machine. Thereby\, a baseline closure conversion and common optimizations become provable equalities and thus are correct by construction. Moreover\, the transformation and its correctness proof are broken down into little steps—as instances of the $\beta$ and $\eta$ axioms—instead of being expressed in terms of a recursive procedure. \nOur proposed IL is based on call-by-push-value which we extend with sharing in order to capture closure conversion for both strict and lazy languages.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053037Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T140000Z
DTEND:20231023T143000Z
DTSTAMP:20231021T100631Z
UID:c72d88be-8f12-4e48-8d14-3325c834144d@conf.researchr.org
CREATED:20230916T200020Z
SUMMARY:[PPDP] Additive Cellular Automata Graded-Monadically - Silvio Capobianco\, Tarmo Uustalu
DESCRIPTION:Cellular automata are an archetypical comonadic notion of computation in the sense that computation happens in the coKleisli category of a comonad. In this paper\, we show that they can also be viewed as graded comonadic—a perspective that turns out to be both more informative and also more basic. We also discuss additive cellular automata to show that they admit both a graded comonadic and a graded monadic view. That these two perspectives are simultaneously available in this special case arises from a graded version of an observation by Kleiner about adjoint comonad-monad pairs.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053037Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T130000Z
DTEND:20231023T133000Z
DTSTAMP:20231021T100631Z
UID:d6dd6e05-2880-4617-a816-8ab1ab94b46f@conf.researchr.org
CREATED:20230918T142744Z
SUMMARY:[SAS ] Error Invariants for Fault Localization via Abstract Interpretation - Aleksandar S. Dimovski
DESCRIPTION:Fault localization aims to automatically identify the cause of an error in a program by localizing the error to a relatively small part of the program. In this paper\, we present a novel technique for automated fault localization via error invariants inferred by abstract interpretation. An error invariant for a location in an error program over-approximates the reachable states at the given location that may produce the error\, if the execution of the program is continued from that location. Error invariants can be used for statement-wise semantic slicing of error programs and for obtaining concise error explanations. We use an iterative refinement sequence of backward-forward static analyses by abstract interpretation to compute error invariants\, which are designed to explain why an error program violates a particular assertion. We demonstrate the effectiveness of our approach to localize errors in realistic C programs.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T174137Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T133000Z
DTEND:20231023T140000Z
DTSTAMP:20231021T100631Z
UID:338ac323-5854-448c-b06c-7a251c36c73a@conf.researchr.org
CREATED:20230918T142744Z
SUMMARY:[SAS ] Error Localization for Sequential Effect Systems - Colin Gordon\, Chaewon Yun
DESCRIPTION:We describe a new concrete approach to giving predictable and useful error locations for sequential (flow-sensitive) effect systems. Prior implementations of sequential effect systems rely on either computing a bottom-up effect and comparing it to a declaration (e.g.\, method annotation) or leaning on constraint-based type inference. These approaches both give errors at locations or granularities far removed from where a mistake might have been made. \nInstead of relying on constraint solving\, we draw on the notion of a residual from work on ordered algebraic structures. Applying these to effect quantales (a large class of sequential effect systems) yields an implementation approach which accepts exactly the same program as an original effect quantale\, but for effect-incorrect programs is guaranteed to fail type-checking with predictable error locations tied to the earliest point in evaluation order where the program would definitely violate its specification. We have implemented this idea in a generic effect system implementation framework for Java\, and report on experiences applying effect systems from the literature effect systems to Java programs. We find that the reported error locations with our technique are significantly closer to the program points that lead to failed effect checks.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052504Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T140000Z
DTEND:20231023T143000Z
DTSTAMP:20231021T100631Z
UID:a9f01678-d9ca-4887-8b97-b3f3c74bcc84@conf.researchr.org
CREATED:20230918T142744Z
SUMMARY:[SAS ] Scaling up Roundoff Analysis of Functional Data Structure Programs - Anastasia Isychev\, Eva Darulova
DESCRIPTION:Floating-point arithmetic is counter-intuitive due to inherent rounding errors that potentially occur at every arithmetic operation. A selection of automated tools now exists to ensure correctness of floating-point programs by computing guaranteed bounds on rounding errors at the end of a computation\, but these tools effectively consider only straight-line programs over scalar variables. Much of numerical codes\, however\, use data structures such as lists\, arrays or matrices and loops over these. To analyze such programs today\, all data structure operations need to be unrolled\, manually or by the analyzer\, reducing the analysis to straight-line code\, ultimately limiting the analyzers’ scalability. \nWe present the first rounding error analysis for numerical programs written over vectors and matrices that leverages the data structure information to speed up the analysis. We facilitate this with our functional domain-specific input language that we design based on a new set of numerical benchmarks that we collect from a variety of domains. Our DSL explicitly carries semantic information that is useful for avoiding duplicate and thus unnecessary analysis steps\, as well as enabling abstractions for further speed-ups. Compared to unrolling-based approaches in state-of-the-art tools\, our analysis retains adequate accuracy and is able to analyze more benchmarks or is significantly faster\, and particularly scales better for larger programs.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052504Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T130000Z
DTEND:20231023T133000Z
DTSTAMP:20231021T100631Z
UID:cd3bd705-b7f0-4b84-8037-dcc6cb20b7dd@conf.researchr.org
CREATED:20231003T154436Z
SUMMARY:[SLE] A reference GLL implementation - Adrian Johnstone
DESCRIPTION:The Generalised-LL (GLL) context-free parsing algorithm was introduced at the 2009 LDTA workshop\, and since then a series of variant algorithms and implementations have been described. There is a wide variety of optimisations that may be applied to GLL \, some of which were already present in the originally published form. \nThis paper presents a reference GLL implementation shorn of all optimisations as a common baseline for the real-world comparison of performance across GLL variants. This baseline version has pedagogic value\, since its simple form may be straightforwardly encoded in the implementer’s preferred programming language. \nWe also describe our approach to low level memory management of GLL internal data structures. Our evaluation on large inputs shows a factor 3–4 speedup over a naïve implementation using the standard Java APIs and a factor 4–5 reduction in heap requirements. We conclude with notes on some algorithm-level optimisations that may be applied independently of the internal data representation.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052707Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T133000Z
DTEND:20231023T140000Z
DTSTAMP:20231021T100631Z
UID:9d132fff-e875-432c-90a8-f150bf2f2aad@conf.researchr.org
CREATED:20231003T154436Z
SUMMARY:[SLE] Sharing Trees and Contextual Information: Re-imagining Forwarding in Attribute Grammars - Lucas Kramer\, Eric Van Wyk
DESCRIPTION:It is not uncommon to design a full-featured programming language around a smaller core language so that other features may explicitly define some semantic analyses or tasks but delegate others to their translation into the core. Semantic analyses typically require contextual information\, such as a typing environment. When this context is the same for a term appearing under a new feature and the translation then the term’s tree\, and the computations over it\, can be shared with context provided by the translation to avoid redundant\, and sometimes exponential computations. Forwarding is a technique in attribute grammars that makes the delegation of semantic tasks automatic\, permitting independent language extensions to work together. Here we describe mechanisms that allow forwarding to share trees and specifications of contextual information (as inherited attributes) between a feature and its core translation. We evaluate these techniques by applying them to language features in the ableC extensible C compiler and find that they replace around 80% of the instances in which sharing of trees was achieved by a crude mechanism that prevented sharing the specification of context and limited language extensibility. This avoided all instances in which this mechanism was used to avoid exponential computations. The techniques also allowed the removal of many\, now not needed\, inherited attribute equations.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052707Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T140000Z
DTEND:20231023T143000Z
DTSTAMP:20231021T100631Z
UID:894c4e79-4bbe-4672-a8e4-5b24deeeb068@conf.researchr.org
CREATED:20231003T154436Z
SUMMARY:[SLE] Nanopass Attribute Grammars - Nathan Ringo\, Lucas Kramer\, Eric Van Wyk
DESCRIPTION:Compilers for feature-rich languages are complex\; they perform various analyses\, optimizations\, and often lower syntactic sugar and complex language constructs into simpler ones in the language. The nanopass compiler architecture manages this complexity by specifying the compiler as a sequence of many small transformations\, over slightly different\, clearly identified\, versions of the language\, that each perform a single well-defined action. This avoids errors that arise from attempting to solve multiple problems at once and allows for testing at each step. Attribute grammars are\, unfortunately\, ill-suited for this architecture\, primarily because one cannot identify the many versions of the language used in the different passes in a non-verbose and type-safe way. We present a formulation of attribute grammars that addresses these concerns\, called nanopass attribute grammars\, by (i) identifying a collection of all language constructs and analyses (as attributes) to be used\, (ii) concisely constructing specific (sub) languages from this set and transformations between them\, and (iii) specifying compositions of transformations to form nanopass compilers. The collection of all features can be statically typed and individual languages can be checked for equation completeness\, well-definedness\, and circularity. This is done individually for each language since different productions will induce different dependencies on attributes. We evaluate the approach by implementing a significant subset of the Go programming language in a prototype nanopass attribute grammar system.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052707Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T130000Z
DTEND:20231023T143000Z
DTSTAMP:20231021T100631Z
UID:f22a2137-56c9-4288-9609-233a410d0321@conf.researchr.org
CREATED:20230918T150317Z
SUMMARY:[SPLASH PLMW] Career Panel - Felienne Hermans\, Chandrakana Nandi\, Jürgen Cito
DESCRIPTION:
LOCATION:Room III - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072325Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T130000Z
DTEND:20231023T133000Z
DTSTAMP:20231021T100631Z
UID:93a4c249-3b27-43cb-bd1e-117cb7a90c07@conf.researchr.org
CREATED:20230916T214912Z
SUMMARY:[REBLS] ComPOS: a DSL for Composing IoT Systems With Weak Connectivity - Alfred Åkesson\, Görel Hedin\, Niklas Fors
DESCRIPTION:Future Internet-of-Things (IoT) systems need to combine heterogeneous IoT components and support weak connectivity. This paper introduces ComPOS\, a domain-specific language for composing IoT services into systems. ComPOS is a small language but supports powerful message mediation\, using stateful reactions with nested and parallel message sequences and anonymous futures. To deal with weak connectivity\, we introduce the notion of abort semantics\, i.e.\, aborting old reactions when a newer message arrives. Alternatives to the abort semantics can be obtained by adding strategy services. We evaluated our approach by implementing seven home automation scenarios.
LOCATION:Room IV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230916T214912Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T133000Z
DTEND:20231023T140000Z
DTSTAMP:20231021T100631Z
UID:ad7f5407-8b34-4f22-8146-bb0ffc0fa64d@conf.researchr.org
CREATED:20230916T214912Z
SUMMARY:[REBLS] Actix-Telepathy - Phillip Wenig\, Thorsten Papenbrock
DESCRIPTION:The actor programming model supports the development of concurrent applications by encapsulating state and behavior into independent actors. Each actor is a computational entity with strictly private state and behavior. Actors communicate via asynchronous messaging and\, in this way\, require neither shared memory nor locking. This makes the actor model suitable not only for parallel programming but also for distributed applications engineering. \nThe Rust programming language is a statically-typed language that gained a lot of attention in the past years due to its efficient\, economical and safe memory management. To ease the development of parallel applications\, several actor model frameworks have been built for Rust. However\, no actively maintained Rust actor framework provides the necessary features to write distributed applications. For this reason\, we propose an extension for Rust’s Actix library\, called Actix-Telepathy\, that enables remote messaging and offers clustering support. It allows developers to setup remote actors that can communicate across a computer network with the help of a straight forward and easy to understand interface. Our evaluation demonstrates that Actix-Telepathy competes well in remote messaging performance and memory consumption with other actor libraries\, such as Scala’s popular Akka library.
LOCATION:Room IV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230916T214912Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T140000Z
DTEND:20231023T143000Z
DTSTAMP:20231021T100631Z
UID:8bd01853-0781-416b-b207-c2d20ab8365a@conf.researchr.org
CREATED:20230916T214912Z
SUMMARY:[REBLS] Realizing Persistent Signals in JavaScript - Daichi Hidaka\, Tetsuo Kamina
DESCRIPTION:Reactive programming enables declarative descriptions of dependencies between and computations throughout signals\, an abstraction of time-varying values. Signals have been extended to persistent signals (an abstraction of time-varying values with their execution histories) to enable them to go back in time with any given time. Currently\, this feature is only supported by SignalJ\, an extension to Java with signals. This limits the use of persistent signals only within the Java-based applications. This is an undesirable restriction\, because mechanisms used in realizing persistent signals are actually language-independent. To tackle this problem\, we propose an implementation of persistent signals in JavaScript\, which makes application areas of persistent signals broader\, including Web-frontend. To realize persistent signals in JavaScript\, seamless connections between JavaScript programs that run on the restricted environments such as browsers and time-series databases that serve histories of persistent signals are required. It is also desirable to reuse existing JavaScript ecosystem. To address these problems\, we design a relay-server-based architecture and realize persistent signals in JavaScript as a DSL library.
LOCATION:Room IV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230916T214912Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T130000Z
DTEND:20231023T133000Z
DTSTAMP:20231021T100631Z
UID:f6e677e9-67d7-4cd1-8609-8b3b2c218c2d@conf.researchr.org
CREATED:20230918T105931Z
SUMMARY:[PAINT] A Penny a Function: Towards Cost Transparent Cloud Programming - Lukas Böhme\, Tom Beckmann\, Sebastian Baltes\, Robert Hirschfeld
DESCRIPTION:Understanding and managing monetary cost factors is crucial when developing cloud applications. However\, the diverse range of factors influencing costs for computation\, storage\, and networking in cloud applications poses a challenge for developers who want to manage and minimize costs proactively. Existing tools for understanding cost factors are often detached from source code\, causing opaqueness regarding the origin of costs. Moreover\, existing cost models for cloud applications focus on specific factors such as compute resources and necessitate manual effort to create the models. \nThis paper presents initial work toward a cost model based on a directed graph that allows deriving monetary cost estimations directly from code using static analysis. Leveraging the cost model\, we explore visualizations embedded in a code editor that display costs close to the code causing them. This makes cost exploration an integrated part of the developer experience\, thereby removing the overhead of external tooling for cost estimation of cloud applications at development time.
LOCATION:Room V - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231016T195624Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T133000Z
DTEND:20231023T140000Z
DTSTAMP:20231021T100631Z
UID:dd7f7543-055d-41a0-b782-805ca8cd7895@conf.researchr.org
CREATED:20231007T210502Z
SUMMARY:[PAINT] The Implementation of A Type-Safe Structure Editor - Thorbjørn Bülow Bringgaard\, Hans Hüttel\, Michael Bak Koldsgaard\, Nicolaj Richs-Jensen\, Tórur Feilberg Zachariassen
DESCRIPTION:
LOCATION:Room V - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231007T210836Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T140000Z
DTEND:20231023T143000Z
DTSTAMP:20231021T100631Z
UID:be6e84fd-5fe3-4f55-918b-7e29f1ebfa1b@conf.researchr.org
CREATED:20231007T210655Z
SUMMARY:[PAINT] Beginning Student Tables - Samuel Maginot\, Chung-chieh Shan\, Sam Tobin-Hochstadt
DESCRIPTION:
LOCATION:Room V - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231007T210836Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T130000Z
DTEND:20231023T132500Z
DTSTAMP:20231021T100631Z
UID:170a2f02-77d7-4ca2-b88b-088bde4277b4@conf.researchr.org
CREATED:20230918T131006Z
SUMMARY:[VMIL] Debugging Dynamic Language Features in a Multi-Tier Virtual Machine - Anmolpreet Singh\, Aayush Sharma\, Meetesh Kalpesh Mehta\, Manas Thakur
DESCRIPTION:Multi-tiered virtual-machine (VM) environments\, involving Just-In-Time (JIT) compilers\, play a crucial role in optimizing program performance for dynamic languages\, but understanding and debugging their internal workings can be a challenging task. In this paper\, we present a novel tool specifically designed to address this issue in the context of Ř\, a JIT compiler for the R programming language. Our tool aims to demystify Ř and provide a suitable middle ground for both beginners and professionals. It allows users to investigate the runtime state of the system\, make modifications\, and visualize contextual specializations. By providing a user-friendly interface and visualization capabilities\, our tool empowers developers to explore\, experiment with\, and gain valuable insights into the inner workings of a specializing JIT system. We evaluate the effectiveness and usability of our tool through real-world use cases\, demonstrating its benefits in learning as well as debugging scenarios. We believe that our tool holds promise for enhancing the understanding and debugging of complex VMs\, ultimately leading to improved program performance\, increased developer productivity\, and likely even more innovation.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T093843Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T132500Z
DTEND:20231023T135000Z
DTSTAMP:20231021T100631Z
UID:64df3abc-838d-424d-9b73-65401a370124@conf.researchr.org
CREATED:20230918T131006Z
SUMMARY:[VMIL] Array Bytecode Support in MicroJIT - Shubham Verma\, Harpreet Kaur\, Kenneth Kent\, Marius Pirvu
DESCRIPTION:Eclipse OpenJ9 is a Java virtual machine (JVM)\, which initially interprets Java programs. OpenJ9 uses Just-in-Time (JIT) compilers—like the default Testarossa JIT (TRJIT)—to translate the program into native code\, which executes faster than interpreting. TRJIT is an optimizing compiler\, which can introduce overhead during runtime but generally improves startup time compared to interpretation. However\, there is room for improvement with a lightweight compiler. MicroJIT is a non-optimizing\, template-based compiler\, which aims to reduce compilation overhead and startup time. Array bytecodes were not supported in the initial implementation of MicroJIT\, forcing them to either be interpreted or compiled using TRJIT. This work implements array bytecodes such as\, \textit{newarray\, aaload\, aastore}\, in MicroJIT and measures their impact on execution of the programs. The implementation is tested with a regression test suite and the experiments are performed on the DaCapo benchmark suite. The results show that TRJIT along with MicroJIT including array bytecodes support is approximately 4.36x faster than the interpreter and 1.02x faster than the MicroJIT without array bytecodes support. These findings highlight the potential of MicroJIT in improving the performance of Java programs by efficiently handling array bytecodes.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T093852Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T135000Z
DTEND:20231023T141500Z
DTSTAMP:20231021T100631Z
UID:63a5af7d-07f1-41aa-8d60-a8e773b117b0@conf.researchr.org
CREATED:20230918T131006Z
SUMMARY:[VMIL] Hybrid Execution: Combining Ahead-of-Time and Just-in-Time Compilation - Christoph Pichler\, Paley Li\, Roland Schatz\, Hanspeter Mössenböck
DESCRIPTION:Ahead-of-time (AOT) compilation is a well-known approach to statically compile programs to native code before they are executed. In contrast\, just-in-time (JIT) compilation typically starts with executing a slower\, less optimized version of the code and compiles frequently executed methods at run time. In doing so\, information from static and dynamic analysis is utilized to speculate and help generate highly efficient code. However\, generating such an efficient JIT-compiled code is challenging\, and this introduces a trade-off between start-up performance and peak performance. \nIn this paper\, we present a novel way to execute programs by bringing together the divergence that existed between AOT and JIT compilation. Instead of having the JIT compiler analyze the program during interpretation to produce optimal code\, critical functions are initially executed natively with code produced by the AOT compiler in order to gain a head start. Thus\, we avoid the overhead of JIT compilation for natively executed methods and increase the start-up performance. We implemented our approach in GraalVM\, which is a multi-language virtual machine based on the Java HotSpot VM. Improvements in start-up performance show a speed-up of up to 1.7x. However\, the results depend heavily on how we select which code is run natively and which code is interpreted and JIT compiled.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T093906Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T141500Z
DTEND:20231023T143000Z
DTSTAMP:20231021T100631Z
UID:f62eba09-3864-4299-b7cc-0b81c9730385@conf.researchr.org
CREATED:20231019T093828Z
SUMMARY:[VMIL] Approximating Type Stability in the Julia JIT - Artem Pelenitsyn
DESCRIPTION:Julia is a dynamic language for scientific computing. For a dynamic language\, Julia is surprisingly typefull. Types are used not only to structure data but also to guide dynamic dispatch – the main design tool in the language. No matter the dynamism\, Julia is performant: flexibility is compiled away at the run time using a simple but smart type-specialization based optimization technique called type stability. Based on a model of a JIT mimicking Julia from previous works\, we present the first algorithm to approximate type stability of Julia code. Implementation and evaluation of the algorithm is still a work in progress.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T094008Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T130000Z
DTEND:20231023T133500Z
DTSTAMP:20231021T100631Z
UID:cb74dca3-835f-4805-88d4-34a68744e468@conf.researchr.org
CREATED:20231002T130820Z
SUMMARY:[LOPSTR] A Reusable Machine-Calculus for Automated Resource Analyses - Hector Suzanne\, Emmanuel Chailloux
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071830Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T133500Z
DTEND:20231023T141000Z
DTSTAMP:20231021T100631Z
UID:945bae6f-4bc1-42f8-94f1-316b568cb6fd@conf.researchr.org
CREATED:20231002T130820Z
SUMMARY:[LOPSTR] A Logical Interpretation of Asynchronous Multiparty Compatibility - Marco Carbone\, Sonia Marin\, Carsten Schürmann
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071830Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T141000Z
DTEND:20231023T143000Z
DTSTAMP:20231021T100631Z
UID:d3097903-f2fc-474e-8cab-6aa0169c915a@conf.researchr.org
CREATED:20231002T130820Z
SUMMARY:[LOPSTR] Relational Solver for Java Generics Type System - Petr Lozov\, Dmitry Kosarev\, Dmitry Ivanov\, Dmitri Boulytchev
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071830Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T130000Z
DTEND:20231023T133000Z
DTSTAMP:20231021T100631Z
UID:d2969f52-99bd-4499-a815-a261bc7b911b@conf.researchr.org
CREATED:20231018T124121Z
SUMMARY:[LIVE] Document-oriented programming based on edit history - Tomas Petricek\, Jonathan Edwards
DESCRIPTION:The demo presents a programming environment based on two key principles. First\, it focuses on working with documents that are enriched with simple formulas. Second\, progams are represented as a history of edits. Thanks to the design\, we are able to: \n \n Work in an local-first way and merge concurrent edits made to the document \n Automatically adapt code to reflect new structure of the document when it is changed by an edit \n Treat evaluation as edits and invalidate results that are affected by a concurrent edit \n \nThe demo shows a simple prototype implementation that achieves the above three. It is an early exploration of a vision for a programming system that combines image-based programming of Smalltalk with structured programming model pioneered by Subtext and adds support for a modern local-first collaboration and programming ranging from simple formulas to powerful reflective code.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T130215Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T133000Z
DTEND:20231023T140000Z
DTSTAMP:20231021T100631Z
UID:fcb230ca-9fa1-43f5-b251-87c5068d66a5@conf.researchr.org
CREATED:20231018T124121Z
SUMMARY:[LIVE] TypeCell: End-User Programming in Block-Based rich text documents - Yousef El-Dardiry
DESCRIPTION:TypeCell explores End-User Programming capabilities in a block-based rich text editing application. With end-user programming\, users can modify and extend software they are using\, giving users agency to shape the tools they are using to their own needs. \nWe believe this goal can only be achieved by building an environment focused on Simplicity\; currently\, we believe most programming systems are too complex to appeal to a wide audience. \nTypeCell combines various constructs to reduce this complexity. Most importantly\, TypeCell has been designed as a regular document editor that initially hides its more advanced capabilities - allowing the user to gradually learn about its programming and extensibility capabilities at their own pace. This design is inspired by Spreadsheets (arguably one of the few widely adopted end-user programming systems)\, where users can use the application to create simple tables\, and only later use more advanced functionality such as formulas\, charts\, or plugins. \nIn the attached demo\, we look at 3 aspects specifically: \nLiveness The Cell-based Reactive programming model makes it possible to create advanced programs and interactions with a limited amount of code\, as data flows are mostly abstracted away by the reactive programming layer. \nThe evaluate-as-you-type functionality offers a live\, real-time programming experience\, closing the gap between authoring and visual feedback. \nComposability TypeCell supports document composition\, enabling code reuse across different documents. This makes it possible to encapsulate / hide more complex parts of the system. TypeCell maintains the Liveness across documents (changes in one document are immediately reflected in the other). \nImported documents live in their own “Reactive Scope”\, that can be interacted with from the host document. We believe this model makes it possible to create both Live and Composable programs as defined by [Live\, Rich\, and Composable: Qualities for Programming Beyond Static Text\, Joshua Horowitz and Jeffrey Heer]. \nExtensibility Code written in documents can function as Plugins to the host environment\, making it possible to modify the application itself. In the demo\, we show how one user creates a Map block that can subsequently be embedded by another user without the need to access the programming system. If the user requires customization of the Block / component\, they can do so at different levels of complexity: \n \n A non-programming “What you see is what you get” experience \n Creating databindings between the component and the host document (code “one-liners”) \n Completely customizing the source code of the component \n \nWe believe this approach allows for gradual customization possibilities without overloading users with complexity. \nIn 2021\, we presented the first version of TypeCell at LIVE\; a “notebook-style” programming environment. We are now excited to demonstrate how this can be embedded into an end-user application (a document editor) - and bridge the gap towards end-user programming. Besides demonstrating the concepts as shown in the video\, I will dive under-the-hood and explain the architecture and pros and cons of the Reactive Live Programming model.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T125906Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T140000Z
DTEND:20231023T143000Z
DTSTAMP:20231021T100631Z
UID:eef76225-05f2-49bb-b403-e953fb9f7d77@conf.researchr.org
CREATED:20231018T124121Z
SUMMARY:[LIVE] Embark: a computational outliner for travel - Paul Sonnentag\, Alexander Obenauer\, Geoffrey Litt
DESCRIPTION:Modern software is organized into applications which each host their own data and computational tools\; users have limited ways to compose behavior across application boundaries. These limits are particularly apparent in tasks like travel planning\, which require coordinating information across multiple tools in unique ways tailored to a specific trip. \nWe present a prototype called Embark which enables users to perform an entire travel planning process within a single outline document enriched with computational tools. In Embark\, users can mix freeform text together with references to external data\, and can author dynamic formulas for pulling in information like weather forecasts and routing information. \nWe find that Embark supports a wide variety of travel use cases ranging from short weekend trips to sprawling RV roadtrips\, all within a single medium. More broadly\, our work proposes an approach to unbundling apps into data\, computations\, and views which can be flexibly composed by users to meet their unique goals.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T125906Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T130000Z
DTEND:20231023T133000Z
DTSTAMP:20231021T100631Z
UID:01f3af6a-a910-43a2-9b6c-b1a7d5dfd243@conf.researchr.org
CREATED:20230913T165236Z
SUMMARY:[ST30 ] Benchmarks for Multiparty Session Types - Martin Vassor\, Nobuko Yoshida
DESCRIPTION:Session types are now 30 years old\, and multiparty session types are 15 years old. The community developed numerous variants\, extensions and implementations of session types\, leading to numerous use cases. Despite this successful record\, the session types community lacks a common set of relevant protocols that could be used to better compare and explain our works. In this talk\, we present a work in progress project to define a benchmark for (multiparty) session types. Our talk will be divided in three part: first\, explaining the motivation for a set of benchmarks and the selection criteria we found relevant\; second\, discussing the current set of protocols we consider. Since we expect our benchmark set to be relevant for the whole session types community\, our third part will be an open discussion to collect feedback from the audience.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230918T224401Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T133000Z
DTEND:20231023T140000Z
DTSTAMP:20231021T100631Z
UID:95f87bf2-6737-4e6c-ac3c-6cd14e08dec0@conf.researchr.org
CREATED:20230913T165236Z
SUMMARY:[ST30 ] Towards Session-Typed Consensus - Matthew Alan Le Brun\, Ornela Dardha
DESCRIPTION:A recent surge in Multiparty Session Types (MPST) has vastly increased the expressivity and practicality of the theory. New theories have introduced notions of failure and failure-handling mechanisms into session types\, with the aim of making them viable for distributed computing. This work asks the question: Is MPST theory capable of accurately describing consensus protocols? We answer this question by attempting to express the Raft consensus algorithm in MAGπ\, a generalised MPST theory capable of modelling non-Byzantine faults. We highlight how\, even with a theory so general\, MAGπ session types cannot accurately describe the protocol. Towards achieving session-typed consensus\, we propose a conservative and minimal extension to MAGπ\, introducing the common distributed-computing concept of terms (a.k.a. time-periods or rounds) into types.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230918T224401Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T140000Z
DTEND:20231023T143000Z
DTSTAMP:20231021T100631Z
UID:74a1fe41-8291-4f30-afd9-39d2175cde32@conf.researchr.org
CREATED:20230913T165236Z
SUMMARY:[ST30 ] Using Event Structures to model Multiparty Session Types: results and open problems - Ilaria Castellani\, Paola Giannini
DESCRIPTION:This talk proposal concerns the use of Event Structures (ESs) as a semantic model for multiparty session types (MPSTs). Based on our previous work on ES semantics for synchronous MPSTs\, it aims at presenting some new initial results and discussing some open problems. In particular\, it will address the issue of characterising the well-formedness conditions for global types semantically\, i.e.\, as structural properties of the ESs obtained by interpreting global types.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230918T224401Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T130000Z
DTEND:20231023T133000Z
DTSTAMP:20231021T100631Z
UID:27074f17-d60f-4bc9-b208-53d8b86f24e8@conf.researchr.org
CREATED:20230918T135730Z
SUMMARY:[GPCE] Crossover: Towards Compiler-enabled COBOL-C Interoperability - Mart van Assen\, Manzi Aimé Ntagengerwa\, Ömer Faruk Sayilir\, Vadim Zaytsev
DESCRIPTION:Interoperability across software languages is an important practical topic — especially in the context of software migration\, where foreign function interfaces can help to replace legacy code fragments with calls to existing alternatives. In this paper\, we take a deep dive into investigating and tackling the challenges involved with achieving interoperability between C and BabyCobol. The latter is a little domain-specific language\, condensing challenges found in compiling legacy languages — borrowing directly from COBOL’s data philosophy — into one quickly implementable language. In this paper\, we introduce Crossover\, a compiler designed specifically to showcase the interoperability and the details of connecting a COBOL-like language with PICTURE clauses and re-entrant procedures\, to C with primitive types and struct composites. Crossover features a C library for bridging the gap in overcoming the differences between the data representations native to the respective languages. We illustrate the design process of Crossover and demonstrate its usage to provide a strategy to achieve interoperability between legacy and modern languages. From a practical perspective\, this directly enables C programmers to contribute to the maintenance of (as well as migration away from) legacy systems. The described process is aimed to be a blueprint for how interoperability can be achieved between full-fledged COBOL and modern (C-like) programming languages\, enabling developers versed in either language to contribute to the maintenance of legacy systems.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231012T174350Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T133000Z
DTEND:20231023T140000Z
DTSTAMP:20231021T100631Z
UID:7fc0ebbe-946a-4eca-9c45-172080575b66@conf.researchr.org
CREATED:20230918T135730Z
SUMMARY:[GPCE] Partial Evaluation of Automatic Differentiation for Differential-Algebraic Equations Solvers - Oscar Eriksson\, Viktor Palmkvist\, David Broman
DESCRIPTION:Differential-Algebraic Equations (DAEs) are the foundation of high-level equation-based languages for modeling physical dynamical systems. Simulating models in such languages requires a transformation known as index reduction that involves differentiating individual equations before numerical integration. Commercial and open-source implementations typically perform index reduction by symbolic differentiation (SD) and produce a Jacobian callback function with forward-mode automatic differentiation (AD). The former results in efficient runtime code\, and the latter is asymptotically efficient in both runtime and code size. However\, AD introduces runtime overhead caused by a non-standard representation of real numbers\, and SD is not always applicable in models with general recursion. This work proposes a new approach that uses partial evaluation of AD in the context of numerical DAE solving to combine the strengths of the two differentiation methods while mitigating their weaknesses. Moreover\, our approach selectively specializes partial derivatives of the Jacobian by exploiting structural knowledge while respecting a user-defined bound on the code size. Our evaluation shows that the new method enables both expressive modeling from AD and retains the efficiency of SD for many practical applications.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231012T174350Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T140000Z
DTEND:20231023T143000Z
DTSTAMP:20231021T100631Z
UID:892985e1-93cc-4a36-aec7-a8ac2391b58d@conf.researchr.org
CREATED:20231012T174350Z
SUMMARY:[GPCE] Generating Constraint Programs for Variability Model Reasoning: A DSL and Solver-Agnostic Approach - Camilo Correa Restrepo\, Jacques Robin\, Raúl Mazo
DESCRIPTION:Verifying and configuring large Software Product Lines (SPL) requires automation tools. Current state-of-the-art approaches involve translating into a formalism accepted as input by a constraint solver. There are currently no standards for the Variability Modeling Languages (VML). There is also a variety of constraint solver input languages. This has resulted in a multiplication of ad-hoc architectures and tools specialized for a single pair of VML and solver\, fragmenting the SPL community. To overcome this limita- tion\, we propose a novel architecture based on model-driven code generation\, where the syntax and semantics of VMLs can be declarative specified as data\, and a standard\, human- readable\, formal pivot language is used between the VML and the solver input language. This architecture is the first to be fully generic by being agnostic to both VML and the solver family. To validate the genericity of the approach\, we have implemented a prototype tool together with declarative specifications for the syntax and semantics of two different VMLs and two different solver Families. One VML is for clas- sic\, static SPL (Feature Model) and the other is for run-time reconfigurable dynamic SPL with soft constraints to be optimized during configuration. The two solver fami- lies are Constraint Satisfaction Problems (CSP) and Constraint Logic Programs (CLP).
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231012T174428Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T150000Z
DTEND:20231023T153000Z
DTSTAMP:20231021T100631Z
UID:0dcd4ece-a86e-4e36-82cd-bd831d00adcf@conf.researchr.org
CREATED:20230916T200041Z
SUMMARY:[PPDP] Intuitionistic Metric Temporal Logic - Luiz de Sá\, Bernardo Toninho\, Frank Pfenning
DESCRIPTION:We develop Intuitionistic Metric Temporal Logic (IMTL) that extends prior work on intuitionistic temporal logics in two ways: (1) it generalizes discrete time to dense time with intervals so it can\, for example\, express the duration of signals\, and (2) every proof corresponds to a temporal computation. \nOur main technical result is a syntactic proof of cut elimination for IMTL\, which entails logical consistency and ensures that every proof executes while respecting the flow of time. Cut reductions in IMTL correspond to temporal interactions\, although we do not fully develop a programming language in this paper. \nBeyond the metatheory of IMTL\, we illustrate the computational meaning of IMTL proofs by developing examples and a small case study where we apply IMTL to well-timed digital circuit design.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053042Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T153000Z
DTEND:20231023T160000Z
DTSTAMP:20231021T100631Z
UID:0a44fe22-5fb9-4a8d-aec5-295462f47121@conf.researchr.org
CREATED:20230916T200041Z
SUMMARY:[PPDP] stablekanren: Integrating Stable Model Semantics with miniKanren - Xiangyu Guo\, James Smith\, Ajay Bansal
DESCRIPTION:This paper presents stableKanren\, a miniKanren extension with normal logic programming support under stable model semantics. MiniKanren is a relational programming solver implemented atop Scheme via shallow embedding\, which means the predicate in each rule is encoded as a goal function directly. The solver utilizes the pattern-matching macro in Scheme to transform the input goal function and form a static search stream through continuations to achieve the essential features\, resolution and unification\, in Prolog. However\, the static stream only works on monotonic reasoning. Even though the core miniKanren is designed to be easily modified and extended with new features\, none of the existing extensions support solving normal logic programs. Also\, no normal logic program solvers are based on a functional programming language. We identify and categorize the roles of resolution and unification in top-down solving. And we realize that a dynamic search stream is needed to support non-monotonic reasoning. So we evolve both resolution and unification with new roles\, and we exploit the advantages of using macros and continuations further to weave the information generated during runtime into future streams dynamically. We create multiple innovative macros to compile the normal logic program into a program with its complement form\, obtain the domain of a variable under different contexts\, and generate the new search stream during solving. And we use the co-inductive resolution to handle the loop in the normal logic program. In future work\, we plan to apply bottom-up optimization to improve our top-down system performance and support various input rules.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053042Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T160000Z
DTEND:20231023T163000Z
DTSTAMP:20231021T100631Z
UID:f622a4f2-3f57-4a46-9367-655f51c1cc4c@conf.researchr.org
CREATED:20230916T200041Z
SUMMARY:[PPDP] Closing of PPDP
DESCRIPTION:
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053042Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T150000Z
DTEND:20231023T160000Z
DTSTAMP:20231021T100631Z
UID:3ec3ebfb-8abc-465a-86f5-a15bc8ecd0d2@conf.researchr.org
CREATED:20230918T142850Z
SUMMARY:[SAS ] Building Trust and Safety in Artificial Intelligence with Abstract Interpretation - Gagandeep Singh
DESCRIPTION:Real-world adoption of deep neural networks (DNNs) in critical applications requires ensuring strong generalization beyond testing datasets. Unfortunately\, the standard practice of measuring DNN performance on a finite set of test inputs cannot ensure DNN safety on inputs in the wild. In this talk\, I will focus on how abstract interpretation can be leveraged to bridge this gap by building DNNs with strong generalization on an infinite set of unseen inputs. In the process\, I will discuss some of our recent work for building trust and safety in diverse domains such as vision\, systems\, finance\, and more. I will also describe a path toward making static analysis for DNNs more scalable\, easy to develop\, and accessible to DNN developers lacking formal backgrounds.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T113113Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T160000Z
DTEND:20231023T163000Z
DTSTAMP:20231021T100631Z
UID:3a091121-3625-4d93-b1b1-e286e18cff99@conf.researchr.org
CREATED:20230918T151002Z
SUMMARY:[SAS ] Radhia Cousot Award  and PC report - Manuel Hermenegildo\, José Morales
DESCRIPTION:Starting in 2014\, the program committee of each SAS conference selects a paper for the Radhia Cousot Young Researcher Best Paper Award\, in memory of Radhia Cousot\, and her fundamental contributions to static analysis\, as well as being one of the main promoters and organizers of the SAS series of conferences. Recipients of previous editions can be found in the Static Analysis series central pages.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052510Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T150000Z
DTEND:20231023T153000Z
DTSTAMP:20231021T100631Z
UID:613c3483-612e-449c-b502-b3fd93af5947@conf.researchr.org
CREATED:20231003T154525Z
SUMMARY:[SLE] Automated extraction of grammar optimization rule configurations in a metamodel-grammar co-evolution scenario - Weixing Zhang\, Regina Hebig\, Daniel Strüber\, Jan-Philipp Steghöfer
DESCRIPTION:When a language evolves\, meta-models and associated grammars need to be co-evolved to stay mutually consistent. Previous work has supported the automated migration of a grammar after changes of the meta-model to retain manual optimizations of the grammar\, related to syntax aspects such as keywords\, brackets\, and component order. Yet\, doing so required the manual specification of optimization rule configurations\, which was laborious and error-prone. In this work\, to significantly reduce the manual effort during meta-model and grammar co-evolution\, we present an automated approach for extracting optimization rule configurations. The inferred configurations can be used to automatically replay optimizations on later versions of the grammar\, thus leading to a fully automated migration process for the supported types of changes. We evaluated our approach on six real cases. Full automation was possible for three of them\, with agreement rates between ground truth and inferred grammar between 88% and 67% for the remaining ones.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T090300Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T153000Z
DTEND:20231023T160000Z
DTSTAMP:20231021T100631Z
UID:8e411f4f-ab4c-4ba8-9aa6-219808d86471@conf.researchr.org
CREATED:20231003T154525Z
SUMMARY:[SLE] Reuse and Automated Integration of Recommenders for Modelling Languages - Lissette Almonte\, Antonio Garmendia\, Esther Guerra\, Juan de Lara
DESCRIPTION:Many recommenders for modelling tasks have recently appeared. They use a variety of recommendation methods\, tailored to concrete modelling languages. Typically\, recommenders are created as independent programs\, and subsequently need to be integrated within a modelling tool\, incurring in high development effort. Moreover\, it is currently not possible to reuse a recommender created for a modelling language with a different notation\, even if they are similar. \nTo alleviate these problems\, we propose a methodology to reuse recommenders and integrate them into modelling tools. It considers four orthogonal dimensions: the target modelling language\, the modelling tool\, the recommendation source\, and the recommended items. To make the access to arbitrary recommenders homogeneous\, we propose a reference recommendation service that enables indexing recommenders\, investigating their properties\, and obtaining recommendations likely coming from several sources. Our methodology is supported by IronMan\, an Eclipse plugin that automates the integration of recommenders within Sirius and tree-based modelling editors\, and can bridge recommenders created for a modelling language for their reuse with a different one. We evaluate the power of the tool by reusing 2 recommenders for 4 different modelling languages\, and integrating them into 6 existing modelling tools.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052711Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T160000Z
DTEND:20231023T163000Z
DTSTAMP:20231021T100631Z
UID:8be55ae1-4df6-4b58-b526-dcba7d62510f@conf.researchr.org
CREATED:20231003T154525Z
SUMMARY:[SLE] GPT-3-Powered Type Error Debugging: Investigating the Use of Large Language Models for Code Repair - Francisco Ribeiro\, José Nuno Macedo\, Kanae Tsushima\, Rui Abreu\, João Saraiva
DESCRIPTION:Type systems are responsible for assigning types to terms in programs. That way\, they enforce the actions that can be taken and can\, consequently\, detect type errors during compilation. However\, while they are able to flag the existence of an error\, they often fail to pinpoint its cause or provide a helpful error message. Thus\, without adequate support\, debugging this kind of errors can take a considerable amount of effort. Recently\, neural network models have been developed that are able to understand programming languages and perform several downstream tasks. We argue that type error debugging can be enhanced by taking advantage of this deeper understanding of the language’s structure. In this paper\, we present a technique that leverages GPT-3’s capabilities to automatically fix type errors in \textit{OCaml} programs. We perform multiple source code analysis tasks to produce useful prompts that are then provided to GPT-3 to generate potential patches. Our publicly available tool\, \textsc{Mentat}\, supports multiple modes and was validated on an existing public dataset with thousands of \textit{OCaml} programs. We automatically validate successful repairs by using Quickcheck to verify which generated patches produce the same output as the user-inteded fixed version\, achieving a $39%$ repair rate. In a comparative study\, \textsc{Mentat} outperformed two other techniques in automatically fixing ill-typed \textit{OCaml} programs.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052711Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T150000Z
DTEND:20231023T151000Z
DTSTAMP:20231021T100631Z
UID:d79d6f73-05a2-401b-8575-9bf729a0e0d1@conf.researchr.org
CREATED:20230918T150437Z
SUMMARY:[SPLASH PLMW] Wrap-up
DESCRIPTION:
LOCATION:Room III - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072333Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T151000Z
DTEND:20231023T152000Z
DTSTAMP:20231021T100631Z
UID:c39b2c8b-50a5-4aab-8a15-81fcdbaed1f5@conf.researchr.org
CREATED:20230918T150437Z
SUMMARY:[SPLASH PLMW] SIGPLAN-M Introduction - Shraddha Barke
DESCRIPTION:
LOCATION:Room III - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T182150Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T152000Z
DTEND:20231023T163000Z
DTSTAMP:20231021T100631Z
UID:7436e808-815d-4452-84df-137ce4944a4a@conf.researchr.org
CREATED:20230918T150437Z
SUMMARY:[SPLASH PLMW] Mentoring Sessions
DESCRIPTION:
LOCATION:Room III - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072333Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T150000Z
DTEND:20231023T152500Z
DTSTAMP:20231021T100631Z
UID:68b22428-0014-40e4-8023-08507911a300@conf.researchr.org
CREATED:20230918T131024Z
SUMMARY:[VMIL] Collecting Garbage on the Blockchain - Luc Bläser\, Claudio Russo\, Ulan Degenbaev\, Omer S. Agacan\, Gabor Greif\, Jason Ibrahim
DESCRIPTION:We present a garbage collector that is specifically designed for a WebAssembly-based blockchain. Applications on the blockchain implement smart contracts that may have indefinitely long lifetime and may hold substantial monetary value. This imposes a different set of requirements for garbage collection compared to traditional platforms. In this paper\, we explain the differences and show our garbage collector optimizes towards these goals.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053237Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T152500Z
DTEND:20231023T155000Z
DTSTAMP:20231021T100631Z
UID:53411617-aeed-4d18-bda7-8b571f8c5da5@conf.researchr.org
CREATED:20230918T131024Z
SUMMARY:[VMIL] Beehive SPIR-V Toolkit: A Composable and Functional API for Runtime SPIR-V Code Generation - Juan Fumero\, György Rethy\, Athanasios Stratikopoulos\, Nikos Foutris\, Christos Kotselidis
DESCRIPTION:The Standard Portable Intermediate Representation (SPIR-V) is a low-level binary format designed for representing shaders and compute kernels that can be consumed by OpenCL for computing kernels\, and Vulkan for graphics rendering. As a binary representation\, SPIR-V is meant to be used by compilers and runtime systems and is usually performed by C/C++ programs and the LLVM software and compiler ecosystem. However\, not all programming environments\, runtime systems\, and language implementations are C/C++ or based on LLVM. \nThis paper presents the Beehive SPIR-V Toolkit\; a framework that can automatically generate a Java composable and functional library for dynamically building SPIR-V binary modules. The Beehive SPIR-V Toolkit can be used by optimizing compilers and runtime systems to generate and validate SPIR-V binary modules from managed runtime systems. Furthermore\, our framework is architected to accommodate new SPIR-V releases in an easy-to-maintain manner\, and it facilitates the automatic generation of Java libraries for other standards\, besides SPIR-V. The Beehive SPIR-V Toolkit also includes an assembler that emits SPIR-V binary modules from disassembled SPIR-V text files\, and a disassembler that converts the SPIR-V binary code into a text file. To the best of our knowledge\, the Beehive SPIR-V Toolkit is the first Java programming framework that can dynamically generate SPIR-V binary modules. \nTo demonstrate the use of our framework\, we showcase the integration of the SPIR-V Beehive Toolkit in the context of the TornadoVM\, a Java framework for automatically offloading and running Java programs on heterogeneous hardware. We show that\, via the SPIR-V Beehive Toolkit\, the TornadoVM is able to compile code 3x faster than its existing OpenCL C JIT compiler\, and it performs up to 1.52x faster than the existing OpenCL C backend in TornadoVM.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053237Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T155000Z
DTEND:20231023T161500Z
DTSTAMP:20231021T100631Z
UID:18922954-3951-43ed-9526-7ddce8acba82@conf.researchr.org
CREATED:20230918T131024Z
SUMMARY:[VMIL] Gigue: A JIT Code Binary Generator for Hardware Testing - Quentin DUCASSE\, Pascal Cotret\, Loïc Lagadec
DESCRIPTION:Just-in-time compilers are the main virtual machine components responsible for performance. They recompile frequently used source code to machine code directly\, avoiding the slower interpretation path. Hardware acceleration and performant security primitives would benefit the generated JIT code directly and increase the adoption of hardware-enforced primitives in a high-level execution component. \nThe RISC-V instruction set architecture presents extension capabilities to design and integrate custom instructions. It is available as open-source and several capable open-source cores coexist\, usable for prototyping. Testing JIT-compiler-specific instruction extensions would require extending the JIT compiler itself\, other VM components\, the underlying operating system\, and the hardware implementation itself. As the cost of hardware prototyping is already high\, a lightweight representation of the JIT compiler code region in memory would ease prototyping and implementation of new solutions. \nIn this work\, we present Gigue\, a binary generator that outputs OS-independent executable JIT code region snapshots. Its main goal is to speed up hardware extension prototyping by keeping it centered around the JIT compiler use case. It is modular and heavily configurable to qualify different JIT code regions implementations from VMs and different running applications. We show how the generated binaries can be extended with three custom extensions\, which execution is guaranteed by Gigue’s testing framework. We also present different application case generation and execution on top of a fully-featured RISC-V core.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053237Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T161500Z
DTEND:20231023T162500Z
DTSTAMP:20231021T100631Z
UID:d13ad194-774c-460a-8d37-fb7395f1f96b@conf.researchr.org
CREATED:20230918T131343Z
SUMMARY:[VMIL] Closing Remarks - Andrea Rosà
DESCRIPTION:
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053237Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T150000Z
DTEND:20231023T153500Z
DTSTAMP:20231021T100631Z
UID:087a9cf0-86b2-4bc6-ab7f-7b4cb3da0283@conf.researchr.org
CREATED:20231002T132218Z
SUMMARY:[LOPSTR] A Rule-Based Approach for Designing and Composing Abstract Domains - Daniel Jurjo Rivas\, José Morales\, Pedro López-García\, Manuel Hermenegildo
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071834Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T153500Z
DTEND:20231023T161000Z
DTSTAMP:20231021T100631Z
UID:25af354d-5321-4501-9d34-375055f752f2@conf.researchr.org
CREATED:20231002T132218Z
SUMMARY:[LOPSTR] Design Datalog Templates for Synthesizing Bidirectional Programs from Tabular Examples - Bach Nguyen Trong\, Kanae Tsushima\, Zhenjiang Hu
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071834Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T161000Z
DTEND:20231023T162000Z
DTSTAMP:20231021T100631Z
UID:0f24fd40-0199-4457-92c7-911e44d10700@conf.researchr.org
CREATED:20231002T132218Z
SUMMARY:[LOPSTR] Best Paper Awards
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T002222Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T150000Z
DTEND:20231023T153000Z
DTSTAMP:20231021T100631Z
UID:632d2c1d-6beb-4fee-a69f-f13d885abbd6@conf.researchr.org
CREATED:20231018T124150Z
SUMMARY:[LIVE] Unfolding State Changes via Live State-First Debugging - Ruanqianqian (Lisa) Huang\, Philip Guo\, Sorin Lerner
DESCRIPTION:Common debugging techniques are execution-first\, requiring programmers to probe into execution via print logging or breakpoints to inspect intermediate program states. To alleviate the tedium of execution probing\, state-first debugging techniques reveal state changes without requiring logs or statement-level breakpoints. Both techniques\, however\, remain time-consuming and laborious due to the need to manually sift through log or debugger outputs\, and even more so when the process must be repeated many times due to code edits. To overcome these limitations\, we propose live state-first debugging\, a live programming paradigm that directly shows programmers where their program state has changed and how those state changes relate to code\, all without requiring any logging or breakpoints. We implemented this paradigm for web-based GUI applications in Unfold\, which shows a timeline of changed UI states\, the corresponding code that caused those changes\, and automatic replays of prior user interaction traces after the code edits are saved. A preliminary user study (N=12) shows that live state-first debugging helps programmers locate some GUI application bugs faster\, and that programmers deem the paradigm usable and helpful.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T130228Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T153000Z
DTEND:20231023T160000Z
DTSTAMP:20231021T100631Z
UID:de9f0766-29c2-4e61-8484-2717912251f0@conf.researchr.org
CREATED:20231018T124150Z
SUMMARY:[LIVE] Lude - build video games quickly - Mary Rose Cook
DESCRIPTION:Lude aims to let you make a simple video game in five minutes and a more complex game in way less time than it would take in other tools. Lude has three features that help you build games quickly. First\, the game is its own level editor. If there’s something you want to change\, just click or drag an element in the running game to edit it. Second\, changes are hot-loaded\, so you can instantly try out every edit you make because the game stays live and always running. Third\, an LLM helps you define the behavior of the elements of your game.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T130159Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T160000Z
DTEND:20231023T163000Z
DTSTAMP:20231021T100631Z
UID:cb3109ff-0702-4d22-83b3-ebaef9ccd732@conf.researchr.org
CREATED:20231018T125632Z
SUMMARY:[LIVE] LIVE 2023 Closing - Jun Kato\, Peter van Hardenberg
DESCRIPTION:
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T125751Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T150000Z
DTEND:20231023T163000Z
DTSTAMP:20231021T100631Z
UID:97063505-c408-4aa3-a206-f60b1909012d@conf.researchr.org
CREATED:20230913T165421Z
SUMMARY:[ST30 ] Future Directions for Session Types - Stephanie Balzer\, Luís Caires\, Ornela Dardha\, Raymond Hu
DESCRIPTION:A panel session on Future Directions for Session Types
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230913T174216Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T150000Z
DTEND:20231023T153000Z
DTSTAMP:20231021T100631Z
UID:bc26da97-3159-41fd-b7a8-b472cca2c36e@conf.researchr.org
CREATED:20230918T135739Z
SUMMARY:[GPCE] Virtual Domain Specific Languages via Embedded Projectional Editing - Niklas Korz\, Artur Andrzejak
DESCRIPTION:Domain Specific Languages (DSLs) can be implemented as either internal DSL\, i.e. essentially a library in a host general-purpose programming language (GPL)\, or as external DSL which is a stand-alone language unconstrained in its syntax. This choice implies an inherent trade-off between a limited syntactic and representational flexibility (internal DSLs)\, or an involved integration with GPLs and the need for a full stack of tools from a parser to a code generator (external DSLs). \nWe propose a solution which addresses this problem by representing a subset of a GPL - from simple code patterns to complex API calls - as GUI widgets in a hybrid editor. Our approach relies on matching parametrized patterns against the GPL program\, and displaying the matched parts as dynamically rendered widgets. Such widgets can be interpreted as components of an external DSL. Since the source code is serialized as GPL text without annotations\, there is no DSL outside the editor - hence the term ‘virtual’ DSL. \nThis solution has several advantages. The underlying GPL and the virtual DSL can be mixed in a compositional way\, with zero cost of their integration. The project infrastructure does not need to be adapted. Furthermore\, our approach works with mainstream GPLs like Python or JavaScript. \nTo lower the development effort of such virtual DSLs\, we also propose an approach to generate patterns and the corresponding text-only GUI widgets from pairs of examples. \nWe evaluate our approach and its implementation on use cases from several domains. A live demo of the system can be accessed at https://puredit.korz.dev/ and the source code with examples at https://github.com/niklaskorz/puredit/.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230919T121250Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T153000Z
DTEND:20231023T160000Z
DTSTAMP:20231021T100631Z
UID:1edf95bc-2ca4-4b1f-a6c3-8bc28bb97a55@conf.researchr.org
CREATED:20230918T135739Z
SUMMARY:[GPCE] Unleashing the Power of Implicit Feedback in Software Product Lines: Benefits ahead - Raul Medeiros\, Oscar Diaz\, David Benavides
DESCRIPTION:Software Product Lines (SPLs) enable the development of an entire family of software products through systematic reuse. `Reuse’ encompasses not only code but also the transfer of knowledge acquired in one product to others within the SPL. This transfer includes bug fixing\, which\, when encountered in one product\, impacts the entire portfolio of the SPL and enhances the overall code quality. Similarly\, feedback derived from customers’ usage can provide valuable insights that benefit the entire SPL when collected from a single product. \nThis paper explores the potential of incorporating implicit feedback derived from user behavior and interactions into SPLs. Implicit feedback refers to the automated collection of data on software usage or execution\, which allows for the inference of user preferences and trends. While implicit feedback is commonly utilized in single-product development\, its application in SPLs has been overlooked. We argue that feedback needs to be captured at the platform level and then integrated into the code of individual products during product derivation. This approach aligns with the platform-centric nature of SPLs\, where product configurations determine the code rather than direct coding. The paper identifies a set of SPL activities that can benefit the most from implicit feedback. We contrast this hypothesized usefulness with practical evaluations conducted with practitioners using a questionnaire-based assessment (n=8). The results provide positive insights into the advantages and practical implications of adopting a “platform-centric feedback” approach to SPLs and reveal that privacy concerns are a significant consideration for practitioners.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230919T121250Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231023T160000Z
DTEND:20231023T163000Z
DTSTAMP:20231021T100631Z
UID:7aebba05-2103-4bfc-8969-b6eed5d2f086@conf.researchr.org
CREATED:20230919T121250Z
SUMMARY:[GPCE] Automatically Generated Supernodes for AST Interpreters Improve Virtual-machine Performance - Matteo Basso\, Daniele Bonetta\, Walter Binder
DESCRIPTION:Abstract syntax tree (AST) interpreters allow implementing programming languages in a straight-forward way. However\, AST interpreters implemented in object-oriented languages\, such as e.g. in Java\, often suffer from two serious performance issues. First\, these interpreters commonly implement AST nodes by leveraging class inheritance and polymorphism\, leading to many polymorphic call sites in the interpreter implementation and hence lowering interpreter performance. Second\, widely used implementations of these interpreters throw costly runtime exceptions to model the control flow. Even though Just-in-Time (JIT) compilation mitigates these issues\, performance in the first stages of the program execution remains poor. \nIn this paper\, we propose a novel technique to improve both interpreter performance and steady-state performance\, lowering also the pressure on the JIT compiler. Our technique automatically generates AST supernodes ahead-of-time\, i.e.\, we automatically generate compound AST-node classes that encode the behavior of several other primitive AST nodes before the execution of the application. Our technique extracts common control-flow structures from an arbitrary\, given set of ASTs\, such as e.g. the functions of popular packages. It is based on matchmaking of AST structures\, instantiation of matching supernodes\, and replacement the corresponding AST subtrees with the instantiated supernodes at load-time. We implement our technique in the GraalVM JavaScript engine\, showing that our supernodes lead to an average interpreter speedup of $1.24\times$\, an average steady-state speedup of $1.14\times$\, and an average just-in-time compilation speedup of $1.33\times$ on the web-tooling benchmark suite.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230919T121250Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T080000Z
DTEND:20231024T082230Z
DTSTAMP:20231021T100631Z
UID:a2d034b7-7385-4902-a0ee-caa2f9ff19ed@conf.researchr.org
CREATED:20230919T123333Z
SUMMARY:[CONFLANG] Empirical Study of the Docker Smell Impact - Thomas Durieux
DESCRIPTION:Docker is widely adopted for packaging and deploying applications in portable containers. Creating optimal Dockerfiles can be challenging due to varying best practices and deviations known as “Docker smells.” Existing tools for detecting Docker smells suffer from limited recognition and maintenance issues. In this study\, we introduce a new tool\, Parfum\, that automatically detects and repairs Docker smells. We evaluate the effectiveness of Parfum and investigate the impact of Docker smells on image sizes in open-source Dockerfiles. Our results show that Docker smells affect image sizes. On average\, eliminating Docker smells results in a size reduction of 46.38MB per image\, leading to a total reduction of 39.93T in transferred data per week on DockerHub. We also identify packaging manager commands as the most impactful smells. We initiated 34 pull requests\, 24/25 have been merged\, and 9 pull requests waiting for an answer\, indicating developers’ interest in repairing Docker smells.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053103Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T082230Z
DTEND:20231024T084500Z
DTSTAMP:20231021T100631Z
UID:b4e928e0-9487-4c17-aeac-e94bcc8cf48c@conf.researchr.org
CREATED:20230919T123333Z
SUMMARY:[CONFLANG] Measuring Configuration in Code - David Newell
DESCRIPTION:A growing percentage of outages are caused by simple configuration changes as the amount of code controlled by configuration continues to increase. We need to understand the risk of these changes before they are rolled out to a live environment and configuration rarely gets the full suite of testing and reviews that a similar code change would receive. Why should changing a feature flag receive less scrutiny than even a simple code change introducing the conditional that will guard the new feature. \nWhile an individual line of configuration is often simple\, a boolean guarding a new feature or the address of a server\, the code using these values might hide the true complexity. By looking at the intermediate and terminal usages of a configuration value\, we can determine the true significance of what appears to be a small change. \nWe’re used to tracing values using tools that move forward one level at a time through a branching disarray of function calls and reassignments. However\, manually tracing a widely used configuration and understanding everywhere it’s used can be infeasible. When looking at a configuration value and changing its current state\, I want to understand where this will impact the production system. \nInstead\, we can propagate existing code complexity and coverage metrics up the call stack and aggregate them at a configuration level. Hear about our experiences computing test coverage for configuration based on the aggregate coverage where the configuration values are meaningfully used. \nBeyond test coverage\, we can consider what existing and new code metrics are informative when applied to configuration. Number of usages\, complexity at a terminal usage\, distance to terminal usage and other metrics can elucidate the risk of changing an otherwise simple configuration value\, highlight troubling areas in your code base and\, by knowing precisely where a configuration value makes a difference in production code\, can quicken the recovery from an issue caused by the configuration change.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053103Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T084500Z
DTEND:20231024T090730Z
DTSTAMP:20231021T100631Z
UID:65e4f789-75a4-4e55-9b7d-36999ac195e1@conf.researchr.org
CREATED:20230919T123333Z
SUMMARY:[CONFLANG] Yes\, Configuring is Good\, But Have You Ever Tried Justifying? - Sébastien Mosser\, Corinne Pulgar\, Mireille Blay-Fornarino\, Deesha Patel\, Aaron Loh\, Jean-Michel Bruel
DESCRIPTION:This talk proposal describes how justification diagrams can be extended to support the justification of configuration choices in complex systems\, in an operational way.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053103Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T090730Z
DTEND:20231024T093000Z
DTSTAMP:20231021T100631Z
UID:25bc8b6a-5edc-4c5e-8ce8-88106b578c98@conf.researchr.org
CREATED:20230919T143720Z
SUMMARY:[CONFLANG] Configuration analysis Q&A/Discussion
DESCRIPTION:Live Q&amp\;A with the speakers of the session and general discussion around the present and the future of configuration analysis.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053103Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T080000Z
DTEND:20231024T083000Z
DTSTAMP:20231021T100631Z
UID:e65c8063-29d7-44f7-beb6-ceab7c27d57c@conf.researchr.org
CREATED:20230918T143042Z
SUMMARY:[SAS ] ADCL: Acceleration Driven Clause Learning for Constrained Horn Clauses - Florian Frohn\, Jürgen Giesl
DESCRIPTION:Constrained Horn Clauses (CHCs) are often used in automated program verification. Thus\, techniques for (dis-)proving satisfiability of CHCs are a very active field of research. On the other hand\, acceleration techniques for computing formulas that characterize the N-fold closure of loops have successfully been used for static program analysis. We show how to use acceleration to avoid repeated derivations with recursive CHCs in resolution proofs\, which reduces the length of the proofs drastically. This idea gives rise to a novel calculus for (dis)proving satisfiability of CHCs\, called Acceleration Driven Clause Learning (ADCL). We implemented this new calculus in the tool LoAT and evaluate it empirically in comparison to other state-of-the-art tools.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T122122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T083000Z
DTEND:20231024T090000Z
DTSTAMP:20231021T100631Z
UID:d26e0a05-fa44-4437-8c4c-87db3754ca0a@conf.researchr.org
CREATED:20230918T143042Z
SUMMARY:[SAS ] Unconstrained Variable Oracles for Faster Static Analyses - Vincenzo Arceri\, Greta Dolcetti\, Enea Zaffanella
DESCRIPTION:In the context of static analysis based on Abstract Interpretation\, we propose a lightweight pre-analysis step which is meant to suggest\, at each program point\, which program variables are likely to be unconstrained for a specific class of abstract properties. Using the outcome of this pre-analysis as an oracle\, we simplify the statements of the program being analyzed by propagating this lack of information\, aiming at fine-tuning the precision/efficiency trade-off of the analysis. A preliminary experimental evaluation shows that the idea underlying the approach is promising\, as it improves the efficiency of the more costly analysis\, while having a limited effect on its precision.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T122122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T090000Z
DTEND:20231024T093000Z
DTSTAMP:20231021T100631Z
UID:0ed172cf-39cc-4bb8-a141-f4a94475935d@conf.researchr.org
CREATED:20230918T143042Z
SUMMARY:[SAS ] Modular Optimization-Based Roundoff Error Analysis of Floating-Point Programs - Rosa Abbasi Boroujeni\, Eva Darulova
DESCRIPTION:Modular static program analyses improve over global whole-program analyses in terms of scalability at a tradeoff with analysis accuracy. This tradeoff has to-date not been explored in the context of sound floating-point roundoff error analyses\; existing available analyses computing guaranteed absolute error bounds consider only monolithic straight-line code. This paper presents the first modular optimization-based roundoff error analysis for non-recursive procedural floating-point programs. Our analysis achieves modularity and at the same time reasonable accuracy by automatically computing procedure summaries that are a function of the input parameters. Technically\, we extend an existing optimization-based roundoff error analysis and show how to effectively use first-order Taylor approximations to compute precise procedure summaries\, and how to integrate those to obtain end-to-end roundoff error bounds. Our evaluation shows that compared to an inlining of procedure calls\, our modular analysis is significantly faster\, while nonetheless mostly computing relatively tight error bounds.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T122122Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T080000Z
DTEND:20231024T083000Z
DTSTAMP:20231021T100631Z
UID:5543a12c-2206-4048-af8c-38c27a21718f@conf.researchr.org
CREATED:20231003T155707Z
SUMMARY:[SLE] Temporal Breakpoints for Multiverse Debugging - Matthias Pasquier\, Ciprian Teodorov\, Frédéric Jouault\, Matthias Brun\, Luka Le Roux\, Loïc Lagadec
DESCRIPTION:Multiverse debugging extends classical and omniscient debugging to allow the exhaustive exploration of non-deterministic and concurrent systems during debug sessions. The introduction of user-defined reductions significantly improves the scalability of the approach. However\, the literature fails to recognize the importance of using more expressive logics\, besides local-state predicates\, to express breakpoints. In this article\, we address this problem by introducing temporal breakpoints for multiverse debugging. Temporal breakpoints greatly enhance the expressivity of conditional breakpoints\, allowing users to reason about the past and future of computations in the multiverse. Moreover\, we show that it is relatively straightforward to extend a language-agnostic multiverse debugger semantics with temporal breakpoints\, while preserving its generality. To show the elegance and practicability of our approach\, we have implemented a multiverse debugger for the AnimUML modeling environment that supports 3 different temporal breakpoint formalisms: regular-expressions\, statecharts\, and statechart-based Büchi automata.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052715Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T083000Z
DTEND:20231024T090000Z
DTSTAMP:20231021T100631Z
UID:5aebbd0e-db88-452d-a24d-a211331b6789@conf.researchr.org
CREATED:20231003T155707Z
SUMMARY:[SLE] Cross-Level Debugging for Static Analysers - Mats Van Molle\, Bram Vandenbogaerde\, Coen De Roover
DESCRIPTION:Static analyses provide the foundation for several tools that help find problems before executing the program under analysis. Common applications include warning about unused code\, deprecated API calls\, or about potential security vulnerabilities within an IDE. A static analysis distinguishes itself from a dynamic analysis in that it is supposed to terminate even if the program under analysis does not. In many cases it is also desired for the analysis to be sound\, meaning that its answers account for all possible program behavior. Unfortunately\, analysis developers may make mistakes that violate these properties resulting in hard-to-find bugs in the analysis code itself. Finding these bugs can be a difficult task\, especially since analysis developers have to reason about two separate code-bases: the analyzed code and the analysis implementation. The former is usually where the bug manifests itself\, while the latter contains the faulty implementation. A recent survey has found that analysis developers prefer to reason about the analyzed program\, indicating that debugging would be easier if debugging features such as (conditional) breakpoints and stepping were also avail- able in the analyzed program. In this paper\, we therefore propose cross-level debugging for static analysis. This novel technique moves debugging features such as stepping and breakpoints to the base-layer (i.e.\, analyzed program)\, while still making interactions with the meta-layer (i.e.\, analysis implementation) possible. To this end\, we introduce novel conditional breakpoints that express conditions\, which we call meta-predicates\, about the current analysis’ state. We integrated this debugging technique in a framework for implementing modular static analyses called Framework X . Through a detailed case study on 4 real-world bugs taken from the repository of Framework X\, we demonstrate how cross-level debugging helps analysis developers in locating and solving bugs.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052715Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T090000Z
DTEND:20231024T093000Z
DTSTAMP:20231021T100631Z
UID:0146c296-f1f6-46b8-9bf7-a511d78fbee7@conf.researchr.org
CREATED:20231003T155707Z
SUMMARY:[SLE] Cascade: a Meta-Language for Change\, Cause and Effect - Riemer van Rozen
DESCRIPTION:Live programming brings code to life with immediate and continuous feedback. To enjoy its benefits\, programmers need powerful languages and live programming environments for understanding the effects of code modifications on running programs. Unfortunately\, the enabling technology that powers these languages\, is missing. Change\, a crucial enabler for explorative coding\, omniscient debugging and version control\, is a potential solution. \nWe aim to deliver generic solutions for creating these languages\, in particular Domain-Specific Languages (DSLs). We present Cascade\, a meta-language for expressing DSLs with interface- and feedback-mechanisms that drive live programming. We demonstrate run-time migrations\, ripple effects and live desugaring of three existing DSLs. Our results show that an explicit representation of change is instrumental for how these languages are built\, and that cause-and-effect relationships are vital for delivering precise feedback.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052715Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T080000Z
DTEND:20231024T093000Z
DTSTAMP:20231021T100631Z
UID:d1d213b6-6075-4dd7-93b4-0e1620f1c0a5@conf.researchr.org
CREATED:20230914T161105Z
SUMMARY:[PLF] Keynote: Feeling the Local-First Elephant: A Roadmap\, Hidden Gems\, and New Puzzles from the Field - Brooklyn Zelenka
DESCRIPTION:
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053254Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T080000Z
DTEND:20231024T090000Z
DTSTAMP:20231021T100631Z
UID:392c77b3-8f13-4a07-a95d-072cc63d3be9@conf.researchr.org
CREATED:20231002T132838Z
SUMMARY:[LOPSTR] On-The-Fly Verification via Incremental\, Interactive Abstract Interpretation with CiaoPP and VeriFly - Manuel Hermenegildo
DESCRIPTION:While abstract interpretation-based program verification is often performed offline\, it can be very useful when it occurs interactively during software development\, flagging errors as the program is written. However\, while context- and path-sensitive global analysis over complex domains can provide the precision needed for effective verification and optimization\, it can also be expensive when applied to large code bases\, sometimes making interactive use impractical. On the other hand\, in many program development situations modifications are small and isolated within a few components. The modular and incremental fixpoint algorithms used by the Ciao abstract interpretation framework take advantage of this to reuse as much as possible previous analysis results\, reducing response times in interactive use. In this talk we will review these ideas and show how the integration of the Ciao framework within different IDEs takes advantage of these techniques to achieve effective verification on-the-fly\, as the program is developed. We also demonstrate a number of embeddings of this framework within the browser\, and show as an example an application for building interactive tutorials\, which we have used for teaching abstract interpretation and verification.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071838Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T090000Z
DTEND:20231024T093000Z
DTSTAMP:20231021T100631Z
UID:40039e31-72fe-46ad-b137-64508a81d14e@conf.researchr.org
CREATED:20231002T132838Z
SUMMARY:[LOPSTR] A Term Matching Algorithm and Substitution Generality - Marija Kulaš
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071838Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T080000Z
DTEND:20231024T081000Z
DTSTAMP:20231021T100631Z
UID:47e6055f-3365-4fa6-9482-ebacc7dbd1b0@conf.researchr.org
CREATED:20230921T200417Z
SUMMARY:[SPLASH Doctoral Symposium] Introduction and Welcome - Michael Coblenz
DESCRIPTION:
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231006T225849Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T081000Z
DTEND:20231024T091000Z
DTSTAMP:20231021T100631Z
UID:32da97cb-1f54-478b-9214-cb3f9fd17557@conf.researchr.org
CREATED:20230921T200351Z
SUMMARY:[SPLASH Doctoral Symposium] Navigating your thesis and job search: sustainability and standing out [Invited Talk] - Jonathan Aldrich
DESCRIPTION:Jonathan Aldrich is a Professor of Computer Science at Carnegie Mellon University. He teaches courses in programming languages\, software engineering\, and program analysis for quality and security. Prof. Aldrich directed CMU’s Software Engineering Ph.D. program from 2013-2019. \nDr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations and human factors. His research contributions include verifying the correct implementation of an architectural design\, modular formal reasoning about code\, and API protocol specification and verification. His notable awards include an NSF CAREER award (2006)\, the Dahl-Nygaard Junior Prize (2007)\, the DARPA Computer Science Study Group\, and an ICSE most influential paper award (2012). He served as general chair (2015)\, program chair (2017)\, and steering committee chair (2017-2019) of SPLASH and OOPSLA. Aldrich holds a bachelor’s degree in Computer Science from Caltech and a Ph.D. from the University of Washington.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231006T225826Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T091000Z
DTEND:20231024T093000Z
DTSTAMP:20231021T100631Z
UID:b954d2ce-283a-4c5f-af35-8249856d349e@conf.researchr.org
CREATED:20230921T200439Z
SUMMARY:[SPLASH Doctoral Symposium] Elevator Pitches
DESCRIPTION:Each student will present a two-minute talk about their work to get everyone excited about the rest of the day.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231006T225951Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T080000Z
DTEND:20231024T081500Z
DTSTAMP:20231021T100631Z
UID:e686e311-b8aa-494a-a929-612d7ade345f@conf.researchr.org
CREATED:20230915T214234Z
SUMMARY:[IWACO] Welcome to IWACO! - Aleksander Boruch-Gruszecki
DESCRIPTION:
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072736Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T081500Z
DTEND:20231024T093000Z
DTSTAMP:20231021T100631Z
UID:9153c1f4-0384-4e9d-8290-4c6270b7496b@conf.researchr.org
CREATED:20230915T214234Z
SUMMARY:[IWACO] Capture Tracking in Scala - Martin Odersky
DESCRIPTION:
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072736Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T080000Z
DTEND:20231024T083000Z
DTSTAMP:20231021T100631Z
UID:b866a8b5-5153-4a8c-9c73-7cae9ac43714@conf.researchr.org
CREATED:20230915T220755Z
SUMMARY:[DLS] Is Polyglot Programming Really a Thing? - Walter Cazzola
DESCRIPTION:Polyglot programming is the practice of writing an application with multiple languages to capture additional functionality and efficiency not available to a single language. This happens more often than people think. Some reasons are: to support different platforms (e.g.\, Android\, iOS)\, to be more efficient on some parts\, to take advantage of features unique to a different ecosystem (e.g.\, dedicated APIs). But are we ready for polyglot programming? This talk will try to explore the open issues from the point of view of both the multiple programming language integration and from the software engineering development for polyglot programming.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230922T165215Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T083000Z
DTEND:20231024T090000Z
DTSTAMP:20231021T100631Z
UID:e42a1f3f-3c18-445e-82a7-d28511d24a8c@conf.researchr.org
CREATED:20230915T220755Z
SUMMARY:[DLS] The importance of facing outwards: why dynamic languages can and should address the world - Stephen Kell
DESCRIPTION:The directness and immediacy of dynamic languages underlie their enduring promise: as tools for modelling and interacting with the world\, as means of building simple yet resilient systems\, as tools for human thought\, and as a medium that can unlock computers’ potential to work for human beings (rather than vice-versa). \nCurrently\, however\, dynamic languages are ‘popular’ only in the form of thin layers `trapped’ within much larger and and complex commodity software stacks\, much of whose state is beyond the reach of those liberatingly direct modes of expression. A web application may use JavaScript but most of its state is not addressable as a JavaScript objects\; a game may embed Lua but Lua code only reaches what is explicitly gatewayed into it\; and so on. \nI’ll review some open challenges in the implementation of dynamic languages which I believe must be solved if we are to fulfil the promise of dynamic languages as modes of expression widely available to human beings at large. \nThese include “unbundling” garbage collection (where dynamic resource management is not confined to the space managed by a single language runtime)\; federated approaches of object representation (where in extremis an implementation need have no ‘native’ object representation at all)\; enabling interaction with system objects symmetrically with in-memory objects\; reclaiming the visual and direct-manipulation paradigms of interaction alongside the textual\; and protocols for safely combining dynamic code with more “static” code that relies on ahead-of-time reasoning to enforce its invariants (e.g. Rust borrow checking\, to pick a hard example!).
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230922T165215Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T090000Z
DTEND:20231024T093000Z
DTSTAMP:20231021T100631Z
UID:8f5a9022-82b3-4a79-8f3c-170525b01421@conf.researchr.org
CREATED:20230922T165215Z
SUMMARY:[DLS] Going Static\, Gradually: Semantic Soundness and Telling the Truth at Scale - Maxwell Heiber
DESCRIPTION:This talk explores the evolution of gradual typing from the perspective that the best end state for a large codebase is full static types. Hack’s Sound Dynamic is designed to bridge the gap for a large codebase where a “big bang” adoption of static typing is infeasible. Hack evolved from PHP. The Hack type system and tooling are such that “’types don’t lie”: users know which types are (un)trustworthy and have mechanisms for gradually improving type safety of the codebase.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230922T165215Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T100000Z
DTEND:20231024T102230Z
DTSTAMP:20231021T100631Z
UID:579be30c-1d70-45c1-8d4a-5c3644776f27@conf.researchr.org
CREATED:20230919T123322Z
SUMMARY:[CONFLANG] The Configuration Continuum: Using a Unified Model of Configuration to Prevent Outages - Marcel van Lohuizen
DESCRIPTION:The role and scope of configuration often transcends people’s initial perceptions. Virtually every component of your technology stack - from databases\, applications\, schemas\, services\, workflows\, policies\, to models\, and networking - requires or represents some aspect of configuration. Complicating this further\, significant redundancies and interdependencies may exist among these various configuration aspects\, frequently serving as catalysts for system failures. As our systems continue to grow more complex\, it becomes increasingly essential to identify and mitigate such failure-prone redundancies and interdependencies. \nBy examining an example system\, we uncover various types of configurations\, highlighting where redundancies emerge and how these redundancies can bring about issues. We employ CUE to model these configurations\, thereby making such redundancies more apparent. From there\, we explore real-life cases of substantial outages instigated by configuration failures and how the nature of such failures can evolve as a company grows. Notably\, these failures are often preventable through early error detection\, or “shifting left\,” as it is colloquially known. \nWe demonstrate that the distinctions among these various configuration types can often be vague\, appearing more as a continuum than strictly segregated categories. As a consequence\, dismantling these configuration silos may be a requisite to adequately address certain configuration challenges. We illustrate how CUE can be utilized to facilitate this process. \nTo conclude\, we differentiate what we refer to as “configuration engineering” from traditional software engineering\, emphasizing how logical programming can be instrumental in modeling configuration.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053107Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T102230Z
DTEND:20231024T104500Z
DTSTAMP:20231021T100631Z
UID:e8f1010d-cfec-4b27-bb1e-748d19dcf40d@conf.researchr.org
CREATED:20230919T123322Z
SUMMARY:[CONFLANG] Utilizing the LSP to inform and teach users on config languages - Alexander Putman
DESCRIPTION:The GCL configuration language at Google has a complicated 20 year history. The gist is that there are many dialects of the language and most users that are required to use it are confused by it. We determined one way we could meaningfully change how our thousands of users use the language was to provide them with relevant information directly into their editing experience (their IDE). \nIn this talk I go over the Microsoft Language Server Protocol (LSP) and how config languages can utilize it effectively. I use the GCL language and our LSP implementation as an example to show config language specific functionality\, and how it has improved user behavior.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053107Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T104500Z
DTEND:20231024T110730Z
DTSTAMP:20231021T100631Z
UID:126b5973-bc4b-450b-b639-5b98e47ecd7d@conf.researchr.org
CREATED:20230919T123322Z
SUMMARY:[CONFLANG] Evolving a configuration language in place at Google scale - Marcos Lara-Reinhold
DESCRIPTION:GCL\, an internal configuration language used at Google\, was created in 2003\, and after a few years of improvements it got to a point where it was impossible to change it. Its usage had grown too fast and users were depending on nearly all of its documented and undocumented behaviors so any change would break someone’s workflow. \nThe breaking point for inaction was when some user programs became so large\, and required so much memory\, that they couldn’t be run in user workstations. \nMany attempts over the years to replace the language were unsuccessful. No replacement was good enough to warrant the migration costs. Infrastructure teams weren’t able to migrate users automatically\, and their users didn’t have enough incentive to migrate on their own. After a while these efforts were deemed infeasible. \nThis talk tells the story of how we gradually evolved GCL\, while staying mostly backward compatible\, in what has been a huge scale migration effort. \nBased on these constraints and our past successes\, we’re pursuing the approach of evolving the language in place\, one semantic change or feature at a time. We will be simplifying the semantics\, replacing constructs that are error-prone with simpler ones and adding features to make it easier for users to understand their programs. \nWe’ve developed tools to validate the effect of a change to the interpreter on our whole codebase\, mechanisms for gradual rollout\, which combined with the techniques for rolling our large-scale changes across the mono-repo allow our small team to centrally manage the rollout of a semantic change to our whole codebase.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053107Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T110730Z
DTEND:20231024T113000Z
DTSTAMP:20231021T100631Z
UID:3624d923-acdf-46e1-80fd-debf74c30ba0@conf.researchr.org
CREATED:20230919T143747Z
SUMMARY:[CONFLANG] Experience reports Q&A/Discussion
DESCRIPTION:Live Q&amp\;A with the speakers of the session and general discussion around the present and the future of configuration.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053107Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T100000Z
DTEND:20231024T110000Z
DTSTAMP:20231021T100631Z
UID:9de9a051-c9e8-43b3-a05c-84fa2f4fef5c@conf.researchr.org
CREATED:20231017T122220Z
SUMMARY:[SAS ] Verifying Infinitely Many Programs at Once - Loris D'Antoni
DESCRIPTION:In traditional program verification\, the goal is to automati- cally prove whether a program meets a given property. However\, in some cases one might need to prove that a (potentially infinite) set of programs meets a given property. For example\, to establish that no program in a set of possible programs (i.e.\, a search space) is a valid solution to a synthesis problem specification\, e.g.\, a property φ\, one needs to verify that all programs in the search space are incorrect\, e.g.\, satisfy the property ¬φ. The need to verify multiple programs at once also arises in other domains such as reasoning about partially specified code (e.g.\, in the presence of library functions) and self-modifying code. This paper discusses our recent work in designing systems for verifying properties of infinitely many programs at once
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T102150Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T110000Z
DTEND:20231024T113000Z
DTSTAMP:20231021T100631Z
UID:9de0b28a-8dea-4545-8ebb-487468969fe5@conf.researchr.org
CREATED:20231017T122220Z
SUMMARY:[SAS ] Mutual Refinements of Context-Free Language Reachability - Shuo Ding\, Qirun Zhang
DESCRIPTION:Context-free language (CFL) reachability is an important program analysis framework. Due to the hardness of program analysis\, the exact problems can be intractable or even undecidable\, and CFL-reachability only approximates such problems. For the same problem\, there could be many CFL-reachability formulations based on different CFLs\, each of which over-approximates the problem from a different angle. Given multiple such CFLs $C_1\,ldots \,C_n$\, suppose the reachability result of each $C_i$ produces a set $P_i$ of reachable vertex pairs. We can straightforwardly intersect all reachability results $bigcap_{i=1}^n P_i$ to achieve better precision. But is it possible to achieve even better precision? \nThis paper gives an affirmative answer from an interesting perspective: although CFLs are not closed under intersections\, in CFL-reachability we can ``intersect'' the graphs. Specifically\, we propose emph{mutual refinement} to combine different CFL-reachability-based over-approximations. Our key insight is that the standard CFL-reachability algorithm can be slightly modified to trace the edges that contribute to the reachability results of $C_1$\, and $C_2$-reachability only need to consider contributing edges of $C_1$\, which can\, in turn\, trace the edges that contribute to $C_2$-reachability results\, etc. We prove that there exists a unique optimal refinement result (fix-point). Experimental results show that mutual refinement can achieve better precision than the straightforward combination with reasonable extra cost.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T102218Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T100000Z
DTEND:20231024T110000Z
DTSTAMP:20231021T100631Z
UID:716eb34e-8905-4c9b-bc11-65df93ea0311@conf.researchr.org
CREATED:20231003T154852Z
SUMMARY:[SLE] Artificial Languages are Dead. Long Live Artificial Languages! - Crista Lopes
DESCRIPTION:For the past 80 years\, “programming” meant translating a high-level\, semi-formal specification of a desired effect from natural language into computer instructions\, using an artificial language. Mastering these translations requires domain knowledge of algorithms and data structures\, talent\, and years of practice. Large Language Models (LLMs) are disrupting the very notion of “programming.” The disruption is profound\, and at two levels: (1) LLMs are capable of doing those translations automatically\, and (2) many of the desired effects can be obtained without the use of algorithms or data structures. This talk is an exploratory tour through this brave new world\, and its consequences to our field and to CS education.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231021T111529Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T110000Z
DTEND:20231024T112000Z
DTSTAMP:20231021T100631Z
UID:97ecc46a-817a-4cfa-b18a-d599052aaf77@conf.researchr.org
CREATED:20231003T160716Z
SUMMARY:[SLE] Seamless Code Generator Synchronization in the Composition of Heterogeneous Modeling Languages - Nico Jansen\, Bernhard Rumpe
DESCRIPTION:In Software Language Engineering\, the composition of heterogeneous languages has become an increasingly relevant research area in recent years. Despite considerable advances in different composition techniques\, they mainly focus on composing concrete and abstract syntax\, while a thorough yet general concept for synchronizing code generators and their produced artifacts is still missing. Current solutions are either highly generic\, typically increasing the complexity beyond their actual value\, or strictly limited to specific applications. In this paper\, we present a concept for lightweight generator composition\, using the symbol tables of heterogeneous modeling languages to exchange generator-specific accessor and mutator information. The information is attached to the symbols of model elements via templates allowing code generators to communicate access routines at the code level without a further contract. Providing suitable synchronization techniques for code generation is essential to enable language composition in all aspects.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052720Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T100000Z
DTEND:20231024T103000Z
DTSTAMP:20231021T100631Z
UID:13dcd7f5-f848-4ee7-b8a2-33d1943a20bb@conf.researchr.org
CREATED:20230914T161354Z
SUMMARY:[PLF] Collaborative offline-first applications in Education - Annette Bieniusa\, Christopher Thyssen
DESCRIPTION:Schools are an ideal setting for the establishment of local-first software: Firstly\, local-first software empowers students and educators to collaborate\, create\, and access data even in offline or low-connectivity environments\, enhancing learning opportunities. Secondly\, they serve a specific community\, creating a defined and manageable user base\, making it easier to implement and maintain specialised solutions. And finally\, they are receptive to adopting innovative technologies that prioritize privacy\, data ownership\, and security over closed-source corporate solutions. \nThe Teens’ Labbook is a collaborative local-first web application that provides a digital version of the classical laboratory book for documenting experiments in an educational environment. It is designed and developed by the Software Technology Group and the Research Group on Biology Education at the University of Kaiserslautern-Landau\, and the Teens’ Lab team of BASF Ludwigshafen. It provides the functionality to: \n \n Read background material\, experimental descriptions\, and tasks\; \n Document observations by taking notes\, photos\, and measurements\; and \n Collaboratively share these observations and evaluate/discuss the results. \n \nIn addition\, it serves as a research and teaching playground to explore practical aspects of designing and building local-first applications. \nAt the workshop\, we will present the major design decisions in building a reactive local-first application and the lessons-learned so far in developing\, maintaining\, and running the project.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053257Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T103000Z
DTEND:20231024T110000Z
DTSTAMP:20231021T100631Z
UID:7cf3c57b-0195-4a4b-bb94-01c74ca489a1@conf.researchr.org
CREATED:20230914T161354Z
SUMMARY:[PLF] Local-first: experiments & lessons learned building TypeCell - Yousef El-Dardiry
DESCRIPTION:TypeCell is an open source\, local-first knowledge base and document management system (similar to Notion) with Live Programming capabilities and extensibility. Over the last two years\, I’ve worked on several open source projects in the Local-First ecosystem. In this talk\, I’d love to share my learnings building Local-First software by walking you through the experiments I’ve worked on\, architectural challenges\, and opportunities I see ahead. \nOne of the under-appreciated aspects of Local-First architecture is that by design\, you need to abstract the data (syncing) layer from the rest of the application. This abstraction makes it easier to connect the View layer to your data store\, or connect different (pluggable) backends which I’ll further explain below. \nUI Techniques In my applications\, I employ a Reactive programming model. This allows you to create views that instantly react to changes in the underlying data model\, with a minimum amount of code. I will show you how I built SyncedStore to fill in the gap between the Yjs CRDT library and UI libraries that support reactivity in the View layer (MobX+React and Vue in particular). \nExperimental backends Because the Yjs (and Automerge) libraries in essence operate on a stream of updates that are hydrated into an eventually consistent “state” instead of a traditional architecture that works with a “single source of truth”\, there’s the surprising possibility of using infrastructure designed for Chat / messaging systems as the transport and storage of application state. \nIn my experiments\, I’ve released Matrix-CRDT and Nostr-CRDT\, which enable you to use Matrix or Nostr as the backend of a Local-First application. Without writing your own backend\, you can get the benefits of a decentralized architecture\, a users and permissioning system\, and possibly end-to-end encryption out-of-the-box. I’ll share my experience building on top of these networks\, and also the limitations that come with this approach. \nChallenges / opportunities Because of some limitations with these experimental architectures\, in the latest iteration\, I have opted for a backend built on top of Supabase (Postgres). The backend layer is still very agnostic to the data stored compared to traditional backend design. \nI’ll discuss the TypeCell document model and architecture of the new backend\, including how we now handle more complex features such as Cascading Document Permissions\, cross document References\, and search. I’ll also explain why I think there’s an opportunity here for a framework or service that would handle most of this for application authors. \nAbout the author Yousef El-Dardiry is a software engineer with an entrepreneurial background. During his sabbatical after co-founding Relive (outdoor app with 15M+ users)\, he got interested in Local-First software and Rich Text editing. This led him on a long and somewhat bumpy road building TypeCell\; hoping to democratize the way we build software and give more agency to consumers of software in an increasingly digital world. \nBesides the projects mentioned above he made contributions to HocusPocus (a Yjs backend)\, Yjs\, Tiptap\, Prosemirror and is developing an open source Block-Based text editor component (BlockNote). \nLinks: https://twitter.com/yousefed https://syncedstore.org/ https://github.com/yousefed/matrix-CRDT/ https://github.com/YousefED/nostr-crdt
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053257Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T110000Z
DTEND:20231024T113000Z
DTSTAMP:20231021T100631Z
UID:b7421701-c5a6-493a-b116-d801257eeb92@conf.researchr.org
CREATED:20230914T161354Z
SUMMARY:[PLF] Proposal: Versioned Collaborative Documents - Matthew Weidner
DESCRIPTION:We propose a design for \emph{versioned collaborative documents}. Versioned collaborative documents combine Google Docs-style real-time collaboration with git-style fork-merge collaboration. We sketch the architecture of a local-first platform for versioned collaborative documents\, outline the programming model that programmers would use to support new document types on top of the platform\, and discuss the tools required to implement our proposal.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053257Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T100000Z
DTEND:20231024T103500Z
DTSTAMP:20231021T100631Z
UID:15eb8279-ce1c-4422-925c-738bd8c73598@conf.researchr.org
CREATED:20231002T134250Z
SUMMARY:[LOPSTR] Predicate Anti-unification in (Constraint) Logic Programming - Gonzague Yernaux\, Wim Vanhoof
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071843Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T103500Z
DTEND:20231024T111000Z
DTSTAMP:20231021T100631Z
UID:537e5f42-24e0-44f6-abf6-42240649bb5f@conf.researchr.org
CREATED:20231002T134250Z
SUMMARY:[LOPSTR] A Novel EGs-Based Framework for Systematic Propositional-Formula Simplification - Jordina Francès de Mas\, Juliana Bowles
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071843Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T111000Z
DTEND:20231024T113000Z
DTSTAMP:20231021T100631Z
UID:bea2ee07-2360-45a7-9613-06af4f1224f7@conf.researchr.org
CREATED:20231002T134250Z
SUMMARY:[LOPSTR] From Static to Dynamic Access Control Policies via Attribute-Based Category Mining - Anna Bamberger\, Maribel Fernandez
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071843Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T100000Z
DTEND:20231024T103000Z
DTSTAMP:20231021T100631Z
UID:0df3c25f-c198-4ab8-bb37-71ec722f064c@conf.researchr.org
CREATED:20230921T201325Z
SUMMARY:[SPLASH Doctoral Symposium] Large Language Models for Automated Program Repair - Francisco Ribeiro
DESCRIPTION:This paper introduces two methods for automated program repair (APR) utilizing pre-trained language models. The first method demonstrates program repair as a code completion task and is validated on a dataset of Java programs. The second method\, Mentat\, leverages OCaml’s parser and type system as fault localization techniques to generate prompts for GPT-3\, producing candidate patches. Evaluation results show promising repair rates\, with 27% and 39.2% effectiveness\, respectively. For OCaml\, a comparative study employing an automated validation strategy is presented in which the technique outperforms other tools. Language models are effective at APR\, enhancing bug fixing and freeing developers to focus on other critical aspects of software engineering.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230921T201325Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T103000Z
DTEND:20231024T110000Z
DTSTAMP:20231021T100631Z
UID:06e07a2a-d40d-4e86-a58b-dcbbd5a15e03@conf.researchr.org
CREATED:20230921T201325Z
SUMMARY:[SPLASH Doctoral Symposium] Scaling up Program Synthesis to Efficient Algorithms - Ruyi Ji
DESCRIPTION:The automatic synthesis of algorithms can effectively reduce the difficulty of algorithm design. However\, multiple challenges exist for algorithm synthesis. Among them\, scalability is the most prominent one because of the significant complexity of efficient algorithms. We aim at solving this scalability challenge. Specifically\, we propose several approaches from two aspects\, improving the efficiency of existing program synthesizers and reducing the difficulty of algorithm synthesis by properly using algorithmic knowledge\, respectively.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230921T201325Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T110000Z
DTEND:20231024T113000Z
DTSTAMP:20231021T100631Z
UID:ebf54bcd-b124-41be-a6b7-3705d0ce7f7c@conf.researchr.org
CREATED:20230921T201325Z
SUMMARY:[SPLASH Doctoral Symposium] Transforming Ideas into Code: Visual Sketching for ML Development - Luis F. Gomes
DESCRIPTION:We propose a novel code assistant and generation paradigm aimed at closing the gap between visual sketching and code creation for Machine Learning (ML) development. This approach empowers developers and ML practitioners to translate hand-drawn sketches into functional code with enhanced accuracy and usability. Developers are recruited to assess the tool’s performance. This research contributes to the future of low-code approaches\, facilitating ML application development\, and promoting an intuitive and accessible programming environment.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230921T201325Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T100000Z
DTEND:20231024T103000Z
DTSTAMP:20231021T100631Z
UID:ff958495-bded-4a0d-a83b-80ae39b49383@conf.researchr.org
CREATED:20230915T213353Z
SUMMARY:[IWACO] Borrow checking Hylo - Dimi Racordon\, Dave Abrahams
DESCRIPTION:Hylo is a language for high-level systems programming that promises safety without loss of efficiency. It is based on mutable value semantics\, a discipline that emphasizes the independence of values to support local reasoning. The result—in contrast with approaches based on sophisticated aliasing restrictions—is an efficient\, expressive language with a simple type system and no need for lifetime annotations. \nSafety guarantees in Hylo programs are verified by an abstract interpreter processing an intermediate representation\, Hylo IR\, that models lifetime properties with ghost instructions. Further\, lifetime constraints are used to eliminate unnecessary memory allocations predictably.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072714Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T103000Z
DTEND:20231024T110000Z
DTSTAMP:20231021T100631Z
UID:dd4b3178-2821-4eb7-99ca-d8a475e004f0@conf.researchr.org
CREATED:20230915T213353Z
SUMMARY:[IWACO] Degrees of Separation: A Flexible Type System for Data Race Prevention - Yichen Xu\, Aleksander Boruch-Gruszecki\, Martin Odersky
DESCRIPTION:Data race is a notorious problem in parallel programming. There has been great research interest in type systems that statically prevent data races. Despite the progress in the safety and usability of these systems\, lots of existing approaches enforce strict anti-aliasing principles to prevent data races. The adoption of them is often intrusive\, in the sense that it invalidates common programming patterns and requires paradigm shifts. We propose Capture Separation Calculus (System CSC)\, a calculus based on Capture Calculus (System CC&lt\;:box)\, that achieves static data race freedom while being non-intrusive. It allows aliasing in general to permit common programming patterns\, but tracks aliasing and controls them when that is necessary to prevent data races. We study the formal properties of System CSC by establishing its type safety and data race freedom. Notably\, we establish the data race freedom property by proving the confluence of its reduction semantics. To validate the usability of the calculus\, we implement it as an extension to the Scala 3 compiler\, and use it to type-check the examples.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072714Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T110000Z
DTEND:20231024T113000Z
DTSTAMP:20231021T100631Z
UID:ab069968-5b3b-45ec-a873-bdd8850da696@conf.researchr.org
CREATED:20230915T213353Z
SUMMARY:[IWACO] Latte: Lightweight Aliasing Tracking for Java - Conrad Zimmerman\, Catarina Gamboa\, Alcides Fonseca\, Jonathan Aldrich
DESCRIPTION:Many existing systems track aliasing and uniqueness\, each with their own trade-off between expressiveness and developer effort. \nWe propose Latte\, which aims to minimize both the amount of annotations and the complexity of invariants necessary for reasoning about aliasing in an object-oriented language with mutation. Our approach only requires annotations for parameters and fields\, while annotations for local variables are inferred. Furthermore\, it relaxes uniqueness to allow aliasing among local variables\, as long as this aliasing can be precisely determined. This enables support for destructive reads without changes to the language or its run-time semantics. \nDespite this simplicity\, we show how this design can still be used for tracking uniqueness and aliasing in a local sequential setting\, with practical applications\, such as modeling a stack.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072714Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T100000Z
DTEND:20231024T103000Z
DTSTAMP:20231021T100631Z
UID:f378113e-9711-4f0e-9b9b-fc0af950dad5@conf.researchr.org
CREATED:20230915T220847Z
SUMMARY:[DLS] All Languages are Dynamic - James Noble
DESCRIPTION:Virtual Machines\, Dynamic Compilers\, and Implementation Frameworks make dynamic languages easier and more efficient to optimize. Meanwhile\, IDEs\, provers\, dependent types\, type inferencers\, and (so-called) “generative AI” mean programmers can express - statically - more information about the dynamic behavior of their programs. Component libraries in these languages will come with assertions and proofs of their behavior\, and their advocates fantasize about transforming programming into the composition of dependently-typed higher-order yoneda morphisms\, ensuring programs are correct-by-construction (where that construction is carried out by yet more generative AI). \nIn this talk\, I’ll speculate about what the resulting world will be like for programmers. Rather than a static world of platonic mathematical abstractions\, I argue that the opposite will be true: that all languages will be dynamic.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230915T220847Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T103000Z
DTEND:20231024T110000Z
DTSTAMP:20231021T100631Z
UID:6dff6bed-4962-4dc4-96d4-69ce62dc8b43@conf.researchr.org
CREATED:20230915T220847Z
SUMMARY:[DLS] Are we Heading Towards a Dynamic Language Winter? - Maxime Chevalier-Boisvert
DESCRIPTION:Though the 2010s saw many research publications about languages such as JavaScript and Python\, there currently appears to be a general loss of interest in dynamic languages\, with popular new languages such as Rust and Zig being statically typed\, and AOT compilation often being viewed as a preferable option to JIT compilation. There is a legitimate question as to whether we are headed towards\, or already in\, a dynamic language “winter”\, with reduced interest from industry and reduced access to funding for dynamic language research. However\, despite this\, many of the most popular languages (Python\, JS\, Julia\, etc.) are still dynamically typed. In this talk\, we discuss questions such as potential causes for a dynamic language winter\, what makes statically typed languages so attractive at this time\, the major strengths of dynamic languages that could help turn the tide\, and what may come after.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230915T220847Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T110000Z
DTEND:20231024T113000Z
DTSTAMP:20231021T100631Z
UID:1f636e4b-49f4-4d33-b737-221b6ecaa825@conf.researchr.org
CREATED:20230915T220847Z
SUMMARY:[DLS] Prof. Strangelove or: How I Learned to Stop Worrying and Love Dynamic Languages - Jan Vitek
DESCRIPTION:After three decades working on dynamic languages\, with occasional forays in the static desert\, I will share some insights on what worked for me as researcher\, advisor\, and principal investigator.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230915T220847Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T130000Z
DTEND:20231024T132230Z
DTSTAMP:20231021T100631Z
UID:9f2a3b05-c24d-404e-a236-3f2765aceca9@conf.researchr.org
CREATED:20230919T123346Z
SUMMARY:[CONFLANG] The LIFE of CUE - Eloi Perdereau\, Jacques Noyé
DESCRIPTION:In this talk\, we compare CUE and LIFE (actually a subset of these)\, two languages apparently far apart but which share some common roots. \nWe elaborate on the commonalities and differences between building CUE configurations and LIFE psi-terms by relying on basic examples as well as sketches of operational semantics\, considering a subset of CUE including embedded values and duplicate field declarations. Depending on the example\, the mapping between CUE and LIFE can be straightforward or reveal serious discrepancies. \nWe plan to further explore the commonalities and differences of these languages\, in particular with respect to adding constraints to feature structures. It would also be worthwhile to look at some other languages based on typed feature structures to gain a better understanding of the design space. We conjecture that this understanding could lead to a theoretically-simpler configuration language\, possibly extended with computational abilities.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053111Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T132230Z
DTEND:20231024T134500Z
DTSTAMP:20231021T100631Z
UID:96055187-ba58-4b15-8349-9bcab2b1f8d0@conf.researchr.org
CREATED:20230919T123346Z
SUMMARY:[CONFLANG] Ansible Is Turing Complete - Ruben Opdebeeck\, Coen De Roover
DESCRIPTION:Unsurprisingly\, many systems and languages are Turing complete. An interesting subset is that of systems which are Turing complete by accident. A well-known example is that of C++ templates\, which led to the practice of template metaprogramming. A more creative showcase of accidental Turing completeness can be found in Cities: Skylines\, involving the flow of simulated city sewage to construct a 4-bit adder. More recently\, it has been shown that Helm charts\, which abstract over Kubernetes deployments\, are Turing complete due to the inclusion of the go-template language. \nThis led some to suggest that every simple language eventually ends up Turing complete. Although difficult to argue that it is a “simple” language\, Ansible is a popular configuration management language and widely used in practice. At first glance\, Ansible does not appear to offer language features that make it truly Turing complete. While it supports conditional and looping execution\, such loops can only be executed over a finite sequence of elements. Nonetheless\, one can envision various paths to Turing completeness in Ansible. A trivial path would be that of plugins\, which allow developers to extend Ansible functionality through Python code. Thus\, one could “cheat” by leveraging the Turing completeness of Python. Alternatively\, Jinja2\, embedded into Ansible as a templating language\, could well be Turing complete\, similar to the aforementioned embedding of go-template in Helm charts. In this presentation\, rather than relying on the Turing completeness of other languages\, we instead show that we can achieve Turing completeness relying solely on a tiny subset of the core Ansible language. The presentation is structured into three parts\, which are briefly described in the following sections.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053111Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T134500Z
DTEND:20231024T140730Z
DTSTAMP:20231021T100631Z
UID:75a77ed3-0d50-47a4-b742-c7d4e9e32fb6@conf.researchr.org
CREATED:20230919T123346Z
SUMMARY:[CONFLANG] Cached call-by-name: incremental evaluation of configurations - Yann Hamdaoui\, Daniele Palombi
DESCRIPTION:Domain specific languages for configuration are peculiar in many ways. One of those aspects is performance: what is the cost of evaluating a configuration? What configuration languages should or could optimize for? \nA standard route to take from there is the traditional metamorphosis from from naive tree-walking interpreter to an optimizing bytecode compiler and virtual machine. One could add Just-in-Time Compilation (JIT) in the mix. \nIn this talk\, we will explore an alternative route. We start from a simple observation: most changes to an existing configuration codebase are usually small and localized. We will present our attempt at baking incrementality and evaluation caching in the specification of our configuration language itself\, but in a non-intrusive way\, such that the semantics doesn’t depend from the specific caching and evaluation strategy that has been chosen. \nThis is work in progress\, both on the side of semantics and implementation\, which is currently being experimented in the implementation of the Nickel configuration language.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053111Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T140730Z
DTEND:20231024T143000Z
DTSTAMP:20231021T100631Z
UID:33429ae3-ae99-44c4-9722-2a44d84c8d72@conf.researchr.org
CREATED:20230919T143806Z
SUMMARY:[CONFLANG] Configuration languages Q&A/Discussion
DESCRIPTION:Live Q&amp\;A with the speakers of the session and general discussion around the present and the future of configuration languages.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053111Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T130000Z
DTEND:20231024T133000Z
DTSTAMP:20231021T100631Z
UID:d7bd47bb-a4e4-43a5-8da0-e375c2f19601@conf.researchr.org
CREATED:20231003T154611Z
SUMMARY:[SLE] Enabling Blended Modelling of Timing and Variability in EAST-ADL - Muhammad Waseem Anwar\, Federico Ciccozzi\, Alessio Bucaioni
DESCRIPTION:EAST-ADL is a domain-specific modelling language for the design and analysis of vehicular embedded systems. Seamless modelling through multiple concrete syntaxes for the same language\, known as blended modelling\, offers enhanced modelling flexibility to boost collaboration\, lower modelling time\, and maximise the productivity of multiple diverse stakeholders involved in the development of complex systems\, such as those in the automotive domain. Together with our industrial partner\, which is one of the leading contributors to the definition of EAST-ADL and one of its main end-users\, we provided prototypical blended modelling features for EAST-ADL. In this article\, we report on our language engineering work towards the provision of blended modelling for EAST-ADL to support seamless graphical and textual notations. Notably\, for selected portions of the EAST-ADL language (i.e.\, timing and variability packages)\, we introduce ad-hoc textual concrete syntaxes to represent the language’s abstract syntax in alternative textual notations\, preserving the language’s semantics. Furthermore\, we propose a full-fledged runtime synchronisation mechanism\, based on the standard EAXML schema format\, to achieve seamless change propagation across the two notations. As EAXML serves as a central synchronisation point\, the proposed blended modelling approach is workable with most existing EAST-ADL tools. The feasibility of the proposed approach is demonstrated through a car wiper use case from an industrial partner. Results indicate that the proposed blended modelling approach is effective and can be applied to other EAST-ADL packages and supporting tools.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052725Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T133000Z
DTEND:20231024T140000Z
DTSTAMP:20231021T100631Z
UID:95190703-f8e0-414d-b402-59214161db0d@conf.researchr.org
CREATED:20231003T154611Z
SUMMARY:[SLE] Towards Efficient Model Comparison Using Automated Program Rewriting - Qurat Ul Ain Ali\, Dimitris Kolovos\, Konstantinos Barmpis
DESCRIPTION:Model comparison is a prerequisite task used for several other model management tasks such as model merging\, model differencing etc. We present a novel approach to efficiently compare models using programs written in a rule-based model comparison language. As the comparison is done at the model element level\, and each element needs to be traversed and compared with its corresponding elements\, the execution of these comparison algorithms can be computationally expensive for larger models. In this paper\, we present an efficient comparison approach which provides an automated rewriting facility to compare (both homogeneous and heterogeneous) models\, based on static program analysis. Using this analysis\, we reduce the search space by pre-filtering/indexing model elements\, before actually comparing them. Moreover\, we reorder the comparison match rules according to the dependencies between these rules. Our experiments demonstrate that the proposed model comparison approach delivers significant performance benefits in terms of execution time compared to the default ECL execution engine.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052725Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T140000Z
DTEND:20231024T143000Z
DTSTAMP:20231021T100631Z
UID:a86a8ca6-a209-4639-b213-af1fc05a2dac@conf.researchr.org
CREATED:20231003T154611Z
SUMMARY:[SLE] Deriving Integrated Multi-Viewpoint Modeling Languages from Heterogeneous Modeling Languages: An Experience Report - Malte Heithoff\, Nico Jansen\, Jörg Christian Kirchhof\, Judith Michael\, Florian Rademacher\, Bernhard Rumpe
DESCRIPTION:In modern systems engineering\, domain experts increasingly utilize models to define domain-specific viewpoints in a highly interdisciplinary context. Despite considerable advances in developing model composition techniques\, their integration in a largely heterogeneous language landscape still poses a challenge. Until now\, composition in practice mainly focuses on developing foundational language components or applying language composition in smaller scenarios\, while the application to extensive\, heterogeneous languages is still missing. In this paper\, we report on our experiences of composing sophisticated modeling languages using different techniques simultaneously in the context of heterogeneous application areas such as assistive systems and cyber-physical systems in the Internet of Things. We apply state-of-the-art practices\, show their realization\, and discuss which techniques are suitable for particular modeling scenarios. Pushing model composition to the next level by integrating complex\, heterogeneous languages is essential for establishing modeling languages for highly interdisciplinary development teams.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T052725Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T130000Z
DTEND:20231024T133000Z
DTSTAMP:20231021T100631Z
UID:7a30924c-cfca-4426-94d2-d08ff4fa7268@conf.researchr.org
CREATED:20230914T161426Z
SUMMARY:[PLF] Can local-first really scale at the edge? - Carlos Baquero
DESCRIPTION:Local-first software aims to empower the user at the edge. User operations should be accepted locally at the users’ node with negligible latency and only asynchronously propagated to other nodes or the cloud infrastructure when connectivity conditions permit. This considerably impacts overall metadata size for non-trivial data types\, as is the case of counters and causal CRDTs. Here we explore this problem and point to possible solutions.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053302Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T133000Z
DTEND:20231024T140000Z
DTSTAMP:20231021T100631Z
UID:950dfee8-260f-434d-b5fb-123b1bbd3903@conf.researchr.org
CREATED:20230914T161426Z
SUMMARY:[PLF] Local-first at Actyx - Roland Kuhn\, José Duarte
DESCRIPTION:Experience report from rolling out Local-First in factories \nAt Actyx we have been implementing local-first software before the seminal paper from Ink &amp\; Switch came out\, but for different reasons: our hand was forced by needing to minimise dependence on IT infrastructure (which is problematic to grow in factories) and maximising the speed of roll-out — this was our start-up advantage and a key selling point. Going for coordination-free swarm systems with only peer-to-peer communication and distributed data storage and compute satisfied our constraints\, but it came with a new challenge: how to write programs for this environment that actually do what production managers want? \nAfter implementing a few systems by ourself and concurrently developing our corresponding middleware and libraries we turned the latter into a product and started selling that to partner companies — IT providers who wanted to move down to the shop floor and OT (classical automation) providers who wanted to move up from single machine control to shop floor orchestration. We are now collaborating with machine and plant builders who develop their next generation machines and production lines to allow for flexible IT-based process management directly on the shop-floor\, in a local-first fashion. The reasons span all of the above motivations\, including data ownership\, agency\, and minimal infrastructure as well as latency\, bandwidth\, and resilience. \nThe difference in programming model shows foremost in the lack of strong consistency\, but there are other aspects that are less expected and equally impactful\, like the UX problem of managing connectivity expectations or showing which data are available where. This presentation highlights the main such learnings from seven years of Actyx. \nBeyond data — evolving behaviours in swarm systems \nThe Actyx model allows nodes to work in a local-first manner\, to that end\, each node runs their own state machine and merely reacts to incoming events. These events can be compared to RPCs\, they even share similarities! Unfortunately\, one of the shared similarities is the difficulty evolving the data format — how do we add an extra field? Akin to the data format\, behaviours must also evolve\, otherwise\, as goals evolve\, the system risks diverging from said goals (arguably becoming useless). \nWhen discussing P2P systems\, it is unclear how to upgrade the system as a whole as the nature of each peer varies wildly — peers can belong to different people\, have different hardware\, etc. \nEvolving these P2P state machines requires flexibility on two axis — data\, and behavioural — Cambria by Litt et al. targets the data axis\, providing a mechanism which we can use to transform the events between different versions. As for transitions\, it’s clear they belong on the behavioural axis\, what is less clear is how to enable a system to support several versions of transitions. \nThe presentation discusses on-going research into how versioning could be applied to a state machine\, enabling it to handle the evolution of behaviour and data the system must process. \nThe driving idea behind this approach can be summed up as “version everything”. More concretely\, it proposes recognising the state machine for the graph it is\; splitting it into it’s components — state\, events and transitions — and versioning each of them separately\; each version then becomes a new\, separate “path” in the state machine. This approach allows incremental modifications (addition\, modification and deletion) to the state machine as new and old versions of components cohabit the same state machine.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053302Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T140000Z
DTEND:20231024T143000Z
DTSTAMP:20231021T100631Z
UID:3961c664-b365-40a4-a007-c671388725d8@conf.researchr.org
CREATED:20230914T161426Z
SUMMARY:[PLF] Extending Automerge: Undo\, Redo\, and Move - Leo Stewen\, Martin Kleppmann\, Liangrun Da
DESCRIPTION:This entry is a combination – you could say a merge – of two independent submissions: \nUndo and Redo Support for Replicated Registers \nUndo and redo functionality is ubiquitous in collaboration software. In single user settings\, undo and redo are well understood. However\, when multiple users (concurrently) edit a document\, the operation history may become non-linear\, and undo and redo are more complex both in terms of their semantics and implementation. We introduce a distinction between undo/redo and a revert operation that takes inspiration from the behavior of current mainstream collaboration software. \nCRDTs are a tool to allow for concurrent editing of a shared document without requiring central coordination. A simple CRDT is the multi-valued register\, for which we present a novel undo and redo algorithm that implements our identified undo/redo semantics. \nExtending JSON CRDT with Move Operations: An Implementation in Automerge \nConflict-Free Replicated Data Types (CRDTs) for JSON allow users to concurrently update a JSON document without introducing any conflicts and automatically merge the updates into a consistent state. However\, moving elements in a map or reordering elements in a list for a JSON CRDT is considered hard as it is easy to introduce unexpected results such as duplicates or cycles. In this paper\, we implement move operations in Automerge\, a CRDT library\, and evaluate its performance.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053302Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T130000Z
DTEND:20231024T133000Z
DTSTAMP:20231021T100631Z
UID:d3aa639a-c7b5-465b-b10b-da0ddfc224c7@conf.researchr.org
CREATED:20231002T134925Z
SUMMARY:[LOPSTR] Constrained Horn Clauses Satisfiability via Catamorphic Abstractions - Emanuele De Angelis\, Fabio Fioravanti\, Alberto Pettorossi\, Maurizio Proietti
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071848Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T133000Z
DTEND:20231024T135500Z
DTSTAMP:20231021T100631Z
UID:503023ec-a878-4576-8d76-cfd812c8c32b@conf.researchr.org
CREATED:20231002T134925Z
SUMMARY:[LOPSTR] Transforming Big-Step to Small-Step Semantics Using Interpreter Specialisation - John P. Gallagher\, Manuel Hermenegildo\, José Morales\, Pedro López-García
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071848Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T135500Z
DTEND:20231024T140500Z
DTSTAMP:20231021T100631Z
UID:185db829-97f3-4c41-9711-81890c883223@conf.researchr.org
CREATED:20231004T105625Z
SUMMARY:[LOPSTR] Closing and Adjourn
DESCRIPTION:
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071848Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T130000Z
DTEND:20231024T133000Z
DTSTAMP:20231021T100631Z
UID:31dd5f5d-89fc-41b6-a460-32c1b37bf647@conf.researchr.org
CREATED:20230921T201516Z
SUMMARY:[SPLASH Doctoral Symposium] Remote Just-in-Time Compilation for Dynamic Languages - Andrej Pečimúth
DESCRIPTION:Cloud platforms allow applications to meet fluctuating levels of demand through automatic horizontal scaling. These deployment models are characterized by short-lived applications running in resource-constrained environments. This amplifies the overhead of dynamic languages with just-in-time (JIT) compilation. Dynamic-language runtimes suffer from a warmup phase and resource-usage peaks caused by JIT compilation. Offloading compilation jobs to a dedicated server is a possible mitigation for these problems. We propose leveraging remote JIT compilation as a means to enable coordination between the independent instances. By sharing compilation results\, aggregating profiles\, and adapting the compiler and compilation policy\, we strive to improve the peak performance and further reduce the warmup time of these applications. Additionally\, an implementation on top of the Truffle framework enables us to bring these benefits to many popular languages.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230921T201516Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T133000Z
DTEND:20231024T140000Z
DTSTAMP:20231021T100631Z
UID:f253bd8f-64fa-4b0b-8893-717f18c02c9c@conf.researchr.org
CREATED:20230921T201516Z
SUMMARY:[SPLASH Doctoral Symposium] Reusing Single-Language Analyses for Static Analysis of Multi-Language Programs - Tobias Roth
DESCRIPTION:State-of-the-art software is crafted in multiple programming languages. Multi-language software challenges static analyses. Since many static analyses are focused on analyzing single-language programs\, they are inherently unsound or imprecise in analyzing cross-language interaction. Furthermore\, existing approaches that perform multi-language analysis are not analysis or language independent and lack in extensibility for new languages. To fill this gap\, we will develop an extensible\, language\, framework\, and analysis independent architecture to reuse existing static analyses for analyzing multi-language software. Our hypotheses are\, that analyses based on our architecture will be more sound and more precise than state-of-the-art analyses and that our architecture allows to reuse existing analyses to a larger extent than state-of-the-art approaches. We will evaluate our architecture with a points-to and IFDS analysis for Java\, JavaScript and native code and compare it against the state of the art.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230921T201516Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T140000Z
DTEND:20231024T143000Z
DTSTAMP:20231021T100631Z
UID:0b54bb65-827d-4f3c-990a-534be50a4375@conf.researchr.org
CREATED:20230921T201516Z
SUMMARY:[SPLASH Doctoral Symposium] Semantic Versioning for Python Programs - Luís Carvalho
DESCRIPTION:We propose a language-based approach to software versioning. Unlike the traditional approach of mainstream version control systems\, where each evolution step is represented by a textual diff\, we treat versions as programming elements. Each evolution step\, merge operation\, and version relationship\, is represented explicitly in the program. This provides compile time guarantees for safety code reuse from previous versions\, as well as forward and backwards compatibility between versions\, allowing clients to use newly introduced code without needing to refactor their program. By lifting the versioning to the language level\, we pave the way for tools that interact with software repositories to have more insight regarding the evolution of the software semantics.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230921T201516Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T130000Z
DTEND:20231024T133000Z
DTSTAMP:20231021T100631Z
UID:6fa87ba7-40a5-4c8c-bbba-ede83869b886@conf.researchr.org
CREATED:20230915T213421Z
SUMMARY:[IWACO] A Mechanized Theory of the Box Calculus - Joseph Fourment\, Yichen Xu
DESCRIPTION:Capture calculus is an extension of System F_&lt\;: that tracks free variables of terms in their type\, allowing one to represent capabilities while limiting their scope. While previous calculi had mechanized soundness proofs – notably System CF_&lt\;: – the latest version\, namely the box calculus (System CC_&lt\;:□)\, only had a paper proof. We present here our work on mechanizing the theory of the box calculus in Coq\, and the challenges encountered along the way. While doing so\, we motivate the current design of capture calculus\, in particular the concept of boxes\, from both user and metatheoretical standpoints. Our mechanization is complete and available on GitHub.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072719Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T133000Z
DTEND:20231024T140000Z
DTSTAMP:20231021T100631Z
UID:49a8a975-8e4c-411d-b5cd-357e8270b3da@conf.researchr.org
CREATED:20230915T213421Z
SUMMARY:[IWACO] Compositional Reasoning about Advanced Iterator Patterns in Rust - Aurel Bílý\, Jonas Hansen\, Alexander J. Summers\, Peter Müller
DESCRIPTION:Iteration is a control-flow mechanism that consists of repeating statements. Iterators provide an object-oriented abstraction to iteration. Simple iterators confer access to elements of a data structure\, but modern languages such as Rust\, Java\, and C# generalise iteration far beyond this simple use case\, allowing iterators to be parameterised with closures (which can modify their captured state as a side effect) and supporting the composition of iterators to form iterator chains\, where each iterator in the chain consumes values from its predecessor and produces values for its successor. Such generalisations pose four major challenges for modular specification and verification of iterators and the client code using them: (1) How can parameterised iterators be specified modularly and their (accumulated) side effects reasoned about? (2) How can the behaviour of an iterator chain be derived from the specifications of its component iterators? (3) How can proofs about such iterators be automated? (4) How to integrate a concrete methodology into the standard library\, without requiring the client code to change? \nWe present a methodology for the modular specification and verification of advanced iteration idioms with computations affecting captured state as a side effect. It addresses the four challenges above using a combination of inductive two-state invariants\, higher-order closure contracts\, separation logic-like ownership\, and a novel type of out-of-band contracts. We implement our methodology in a state-of-the-art SMT-based Rust verifier. Our evaluation shows that our methodology is sufficiently expressive to handle advanced\, idiomatic iteration patterns and requires modest annotation overhead.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072719Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T140000Z
DTEND:20231024T143000Z
DTSTAMP:20231021T100631Z
UID:8f487369-fad3-41a8-adc0-158eebd20e42@conf.researchr.org
CREATED:20230915T213421Z
SUMMARY:[IWACO] Oxidize: A Step-Debugger for Static Semantics - Peter Chon\, Dimi Racordon\, Nada Amin
DESCRIPTION:Despite its success\, Rust is a difficult language to learn\, in particular because of its borrow checker. Part of the issue is a lack of understanding of the static semantics under which it operates. If we look at dynamic semantics\, we observe that people can get this understanding using step-debugging. Therefore\, we propose a static step-debugger to learn Rust’s static semantics.
LOCATION:Room XIII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T072719Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T130000Z
DTEND:20231024T133000Z
DTSTAMP:20231021T100631Z
UID:5a577b10-e9e4-42bf-9f0c-1cab62f80913@conf.researchr.org
CREATED:20230915T220952Z
SUMMARY:[DLS] JITs are Nice\, but Why Aren’t We Using Them? - Kevin Menard
DESCRIPTION:Dynamic languages have evolved quite a bit over the past few decades. While there’s always room for improvement\, the current generation of languages have rich semantics and expressive syntax\, making for a pleasant developer experience. Developers can clearly represent ideas\, decreasing the maintenance burden while supporting rapid development. Dynamic languages such as Python\, Ruby\, JavaScript\, PHP\, and Lua power a substantial portion of web applications and services today. However\, diminishing returns in terms of single-core performance and memory bandwidth improvements combined with the limited computational resources available in budget-minded cloud computing have highlighted the inefficiencies of language interpreters. \nTo remain relevant in the decades to come\, dynamic language VMs must make a concerted effort to reduce overhead and make effective use of performance features made available by the underlying platform. Dynamic optimization through JIT compilation has proven to be an effective mechanism for improving dynamic language performance\, but building and maintaining a JIT compiler is an expensive undertaking. Meta-compilation promises to reduce those costs\, but incurs other costs that hamper adoption in industry. Through the lens of a company deploying thousands of Ruby projects into production\, we assess the limitations of current VMs\, highlight the most impactful advancements\, and consider what’s most important for the coming decades.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230915T220952Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T133000Z
DTEND:20231024T140000Z
DTSTAMP:20231021T100631Z
UID:a2646421-d335-43c3-96db-e1ea8daa89a4@conf.researchr.org
CREATED:20230915T220952Z
SUMMARY:[DLS] Keeping the asm in Wasm – Running high-level languages on a low-level VM - Andreas Rossberg
DESCRIPTION:WebAssembly (Wasm) is a virtual machine whose defining characteristic is that it is low-level: Wasm is designed to abstract the hardware below\, not language concepts above. This is a prerequisite for providing predictable performance and for avoiding language bias without feature creep. At the same time\, it is a hard requirement that Wasm is safe and portable\, which sometimes necessitates raising its abstraction level above the raw metal. Yet ultimately\, the intention is that language runtimes are largely implemented on top of Wasm\, in Wasm itself. \nDynamic languages pose a challenge for this model\, because achieving acceptable performance for them often requires every dirty trick from the books. Not all of these techniques are easily ported to Wasm with some of its abstractions\, or they incur higher cost because a Wasm engine cannot know or trust invariants in the higher-level runtime and may need to perform redundant checks to maintain its own safety. In particular\, Wasm will need to supply additional mechanisms to efficiently support techniques like jit compilation or inline caches.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230915T220952Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T140000Z
DTEND:20231024T143000Z
DTSTAMP:20231021T100631Z
UID:32120b2f-bdc4-4ff0-8bcd-b4b7a19d6b87@conf.researchr.org
CREATED:20230915T220952Z
SUMMARY:[DLS] Language Runtimes for the New Cloud Era - Rodrigo Bruno
DESCRIPTION:Programming languages offer a number of abstractions such as dynamic typing\, sandboxing\, and automatic garbage collection which\, however\, come at a performance cost. Looking back\, the most influential programming languages were proposed at a time when Moore’s Law was still in place. Nowadays\, post-Moore’s law\, scalability\, and elasticity become crucial requirements\, leading to an increasing tension between programming language design and implementation\, and performance. This talk will discuss the impact of programming languages and language runtimes in the context of scalable and elastic cloud computing platforms with the goal of forecasting their role in the new cloud era.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230915T220952Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T150000Z
DTEND:20231024T152230Z
DTSTAMP:20231021T100631Z
UID:71f154fa-28f0-4129-b68f-b32508e4b16c@conf.researchr.org
CREATED:20230919T123353Z
SUMMARY:[CONFLANG] Applying Large Scale Diffing to Declarative Configuration Code for Production Safety - Faran Jessani\, Vikram Subramanian
DESCRIPTION:At Google\, we’ve noted the following problems with changing config code: \n \n Declarative code can lead to unintended consequences \n Leaky abstractions can reduce readability \n Testing is hard or non-existent \n \nThe solution we’ve arrived at is Configuration diffing. \nHow does it solve those problems? \n \n Doesn’t expose control flow \n Doesn’t require writing tests or any kind of opt in \n Bypasses abstractions and poorly written code \n \nCaveat: Not a silver bullet for preventing outages. \nWhat is Configuration Diffing? \n \n Configuration diffing is a model for verifying the output of our configuration code. \n It consists of \n   \n   Dependency management - what is affected by this change? \n   Execution - how is it affected? \n   Delivery - how do we present it? \n    \n
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053115Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T152230Z
DTEND:20231024T154500Z
DTSTAMP:20231021T100631Z
UID:eda63678-b116-4e25-8e8e-830c84051edb@conf.researchr.org
CREATED:20230919T123353Z
SUMMARY:[CONFLANG] Creed for Speed: Comprehensive Infrastructure as Code Testing - Daniel Sokolowski\, David Spielmann\, Guido Salvaneschi
DESCRIPTION:With Programming Languages Infrastructure as Code (PL-IaC)\, developers implement imperative IaC programs in one of many general-purpose programming languages\, e.g.\, TypeScript\, Python\, or Go\, to declaratively describe deployments. Using these languages provides access to quality assurance techniques and tools developed for traditional software\; however\, programmers routinely rely on prohibitively slow integration testing—if they test at all. As a result\, even simple bugs are found late\, tremendously slowing down the development process. \nTo improve the velocity of PL-IaC development\, we propose ProTI\, an automated unit testing approach that quickly tests PL- IaC programs in many different configurations. ProTI mocks all cloud resources\, replacing them with pluggable oracles that validate all resources’ configurations and a generator for realistic test inputs. We implemented ProTI for Pulumi TypeScript with simple generator and oracle plugins. Our experience of testing with ProTI encourages the exploration of more sophisticated oracles and generators\, leading to the early detection of more bugs. ProTI enables programmers to rapidly prototype\, explore\, and plug in new oracles and generators for efficient PL-IaC program testing.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053115Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T154500Z
DTEND:20231024T160730Z
DTSTAMP:20231021T100631Z
UID:47e7494c-a496-498a-81b0-3b502a300bf7@conf.researchr.org
CREATED:20230919T123353Z
SUMMARY:[CONFLANG] Configuration testing for Borg at Google - Alex Ivanov
DESCRIPTION:Configuration is used to make generic source code more specific and adaptable to various scenarios\, such as different environments and business logic specifics. This helps reduce overall system complexity\, which improves development velocity and system quality. Unfortunately configurations rarely stay small. \nAt Google\, an internal configuration language called “Google Configuration Language - GCL” was developed over the years. A notable use case for this language is configuration of binary deployments on Google’s cluster management service Borg. The dialect of GCL used for this is known internally as Borg Configuration Language or BCL. BCL started as a simple templating engine but quickly grew in complexity to a fully Turing complete engine. \nWith the growth in complexity the configuration is getting harder to understand and reason about. The software engineering industry has in the past successfully used unit testing as one method of dealing with complexity. Providing unit testing for configuration can provide the same benefit to configuration. However\, the nature of configuration languages is a limitation. It is much closer to data than code. This fact makes the most popular approach to test source code\, unit tests\, impractical in most cases. Other approaches should be used which allow users to keep the development velocity but have a reasonable level of safety for configuration. \nIn this talk\, we present a novel tool for unit testing Borg deployment configuration. The tool is used by hundreds of engineers and has been positively received.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053115Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T160730Z
DTEND:20231024T163000Z
DTSTAMP:20231021T100631Z
UID:b92012a7-fd14-4378-a575-44b2a27cf273@conf.researchr.org
CREATED:20230919T143811Z
SUMMARY:[CONFLANG] Configuration testing Q&A/Discussion
DESCRIPTION:Live Q&amp\;A with the speakers of the session and general discussion around the present and the future of configuration testing.
LOCATION:Oceanus - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053115Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T150000Z
DTEND:20231024T152000Z
DTSTAMP:20231021T100631Z
UID:68c0778b-6ae3-4cca-91d1-0a16ecc803f5@conf.researchr.org
CREATED:20231003T160602Z
SUMMARY:[SLE] A Low-Code Platform for Systematic Component-Oriented Language Composition - Jérôme Pfeiffer\, Andreas Wortmann
DESCRIPTION:Low-code platforms have gained popularity for accelerating complex software engineering tasks through visual interfaces and pre-built components. Software language engineering\, specifically language composition\, is such a complex task requiring expertise in composition mechanisms and language workbenches multi-dimensional language constituents (syntax and semantics). This paper presents an extensible low-code platform with a graphical web-based interface for language composition. It enables composition using language components\, facilitating systematic composition within language families promoting reuse and streamlining the management\, composition\, and derivation of domain-specific languages.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T083727Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T152000Z
DTEND:20231024T154000Z
DTSTAMP:20231021T100631Z
UID:5cda2a96-1078-4efc-8d3f-b27f50a867c9@conf.researchr.org
CREATED:20231003T160602Z
SUMMARY:[SLE] A Tool for the Definition and Deployment of Platform-Independent Bots on Open Source Projects - Adem Ait-Fonolla\, Javier Luis Cánovas Izquierdo\, Jordi Cabot
DESCRIPTION:The development of Open Source Software (OSS) projects is a collaborative process that heavily relies on active contributions by passionate developers. Creating\, retaining and nurturing an active community of developers is a challenging task\; and finding the appropriate expertise to drive the development process is not always easy. To alleviate this situation\, many OSS projects try to use bots to automate some development tasks\, thus helping community developers to cope with the daily workload of their projects. However\, the techniques and support for developing bots is specific to the code hosting platform where the project is being developed (e.g.\, GitHub or GitLab). Furthermore\, there is no support for orchestrating bots deployed in different platforms nor for building bots that go beyond pure development activities. In this paper\, we propose a Domain-Specific Language (DSL) to define and deploy bots for OSS projects\, which besides automation tasks they offer a more social facet\, improving community interactions. The language allows defining bots that can be deployed on top of several platforms and that can be triggered by different events (e.g.\, creation of a new issue or a pull request). We describe the design and the implementation of the language\, and illustrate its use with examples.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T091054Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T154000Z
DTEND:20231024T160000Z
DTSTAMP:20231021T100631Z
UID:ae0f5c1f-0196-4cff-b444-95643d12793f@conf.researchr.org
CREATED:20231003T160602Z
SUMMARY:[SLE] Online Name-Based Navigation for Software Meta-languages - Peter D. Mosses
DESCRIPTION:Software language design and implementation often involve specifications written in various esoteric meta-languages. Language workbenches generally include support for precise name-based navigation when browsing language specifications locally\, but such support is lacking when browsing the same specifications online in code repositories. \nThis paper presents a technique to support precise name-based navigation of language specifications in online repositories using ordinary web browsers. The idea is to generate hyperlinked twins: websites where verbatim copies of specification text are enhanced with hyperlinks between name references and declarations. By generating hyperlinks directly from the name binding analysis used internally in a language workbench\, online navigation in hyperlinked twins is automatically consistent with local navigation. \nThe presented technique has been implemented for the Spoofax language workbench\, and used to generate hyperlinked twin websites from various language specifications in Spoofax meta-languages. However\, the applicability of the technique is not limited to Spoofax\, and developers of other language workbenches could presumably implement similar tooling\, to make their language specifications more accessible to those who do not have the workbench installed.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T083741Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T160000Z
DTEND:20231024T162000Z
DTSTAMP:20231021T100631Z
UID:a844f6a6-f32e-4259-ad8c-f064241a2b33@conf.researchr.org
CREATED:20231003T160602Z
SUMMARY:[SLE] Practical Runtime Instrumentation of Software Languages: the Case of SciHook - Dorian Leroy\, Benoît Lelandais\, Marie-Pierre Oudot\, Benoit Combemale
DESCRIPTION:Software languages have pros and cons\, and are usually chosen accordingly. In this context\, it is common to involve different languages in the development of complex systems\, each one specifically tailored for a given concern. However\, these languages create de facto silos\, and offer little support for interoperability with other languages\, be it statically or at runtime. In this paper\, we report on our experiment on extracting a relevant behavioral interface from an existing language\, and using it to enable interoperability at runtime. In particular\, we present a systematic approach to define the behavioral interface and we discuss the expertise required to define it. We illustrate our work on the case study of SciHook\, a C++ library enabling the runtime instrumentation of scientific software in Python. We present how using the proposed approach\, combined with SciHook\, enables interoperability between Python and a domain-specific language dedicated to numerical analysis\, namely NabLab\, and discuss overhead at runtime.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T083750Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T162000Z
DTEND:20231024T163000Z
DTSTAMP:20231021T100631Z
UID:9a2d9792-b6c1-4341-b78d-73715e9aa73b@conf.researchr.org
CREATED:20231017T083714Z
SUMMARY:[SLE] SLE Closing
DESCRIPTION:
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T083757Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T150000Z
DTEND:20231024T152230Z
DTSTAMP:20231021T100631Z
UID:c969a19d-7671-46f9-a373-deca430ff1fa@conf.researchr.org
CREATED:20230914T161509Z
SUMMARY:[PLF] How to Enforce and Verify Invariants in Weakly Consistent Databases - Dina Borrego\, Carla Ferreira\, Nuno Preguica
DESCRIPTION:Weak consistency is fundamental to achieving high availability and low latency in geo-replicated systems\, allowing the execution of operations without coordination. However\, these consistency models may jeopardise the correctness of applications\, leading to broken invariants. To circumvent this problem\, some systems combine strong consistency with weak consistency. \nThis paper presents a study on the maintenance of application invariants in weakly consistent databases. For each class of invariants identified\, we explain how to combine strong and weak consistency to preserve invariants. We also explain how we verified the correctness of some of the proposed mechanisms using a verification language called VeriFx. \nTo encourage the verification of real applications\, we envision a fully automatic verification tool based on the methodology we used for verifying applications in VeriFx.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053307Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T152230Z
DTEND:20231024T154500Z
DTSTAMP:20231021T100631Z
UID:6719e531-5581-4411-9561-d88ad7e7fe8e@conf.researchr.org
CREATED:20230914T161509Z
SUMMARY:[PLF] Local-First in Practice: Learnings of building a high-performance\, local-first music app - Johannes Schickling
DESCRIPTION:Building a local-first app in 2023 still requires a lot of pioneering work on many levels. In this talk I want to share some learnings\, thoughts on tradeoffs and (open) problems we’ve encountered over the past 2 years of building Overtone (a high-performance\, local-first music app). \nTopics include: \n \n Problems and discovered patterns when integrating external data (e.g. 3rd-party API) into a local-first app \n Best practices and challenges when building a high-performance web app (60 FPS+) \n Workflow improvements and DX benefits through embedded app-specific dev tools \n
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053307Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T154500Z
DTEND:20231024T160730Z
DTSTAMP:20231021T100631Z
UID:03e998a8-e8df-41dc-9fb4-42234b8e9aac@conf.researchr.org
CREATED:20230914T161509Z
SUMMARY:[PLF] MVC\, MVCC and Causal Trees - Victor Grishchenko
DESCRIPTION:My proposed talk is based on the experience implementing Swarm.js and swarmdb prototypes\, as well as new experimentation. My focus is on finding techniques to organise a CRDT system’s inner workings. The super-powers of CRDT are known: offline writes\, real-time sync\, collaborative abilities\, extreme throughput. The top expense is the necessity to break some established practices of software development. Hence\, the goal of the work is to realise the superpowers while minimising the breakage.
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053307Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T160730Z
DTEND:20231024T163000Z
DTSTAMP:20231021T100631Z
UID:597e2b11-a014-46c6-ab89-aaac8f94a03f@conf.researchr.org
CREATED:20230914T161509Z
SUMMARY:[PLF] Mixed & Verified Consistency with Propel & ConOpY - Mirko Köhler\, George Zakhour\, Pascal Weisenburger\, Guido Salvaneschi
DESCRIPTION:Safe Combination of Data-centric and Operation-centric Consistency \nDistributed system programming demands the management of consistency in replicated data\, where a trade-off exists between availability and consistency. Strong consistency provides a shared view of the system but incurs performance costs\, while Weak consistency prioritizes availability but relaxes the shared view constraint. In real-world scenarios\, a single level of consistency for the entire application is impractical\, leading to the adoption of mixed consistency. \nWe present ConOpY\, an innovative object-oriented language that supports mixed consistent replication. ConOpY enables developers to reason about mixed consistent programs. Developers can define consistency for entire replicated objects (data-centric) or individual methods (operation-centric) through annotations enforced by the type system. ConOpY’s type system ensures static reasoning about consistency and facilitates interoperability between data-centric and operation-centric approaches within the same application. \nType-Checking CRDTs with Propel \nConflict-free Replicated Data Types (CRDTs) [2\, 3] are modern distributed data types that allow replicating data to different devices in a distributed system and enable local copies to diverge until they are merged with other replicas ensuring eventual consistency. CRDTs play a vital role in building local-first applications [1]\, i.e.\, applications where devices can always progress their local state independently while also enabling seamless collaboration among devices without being blocked by devices that are (temporarily) unreachable on the network. CRDTs enable keeping replicated data consistent while guaranteeing the absence of conflicts among replicas. CRDTs come in two flavors: state-based and operation-based (op-based). For correct operation\, state-based CRDTs rely on a merge function for two states that is commutative\, associative and idempotent\, while operation-based CRDTs rely on an application function for operations on the state that commutes with itself. \nHowever ensuring that such algebraic properties are satisfied by implementations is left to the programmer\, resulting in a process that is complex and error-prone. While techniques based on testing\, automatic verification of models\, and mechanized or handwritten proofs are available\, we lack an approach that is able to verify such properties on concrete CRDT implementations. \nIn this talk the first author will present the first type system that captures the algebraic properties required by a correct CRDT implementation. The type system is designed in Propel [4\, 5]\, it can reason about programs and derive proofs of such properties with complex rules such as case analysis and induction: sum types guide the case analysis and algebraic properties in function types enable induction. Propel’s key feature is its capacity to reason about algebraic properties (a) in terms of rewrite rules and (b) to derive the equality or inequality of expressions from the properties. \nPropel’s language is provided as a Scala embedding\, in which several CRDTs were implemented and verified and compared with four state-of-the-art verification tools. The evaluation showed that Propel is able to automatically deduce the properties that are relevant for common state-based CRDT implementations found in open-source libraries even in cases in which competitors timeout. \nWe are in the process of extending this work also to op-based CRDTs that do not come with a single merge functions which needs to be checked for commutativity and associativity and idempotence\, but instead we need to check the applying the operations on the CRDT commutes. Our initial investigation indicates that Propel’s algebraic reasoning also helps in proving op-based CRDTs convergent\, guaranteeing eventual consistency of local-first applications. \nReferences \n[1] Martin Kleppmann\, Adam Wiggins\, Peter van Hardenberg\, and Mark McGranaghan. 2019. Local-First Software: You Own Your Data\, in Spite of the Cloud. In Proceedings of the 2019 ACM SIGPLAN International Symposium on New Ideas\, New Paradigms\, and Reflections on Programming and Software (Athens\, Greece) (Onward! 2019). Association for Computing Machinery\, New York\, NY\, USA\, 154–178. https://doi.org/10.1145/3359591.3359737 \n[2] Marc Shapiro\, Nuno Preguiça\, Carlos Baquero\, and Marek Zawirski. 2011. A Comprehensive Study of Convergent and Commutative Replicated Data Types. https://hal.inria.fr/inria-00555588 \n[3] Marc Shapiro\, Nuno Preguiça\, Carlos Baquero\, and Marek Zawirski. 2011. Conflict-Free Replicated Data Types. In Stabilization\, Safety\, and Security of Distributed Systems\, Xavier Défago\, Franck Petit\, and Vincent Villain (Eds.). Springer-Verlag\, Berlin/Heidelberg\, Germany\, 386–400. https://doi.org/10.1007/978-3-642-24550-3_29 \n[4] George Zakhour\, Pascal Weisenburger\, and Guido Salvaneschi. 2023. Propel. https://propel-prover.github.io/. Last accessed on 19 Jul 2023. \n[5] George Zakhour\, Pascal Weisenburger\, and Guido Salvaneschi. 2023. Type-Checking CRDT Convergence. Proc. ACM Program. Lang. 7\, PLDI\, Article 162 (jun 2023)\, 24 pages. https://doi.org/10.1145/3591276
LOCATION:Room VI - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T053307Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T150000Z
DTEND:20231024T153000Z
DTSTAMP:20231021T100631Z
UID:d17acd3e-5c92-46be-b8bc-b7b296da8ce5@conf.researchr.org
CREATED:20230921T201528Z
SUMMARY:[SPLASH Doctoral Symposium] A Pragmatic Approach to Syntax Repair - Breandan Considine
DESCRIPTION:Programming languages share a social and formal heritage. These families were historically divided\, but share deep roots\, and we argue their destined matrimony heralds important consequences for language design and generative language modeling. In our work\, we develop a sociotechnical frame- work for understanding the dynamics of programming and argue it captures many of the social and formal properties of language acquisition and evolution.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230921T202531Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T153000Z
DTEND:20231024T163000Z
DTSTAMP:20231021T100631Z
UID:db556982-37b2-4115-b918-7a8b4bd06fb2@conf.researchr.org
CREATED:20230921T202447Z
SUMMARY:[SPLASH Doctoral Symposium] Discussion - Michael Coblenz
DESCRIPTION:Open time for discussion about research\, grad school\, job search\, and anything else of interest.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230921T202536Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T150000Z
DTEND:20231024T153000Z
DTSTAMP:20231021T100631Z
UID:c607db79-5ed7-4fd0-b5f9-795c361fb4c9@conf.researchr.org
CREATED:20230915T221040Z
SUMMARY:[DLS] Programming Languages for AI Programing Agents - Mark Marron
DESCRIPTION:Over the past decade software development has shifted from a process centered around writing code to a process that increasingly involves composition of external packages and managing the integration of code from other team members. The next decade-plus will be defined by the shift from a process where humans are the central developers of code into one where AI agents\, likely Large Language Model (LLM) based\, will be the major creators of code and humans will shift to a supervisory role as curators\, integrating rich framework-functionality and code developed by AI programming agents. \nIn this new world we must ask ourselves – are programming languages as they exist today fit for purpose and how do they evolve to meet the needs of this future programming model. This talk represents an opinionated take on the question and attempts to outline specific areas of investigation that need to be addressed by the PL community as part of this journey including: \n \n What programming language features help/hinder AI agents when understanding and generating code? \n What programming language features help/hinder human agents when working with an AI Copilot? \n What programming language tools are needed to empower AI agents in creating grounded and reliable outputs? \n How can intents be expressed as part of the program representation – examples\, constraints\, natural language\, external documents? \n How do we empower end-users as part of this transformation? \n What programming language features are needed to support new AI driven workflows – live coding\, interactive requirement gathering\, AI TDD? \n \nEffectively answering these questions plays a key role in determining if AI driven programming represents a revolution in how software is developed or is limited to being a programming productivity aid for existing development workflows. As such our community should play a central role in understanding this space and leading in the development of this technological transformation!
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230915T221157Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T153000Z
DTEND:20231024T160000Z
DTSTAMP:20231021T100631Z
UID:ade15e1a-fc70-4959-8cf6-396672b6e900@conf.researchr.org
CREATED:20230915T221040Z
SUMMARY:[DLS] The Bright Future of Debuggers: Challenges and Opportunities - Christophe Scholliers
DESCRIPTION:Since the first bug was discovered in the Mark Harvard II electromechanical computer it was clear that finding bugs and debugging of computer systems would be an extremely challenging task. Today\, various reports indicated that programmers spend approximately 50% procent of their time on debugging related tasks resulting in an annual cost of $312 billion. Given these astronomical amounts of resources being put into debugging\, any technique that improves debugging efficiency is tremendously valuable. \nIn the last decades various new debugging techniques have been put forward to ease debugging and finding the root cause of a failures. Techniques like record-replay\, delta-debugging\, model checking\, tracing\, visualisation\, fuzzing\, automated debugging\, and many more help programmers to be more effective while debugging. Recently\, we have seen that some of techniques are slowly finding their way into mainstream debugging practices. In this talk we first give an overview of recent exiting debugging techniques\, show their advantages and limitations to then reflect on the challenges and opportunities for further research.
LOCATION:Room XV - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20230915T221209Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T163000Z
DTEND:20231024T163834Z
DTSTAMP:20231021T100631Z
UID:70d35cf0-6946-4883-898a-5e0288d4e4b2@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] Extensible Testing for Infrastructure as Code - David Spielmann\, Daniel Sokolowski\, Guido Salvaneschi
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T163834Z
DTEND:20231024T164709Z
DTSTAMP:20231021T100631Z
UID:6a36f77f-9d90-442a-a745-1891bd0bef3d@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] ReactCOP: Modular and Scalable Web Development with Context-Oriented Programming - David H. Lorenz\, Ofir Shmuel
DESCRIPTION:We present a library named ReactCOP that extends React’s capabilities with support for Context-Oriented Programming. The library lets developers manage behavioral variations in React applications through layers\, and adapt the application’s behavior dynamically based on different contexts.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T232002Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T164709Z
DTEND:20231024T165543Z
DTSTAMP:20231021T100631Z
UID:23e00bca-eda6-4d74-8bfd-65febf9dff16@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] Involving Users in Design of a Widely Used Language: A Case of ECMAScript (JavaScript) Standardization - Mikhail Barash\, Yulia Startsev\, Rolf Martin Glomsrud
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T165543Z
DTEND:20231024T170417Z
DTSTAMP:20231021T100631Z
UID:d8e3a19f-7d09-4072-a590-917d3deb715e@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] Kind Inference for the FreeST Programming Language - Bernardo Almeida\, Andreia Mordido\, Vasco T. Vasconcelos
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T170417Z
DTEND:20231024T171251Z
DTSTAMP:20231021T100631Z
UID:c64b9ac2-027e-491b-8098-944d11637a83@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] Collabs implements collaborative data structures (CRDTs) with OOP principles - Matthew Weidner
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T171251Z
DTEND:20231024T172126Z
DTSTAMP:20231021T100631Z
UID:0cb13f4d-5124-4273-8be2-e02edd055104@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] Completeness Thresholds for Memory Safety: Unbounded Guarantees Via Bounded Proofs - Tobias Reinhard\, Justus Fasse\, Bart Jacobs
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T172126Z
DTEND:20231024T173000Z
DTSTAMP:20231021T100631Z
UID:08c5e156-05ca-445b-89b2-b327aa409de3@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] Dynamic Library Compartmentalization - Octave Larose
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T173000Z
DTEND:20231024T173834Z
DTSTAMP:20231021T100631Z
UID:c2638187-1f93-4049-a2fa-13d7df14fa92@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] JaMaBuild: Mass Building of Java Projects - Matúš Sulír\, Milan Nosáľ
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T173834Z
DTEND:20231024T174709Z
DTSTAMP:20231021T100631Z
UID:84b1b362-a17a-40e3-977d-d3b3ba92a980@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] Sui Move: Modern Blockchain Programming with Objects - Adam Welc\, Sam Blackshear
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T174709Z
DTEND:20231024T175543Z
DTSTAMP:20231021T100631Z
UID:f7f88de2-af94-4944-97a5-7d1fa9518e9a@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] Towards Reusable GUI Structures - Knut Anders Stokke\, Mikhail Barash\, Jaakko Järvi
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T175543Z
DTEND:20231024T180417Z
DTSTAMP:20231021T100631Z
UID:b18a3f39-94fa-4dee-b8b8-f82b2f18d188@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] A Functional Reactive Programming Language for Wirelessly Connected Shape-Changeable Chiplet-Based Computers - Yusuke Izawa\, Junichiro Kadomoto\, Hidetsugu Irie\, Shuichi Sakai
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T180417Z
DTEND:20231024T181251Z
DTSTAMP:20231021T100631Z
UID:e1999ace-8583-44f8-b85a-c9cc2dca98e2@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] Generating Domain-Specific Programs for Diagram Authoring with Large Language Models - Rijul Jain\, Wode Ni\, Joshua Sunshine
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T181251Z
DTEND:20231024T182126Z
DTSTAMP:20231021T100631Z
UID:2e8c5f8a-c070-437b-8a44-0c934c32a2db@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] Safe Combination of Data-centric and Operation-centric Consistency - Mirko Köhler\, Guido Salvaneschi
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231024T182126Z
DTEND:20231024T183000Z
DTSTAMP:20231021T100631Z
UID:b3d25bbb-6bca-458f-8cef-c58da21b770c@conf.researchr.org
CREATED:20231017T082104Z
SUMMARY:[SPLASH Posters] Penrose: Beautiful diagrams from plain text - Sam Estep
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082104Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T080000Z
DTEND:20231025T083000Z
DTSTAMP:20231021T100631Z
UID:9ee52b6d-9a20-4403-a6c6-c54ecea90023@conf.researchr.org
CREATED:20231012T130112Z
SUMMARY:[SPLASH OOPSLA] Opening and Welcome
DESCRIPTION:
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T080000Z
DTEND:20231025T093000Z
DTSTAMP:20231021T100631Z
UID:2bee2c0e-0104-49b2-8368-14ed5ba728c1@conf.researchr.org
CREATED:20230922T141258Z
SUMMARY:[SPLASH Onward! Papers] Creating a learnable and inclusive programming language - Felienne Hermans
DESCRIPTION:Software is playing an increasing role in everyone’s lives\, and therefore it is important (and fun!) for kids to become creators in the digital world. However\, existing programming languages are not necessarily designed for learnability\, with cryptic error messages and a lack of easily accessible resources. In this talk\, Felienne will outline what issues existing tools have\, and how these issues disproportionally affect underrepresented minorities in programming including girls\, kids with disabilities and non-English learners. \nShe will then outline her story of inventing and creating Hedy\, an inclusive\, multi-lingual and gradual programming language for learners. Hedy is open source\, runs in the browser\, is free to use\, and available in 47 different languages (Including English\, Spanish\, Chinese\, Arabic and Hindi). Hedy was launched in early 2020 and now serves about 300.000 monthly users (Try it for free at hedy.org)
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T074033Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T083000Z
DTEND:20231025T093000Z
DTSTAMP:20231021T100631Z
UID:657340e2-3266-48fc-9c46-09de26910073@conf.researchr.org
CREATED:20231011T193533Z
SUMMARY:[SPLASH OOPSLA] Scaling up machine learning without tears (and what do programming languages have to do with it) - Dimitrios Vytiniotis
DESCRIPTION:The rapid rise in demand for training large neural networks on thousands of accelerators has put partitioning techniques in the spotlight of ML systems. However\, implementing various forms of partitioning and parallelism often requires substantial programming effort and careful profiling and analysis to achieve high hardware utilization. Making it easier for ML engineers to distribute ML workloads and also to predict/simulate their performance on existing and future accelerator systems is key both for accelerating and productionizing ML research\, as well as for informing the design of future hardware systems. In this talk I will outline some of the challenges we faced and lessons we learnt while working in this space\; and how key concepts of programming languages\, such as convenient domain-specific abstractions and types\, program transformations at various intermediate representation levels\, and abstract interpretation help address some of these challenges. I will also highlight some idiosyncrasies of the domain of ML programs and accelerators that make certain problems more tractable\, but also pose new problems compared to general-purpose languages.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T100000Z
DTEND:20231025T101800Z
DTSTAMP:20231021T100631Z
UID:8c89aebc-0be4-41d8-a118-bb83f6e49097@conf.researchr.org
CREATED:20230912T154405Z
SUMMARY:[SPLASH OOPSLA] Grounded Copilot: How Programmers Interact with Code-Generating Models - Shraddha Barke\, Michael B. James\, Nadia Polikarpova
DESCRIPTION:Powered by recent advances in code-generating models\, AI assistants like Github Copilot promise to change the face of programming forever. But what is this new face of programming? We present the first grounded theory analysis of how programmers interact with Copilot\, based on observing 20 participants—with a range of prior experience using the assistant—as they solve diverse programming tasks across four languages. Our main finding is that interactions with programming assistants are bimodal: in acceleration mode\, the programmer knows what to do next and uses Copilot to get there faster\; in exploration mode\, the programmer is unsure how to proceed and uses Copilot to explore their options. Based on our theory\, we provide recommendations for improving the usability of future AI programming assistants.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T101800Z
DTEND:20231025T103600Z
DTSTAMP:20231021T100631Z
UID:3124e08c-cd54-423c-9052-b9bf0ecb80ea@conf.researchr.org
CREATED:20230912T154405Z
SUMMARY:[SPLASH OOPSLA] Turaco: Complexity-Guided Data Sampling for Training Neural Surrogates of Programs - Alex Renda\, Yi Ding\, Michael Carbin
DESCRIPTION:Programmers and researchers are increasingly developing surrogates of programs\, models of a subset of the observable behavior of a given program\, to solve a variety of software development challenges. Programmers train surrogates from measurements of the behavior of a program on a dataset of input examples. A key challenge of surrogate construction is determining what training data to use to train a surrogate of a given program. \nWe present a methodology for sampling datasets to train neural-network-based surrogates of programs. We first characterize the proportion of data to sample from each region of a program's input space (corresponding to different execution paths of the program) based on the complexity of learning a surrogate of the corresponding execution path. We next provide a program analysis to determine the complexity of different paths in a program. We evaluate these results on a range of real-world programs\, demonstrating that complexity-guided sampling results in empirical improvements in accuracy.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T103600Z
DTEND:20231025T105400Z
DTSTAMP:20231021T100631Z
UID:e1e736fc-ebce-4511-bc63-1f5cf435d991@conf.researchr.org
CREATED:20230912T154405Z
SUMMARY:[SPLASH OOPSLA] Concrete Type Inference for Code Optimization using Machine Learning with SMT Solving - Fangke Ye\, Jisheng Zhao\, Jun Shirako\, Vivek Sarkar
DESCRIPTION:Despite the widespread popularity of dynamically typed languages such as Python\, it is well known that they pose significant challenges to code optimization due to the lack of concrete type information. To overcome this limitation\, many ahead-of-time optimizing compiler approaches for Python rely on programmers to provide optional type information as a prerequisite for extensive code optimization. Since few programmers provide this information\, a large majority of Python applications are executed without the benefit of code optimization\, thereby contributing collectively to a significant worldwide wastage of compute and energy resources. \nIn this paper\, we introduce a new approach to concrete type inference that is shown to be effective in enabling code optimization for dynamically typed languages\, without requiring the programmer to provide any type information. We explore three kinds of type inference algorithms in our approach based on: 1) machine learning models including GPT-4\, 2) constraint-based inference based on SMT solving\, and 3) a combination of 1) and 2). Our approach then uses the output from type inference to generate multi-version code for a bounded number of concrete type options\, while also including a catch-all untyped version for the case when no match is found. The typed versions are then amenable to code optimization. Experimental results show that the combined algorithm in 3) delivers far superior precision and performance than the separate algorithms for 1) and 2). The performance improvement due to type inference\, in terms of geometric mean speedup across all benchmarks compared to standard Python\, when using 3) is $26.4\times$ with Numba as an AOT optimizing back-end and $62.2\times$ with the Intrepydd optimizing compiler as a back-end. These vast performance improvements can have a significant impact on programmers' productivity\, while also reducing their applications' use of compute and energy resources.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T105400Z
DTEND:20231025T111200Z
DTSTAMP:20231021T100631Z
UID:deb62bf7-3b5e-402c-977b-1e09882631aa@conf.researchr.org
CREATED:20230915T151735Z
SUMMARY:[SPLASH OOPSLA] An Explanation Method for Models of Code - Yu Wang\, Ke Wang\, Linzhang Wang
DESCRIPTION:This paper introduces a novel method\, called WheaCha\, for explaining the predictions of code models. Similar to attribution methods\, WheaCha seeks to identify input features that are responsible for a particular prediction that models make. On the other hand\, it differs from attribution methods in crucial ways. Specifically\, WheaCha separates an input program into "wheat" (i.e.\, defining features that are the reason for which models predict the label that they predict) and the rest "chaff" for any given prediction. We realize WheaCha in a tool\, HuoYan\, and use it to explain four prominent code models: code2vec\, seq-GNN\, GGNN\, and CodeBERT. Results show that (1) HuoYan is efficient — taking on average under twenty seconds to compute wheat for an input program in an end-to-end fashion (i.e.\, including model prediction time)\; (2) the wheat that all models use to make predictions is predominantly comprised of simple syntactic or even lexical properties (i.e.\, identifier names)\; (3) neither the latest explainability methods for code models (i.e.\, SIVAND and CounterFactual Explanations) nor the most noteworthy attribution methods (i.e.\, Integrated Gradients and SHAP) can precisely capture wheat. Finally\, we set out to demonstrate the usefulness of WheaCha\, in particular\, we assess if WheaCha’s explanations can help end users to identify defective code models (e.g.\, trained on mislabeled data or learned spurious correlations from biased data). We find that\, with WheaCha\, users achieve far higher accuracy in identifying faulty models than SIVAND\, CounterFactual Explanations\, Integrated Gradients and SHAP.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T111200Z
DTEND:20231025T113000Z
DTSTAMP:20231021T100631Z
UID:5cfd80fd-41ad-4cc3-a501-49dd90faf615@conf.researchr.org
CREATED:20231008T172009Z
SUMMARY:[SPLASH OOPSLA] Optimization-Aware Compiler-Level Event Profiling - Matteo Basso\, Aleksandar Prokopec\, Andrea Rosà\, Walter Binder
DESCRIPTION:Tracking specific events in a program’s execution\, such as object allocation or lock acquisition\, is at the heart of dynamic analysis. Despite the apparent simplicity of this task\, quantifying these events is challenging due to the presence of compiler optimizations. Profiling perturbs the optimizations that the compiler would normally do—a profiled program usually behaves differently than the original one. \nIn this article\, we propose a novel technique for quantifying compiler-internal events in the optimized code\, reducing the profiling perturbation on compiler optimizations. Our technique achieves this by instrumenting the program from within the compiler\, and by delaying the instrumentation until the point in the compilation pipeline after which no subsequent optimizations can remove the events. We propose two different implementation strategies of our technique based on path-profiling\, and a modification to the standard path-profiling algorithm that facilitates the use of the proposed strategies in a modern just-in-time (JIT) compiler. We use our technique to analyze the behaviour of the optimizations in Graal\, a state-of-the-art compiler for the Java Virtual Machine\, identifying the reasons behind a performance improvement of a specific optimization\, and the causes behind an unexpected slowdown of another. Finally\, our evaluation results show that the two proposed implementations result in a significantly lower execution-time overhead w.r.t. a naive implementation.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T100000Z
DTEND:20231025T101800Z
DTSTAMP:20231021T100631Z
UID:2a0a5dc3-be12-433f-b8fa-bf806d0a327a@conf.researchr.org
CREATED:20230912T182934Z
SUMMARY:[SPLASH OOPSLA] Asparagus: Automated Synthesis of Parametric Gas Upper-Bounds for Smart Contracts - Zhuo Cai\, Soroush Farokhnia\, Amir Kafshdar Goharshady\, S. Hitarth
DESCRIPTION:Modern programmable blockchains have built-in support for smart contracts\, i.e.~programs that are stored on the blockchain and whose state is subject to consensus. After a smart contract is deployed on the blockchain\, anyone on the network can interact with it and call its functions by creating transactions. The blockchain protocol is then used to reach a consensus about the order of the transactions and\, as a direct corollary\, the state of every smart contract. Reaching such consensus necessarily requires every node on the network to execute all function calls. Thus\, an attacker can perform DoS by creating expensive transactions and function calls that use considerable or even possibly infinite time and space. To avoid this\, following Ethereum\, virtually all programmable blockchains have introduced the concept of ``gas''. A fixed hard-coded gas cost is assigned to every atomic operation and the user who calls a function has to pay for its total gas usage. This technique ensures that the protocol is not vulnerable to DoS attacks\, but it has also had significant unintended consequences. Out-of-gas errors\, i.e.~when a user misunderestimates the gas usage of their function call and does not allocate enough gas\, are a major source of security vulnerabilities in Ethereum. \nWe focus on the well-studied problem of automatically finding upper-bounds on the gas usage of a smart contract. This is a classical problem in the blockchain community and has also been extensively studied by researchers in programming languages and verification. In this work\, we provide a novel approach using theorems from polyhedral geometry and real algebraic geometry\, namely Farkas' Lemma\, Handelman's Theorem\, and Putinar's Positivstellensatz\, to automatically synthesize linear and polynomial parametric bounds for the gas usage of smart contracts. Our approach is the first to provide completeness guarantees for the synthesis of such parametric upper-bounds. Moreover\, our theoretical results are independent of the underlying consensus protocol and can be applied to smart contracts written in any language and run on any blockchain. \nAs a proof of concept\, we also provide a tool\, called ``Asparagus'' that implements our algorithms for Ethereum contracts written in Solidity. Finally\, we provide extensive experimental results over 24\,188 real-world smart contracts that are currently deployed on the Ethereum blockchain. We compare Asparagus against GASTAP\, which is the only previous tool that could provide parametric bounds\, and show that our method significantly outperforms it\, both in terms of applicability and the tightness of the resulting bounds. More specifically\, our approach can handle 80.56% of the functions (126\,269 out of 156\,735) in comparison with GASTAP's 58.62%. Additionally\, even on the benchmarks where both approaches successfully synthesize a bound\, our bound is tighter in 97.85% of the cases.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T101800Z
DTEND:20231025T103600Z
DTSTAMP:20231021T100631Z
UID:1fdc98f5-cbd0-489c-ac5d-451ffaf95c6f@conf.researchr.org
CREATED:20230912T182934Z
SUMMARY:[SPLASH OOPSLA] Equality Saturation Theory Exploration à la Carte - Anjali Pal\, Brett Saiki\, Ryan Tjoa\, Cynthia Richey\, Amy Zhu\, Oliver Flatt\, Max Willsey\, Zachary Tatlock\, Chandrakana Nandi
DESCRIPTION:Rewrite rules are critical in equality saturation\, an increasingly popular technique in optimizing compilers\, synthesizers\, and verifiers. Unfortunately\, developing high-quality rulesets is difficult and error-prone. Recent work on automatically inferring rewrite rules does not scale to large terms or grammars\, and existing rule inference tools are monolithic and opaque. Equality saturation users therefore struggle to guide inference and incrementally construct rulesets. As a result\, most users still manually develop and maintain rulesets. \nThis paper proposes Enumo\, a new domain-specific language for programmable theory exploration. Enumo provides a small set of core operators that enable users to strategically guide rule inference and incrementally build rulesets. Short Enumo programs easily replicate results from state-of-the-art tools\, but Enumo programs can also scale to infer deeper rules from larger grammars than prior approaches. Its composable operators even facilitate developing new strategies for ruleset inference. We introduce a new fast-forwarding strategy that does not require evaluating terms in the target language\, and can thus support domains that were out of scope for prior work. \nWe evaluate Enumo and fast-forwarding across a variety of domains. Compared to state-of-the-art techniques\, enumo can synthesize better rulesets over a diverse set of domains\, in some cases matching the effects of manually-developed rulesets in systems driven by equality saturation.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T103600Z
DTEND:20231025T105400Z
DTSTAMP:20231021T100631Z
UID:96f6d613-5ac9-43f2-88d9-1cfae51d9bbc@conf.researchr.org
CREATED:20230912T182934Z
SUMMARY:[SPLASH OOPSLA] Synthesizing Specifications - Kanghee Park\, Loris D'Antoni\, Thomas Reps
DESCRIPTION:Every program should be accompanied by a specification that describes important aspects of the code's behavior\, but writing good specifications is often harder than writing the code itself. This paper addresses the problem of synthesizing specifications automatically\, guided by user-supplied inputs of two kinds: i) a query posed about a set of function definitions\, and ii) a domain-specific language L in which the extracted property is to be expressed (we call properties in the language L-properties). Each of the property is a best L-property for the query: there is no other L-property that is strictly more precise. Furthermore\, the set of synthesized L-properties is exhaustive: no more L-properties can be added to it to make the conjunction more precise. We implemented our method in a tool\, Spyro. The ability to modify both the query and L provides a Spyro user with ways to customize the kind of specification to be synthesized. We use this ability to show that Spyro can be used in a variety of applications\, such as mining program specifications\, performing abstract-domain operations\, and synthesizing algebraic properties of program modules.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T105400Z
DTEND:20231025T111200Z
DTSTAMP:20231021T100631Z
UID:be5f8816-bc9e-4544-bbef-24038893a17f@conf.researchr.org
CREATED:20230912T182934Z
SUMMARY:[SPLASH OOPSLA] Explainable Program Synthesis by Localizing Specifications - Amirmohammad Nazari\, Yifei Huang\, Roopsha Samanta\, Arjun Radhakrishna\, Mukund Raghothaman
DESCRIPTION:The traditional formulation of the program synthesis problem is to find a program that meets a logical correctness specification. When synthesis is successful\, there is a guarantee that the implementation satisfies the specification. Unfortunately\, synthesis engines are typically monolithic algorithms\, and obscure the correspondence between the specification\, implementation and user intent. In contrast\, humans often include comments in their code to guide future developers towards the purpose and design of different parts of the codebase. In this paper\, we introduce \emph{subspecifications} as a mechanism to augment the synthesized implementation with explanatory notes of this form. In this model\, the user may ask for explanations of different parts of the implementation\; the subspecification generated in response is a logical formula that describes the constraints induced on that subexpression by the global specification and surrounding implementation. We develop algorithms to construct and verify subspecifications and investigate their theoretical properties. We perform an experimental evaluation of the subspecification generation procedure\, and measure its effectiveness and running time. Finally\, we conduct a user study to determine whether subspecifications are useful: we find that subspecifications greatly aid in understanding the global specification\, in identifying alternative implementations\, and in debugging faulty implementations.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T111200Z
DTEND:20231025T113000Z
DTSTAMP:20231021T100631Z
UID:b4d7f43e-e754-4599-afb8-998c14596e34@conf.researchr.org
CREATED:20230915T183830Z
SUMMARY:[SPLASH OOPSLA] Pushing the Limit of 1-Minimality of Language-Agnostic Program Reduction - Zhenyang Xu\, Yongqiang Tian\, Mengxiao Zhang\, Gaosen Zhao\, Yu Jiang\, Chengnian Sun
DESCRIPTION:Program reduction has demonstrated its usefulness in facilitating debugging language implementations in practice\, by minimizing bug-triggering programs. There are two categories of program reducers: language-agnostic program reducers (AGRs) and language-specific program reducers (SPRs). AGRs\, such as HDD and Perses\, are generally applicable to various languages\; SPRs are specifically designed for one language with meticulous thoughts and significant engineering efforts\, e.g.\, C-Reduce for reducing C/C++ programs. \nProgram reduction is an NP-complete problem: finding the globally minimal program is usually infeasible. Thus all existing program reducers resort to producing 1-minimal results\, a special type of local minima. However\, 1-minimality can still be large and contain excessive bug-irrelevant program elements. This is especially the case for AGR-produced results because of the generic reduction algorithms used in AGRs. An SPR often yields smaller results than AGRs for the language for which the SPR has customized reduction algorithms. But SPRs are not language-agnostic\, and implementing a new SPR for a different language requires significant engineering efforts. \nThis paper proposes Vulcan\, a language-agnostic framework to further minimize AGRs-produced results by exploiting the formal syntax of the language to perform aggressive program transformations\, in hope of creating reduction opportunities for other reduction algorithms to progress or even directly deleting bugirrelevant elements from the results. Our key insights are two-fold. First\, the program transformations in all existing program reducers including SPRs are not diverse enough\, which traps these program reducers early in 1-minimality. Second\, compared with the original program\, the results of AGRs are much smaller\, and time-wise it is affordable to perform diverse program transformations that change programs but do not necessarily reduce the sizes of the programs directly. Within the Vulcan framework\, we proposed three simple examples of fine-grained program transformations to demonstrate that Vulcan can indeed further push the 1-minimality of AGRs. By performing these program transformations\, a 1-minimal program might become a non-1-minimal one that can be further reduced later. \nOur extensive evaluations on multilingual benchmarks including C\, Rust and SMT-LIBv2 programs strongly demonstrate the effectiveness and generality of Vulcan. Vulcan outperforms the state-of-the-art language-agnostic program reducer Perses in size in all benchmarks: On average\, the result of Vulcan contains 33.55%\, 21.61%\, and 31.34% fewer tokens than that of Perses on C\, Rust\, and SMT-LIBv2 subjects respectively. Vulcan can produce even smaller results if more reduction time is allocated. Moreover\, for the C programs that are reduced by C-Reduce\, Vulcan is even able to further minimize them by 10.07%.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T100000Z
DTEND:20231025T103000Z
DTSTAMP:20231021T100631Z
UID:e06b0672-629e-44a8-bd6d-d4699a92f1f9@conf.researchr.org
CREATED:20230907T154434Z
SUMMARY:[SPLASH Onward! Papers] Time-awareness in Object-exploration Tools: Toward In Situ Omniscient Debugging - Christoph Thiede\, Marcel Taeumel\, Robert Hirschfeld
DESCRIPTION:Exploration of state and behavior is essential for understanding and debugging object-oriented programs. Many time-related questions about object communication – an object’s history – only arise in the context of a specific error in the here and now. At such a specific point in time\, however\, it is often distracting to involve omniscient debugging tools such as program tracers\, because they do not integrate well with the programmer’s current focus on space-related questions and the informational cues at hand. In this paper\, we present a novel way to provide a tangible\, consolidated notion of both space and time in object exploration tools to make it more likely that programmers will use the available means to explore the evolution of particular objects. With programmers remaining informed about and in control of a program’s space and time\, we promote the scientific method for debugging and leverage exploratory programming practices. We evaluate our model with hands-on experiences in the Squeak/Smalltalk programming system\, using a program tracer that we have integrated into existing exploration tools to promote both spatial and temporal views. We believe that a clear\, tangible notion of spacetime can help tool designers provide a better programming experience for those constantly recurring “What happened to this object?” situations.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T133636Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T103000Z
DTEND:20231025T110000Z
DTSTAMP:20231021T100631Z
UID:9eb8bd93-90b4-4f54-9689-36922c45f0d7@conf.researchr.org
CREATED:20230907T154434Z
SUMMARY:[SPLASH Onward! Papers] Code Merging Using Transformations and Member Identity - André R. Teles\, André L. Santos
DESCRIPTION:Conventionally\, merging code files is performed using generic line-based merging algorithms (e.g.\, diff3) that are unaware of the syntax and semantics of the programming language\, outputting conflicts that could be avoided. Structured and semistructured merging techniques are capable of reducing conflicts\, but they still suffer from false positives (conflicts that could be avoided) and false negatives (conflicts that go undetected). We propose a merging technique that combines semistructured and transformation-based strategies\, where conflict detection is aware of semantic aspects of the programming language. We extract transformations of two branches and apply a merging process that analyzes incompatible transformations\, avoiding false positives and false negatives that occur in existing approaches. We developed Jaid\, a prototype merging tool for Java based on the assumption that structural code elements evolve with attached UUIDs (representing identity). We performed an early experiment with 63 merge scenarios from two open-source projects to test the technique and assess its feasibility.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T074039Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T110000Z
DTEND:20231025T113000Z
DTSTAMP:20231021T100631Z
UID:e1382917-bf67-421b-b16f-33cd1ba6ac30@conf.researchr.org
CREATED:20230907T154434Z
SUMMARY:[SPLASH Onward! Papers] Scalable Spreadsheet-driven End-User Applications with Incremental Computation - Sean Hadar\, Shachar Itzhaky
DESCRIPTION:Spreadsheets are a popular programming model among both novice and advanced users. It allows for quick development of computational tasks over the user’s data set. It has also been suggested as a model for lightweight\, low-code development of small-scale personal and collaborative applications for managing data. A barrier is hit when trying to scale up these applications: as the volume of the data grows\, performance of spreadsheet computations degrades noticeably\, making their maintenance more difficult and frustrating. This paper explores one aspect in which spreadsheets can be boosted significantly — by making computations more incremental\, such that small changes to the data would incur a respectively small cost of update. This is particularly interesting in the context of aggregate operations — applied to sets of data elements\, producing a single value\, such as their sum or average. We propose a compilation phase in which a compiler transforms a spreadsheet table into a program that accepts a stream of changes and produces a stream of updates. We show how to adapt classical results from finite differencing to this interesting modern scenario\, and demonstrate that it yields asymptotic improvements to resource usage.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T074039Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T100000Z
DTEND:20231025T103000Z
DTSTAMP:20231021T100631Z
UID:88c30947-7534-49b6-8ce4-ab2de60bf02a@conf.researchr.org
CREATED:20230918T204554Z
SUMMARY:[SPLASH -E] Teaching Programming with Graphics: Pitfalls and a Solution - Luca Chiodini\, Juha Sorva\, Matthias Hauswirth
DESCRIPTION:
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T073438Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T103000Z
DTEND:20231025T110000Z
DTSTAMP:20231021T100631Z
UID:27ef0286-9fdf-44e1-8c8e-54c3c4f1623b@conf.researchr.org
CREATED:20230918T204554Z
SUMMARY:[SPLASH -E] KOGI: A Seamless Integration of ChatGPT into Jupyter Environments for Programming Education - Kimio Kuramitsu\, Yui Obara\, Miyu Sato\, Momoka Obara
DESCRIPTION:
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T073438Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T110000Z
DTEND:20231025T113000Z
DTSTAMP:20231021T100631Z
UID:aaf375b7-dea4-49e3-ab37-ed8e1a09e608@conf.researchr.org
CREATED:20230918T204554Z
SUMMARY:[SPLASH -E] A Framework for the Localization of Programming Languages - Alaaeddin Swidan\, Felienne Hermans
DESCRIPTION:
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T073438Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T130000Z
DTEND:20231025T131800Z
DTSTAMP:20231021T100631Z
UID:766caa8b-e2da-42c8-96ff-848c5fb26df4@conf.researchr.org
CREATED:20230915T184255Z
SUMMARY:[SPLASH OOPSLA] Run-Time Prevention of Software Integration Failures of Machine Learning APIs - Chengcheng Wan\, Yuhan Liu\, Kuntai Du\, Henry Hoffmann\, Junchen Jiang\, Michael Maire\, Shan Lu
DESCRIPTION:Due to the under-specified interfaces\, developers face challenges in correctly integrating machine learning (ML) APIs in software. Even when the ML API and the software are well designed on their own\, the resulting application misbehaves when the API output is incompatible with the software. It is desirable to have an adapter that converts ML API output at runtime to better fit the software need and prevent integration failures. In this paper\, we conduct an empirical study to understand ML API integration problems in real-world applications. Guided by this study\, we present SmartGear\, a tool that automatically detects and converts mismatching or incorrect ML API output at run time\, serving as a middle layer between ML API and software. Our evaluation on a variety of open-source applications shows that SmartGear detects 70% incompatible API outputs and prevents 67% potential integration failures\, outperforming alternative solutions.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T131800Z
DTEND:20231025T133600Z
DTSTAMP:20231021T100631Z
UID:36aa1b94-e911-4dad-9cc3-23a6b2cc40e9@conf.researchr.org
CREATED:20230915T184255Z
SUMMARY:[SPLASH OOPSLA] Compiling Structured Tensor Algebra - Mahdi Ghorbani\, Mathieu Huot\, Shideh Hashemian\, Amir Shaikhha
DESCRIPTION:Tensor algebra is essential for data-intensive workloads in various computational domains. Computational scientists face a trade-off between the specialization degree provided by dense tensor algebra and the algorith- mic efficiency that leverages the structure provided by sparse tensors. This paper presents StructTensor\, a framework that symbolically computes structure at compilation time. This is enabled by Structured Tensor Unified Representation (STUR)\, an intermediate language that can capture tensor computations as well as their sparsity and redundancy structures. Through a mathematical view of lossless tensor computations\, we show that our symbolic structure computation and the related optimizations are sound. Finally\, for different tensor computation workloads and structures\, we experimentally show how capturing the symbolic structure can result in outperforming state-of-the-art frameworks for both dense and sparse tensor algebra.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T133600Z
DTEND:20231025T135400Z
DTSTAMP:20231021T100631Z
UID:2ce57389-1c0d-4b78-93c6-dbdb65996075@conf.researchr.org
CREATED:20230915T184255Z
SUMMARY:[SPLASH OOPSLA] Perception Contracts for Safety of ML-Enabled Systems - Angello Astorga\, Chiao Hsieh\, P. Madhusudan\, Sayan Mitra
DESCRIPTION:We introduce a novel notion of perception contracts to reason about the safety of controllers that interact with an environment using neural perception. Perception contracts capture errors in ground-truth estimations that preserve invariants when systems act upon them. We develop a theory of perception contracts and design symbolic learning algorithms for synthesizing them from a finite set of images. We implement our algorithms and evaluate synthesized perception contracts for two realistic vision-based control systems\, a lane tracking system for an electric vehicle and an agricultural robot that follows crop rows. Our evaluation shows that our approach is effective in synthesizing perception contracts and generalizes well when evaluated over test images obtained during runtime monitoring of the systems.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T135400Z
DTEND:20231025T141200Z
DTSTAMP:20231021T100631Z
UID:4358897a-0040-46ea-82e6-b3ab405dae32@conf.researchr.org
CREATED:20230915T184255Z
SUMMARY:[SPLASH OOPSLA] Languages with Decidable Learning: A Meta-theorem - Paul Krogmeier\, P. Madhusudan
DESCRIPTION:We study expression learning problems with syntactic restrictions and introduce the class of \emph{finite-aspect checkable languages} to characterize symbolic languages that admit decidable learning. The semantics of such languages can be defined using a bounded amount of auxiliary information that is independent of expression size but depends on a fixed structure over which evaluation occurs. We introduce a generic programming language for writing programs that evaluate expression syntax trees\, and we give a meta-theorem that connects such programs for finite-aspect checkable languages to finite tree automata\, which allows us to derive new decidable learning results and decision procedures for several expression learning problems by writing programs in the programming language.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T141200Z
DTEND:20231025T143000Z
DTSTAMP:20231021T100631Z
UID:f067964d-7ad8-4444-bcfe-bbf28c944f3e@conf.researchr.org
CREATED:20231020T191129Z
SUMMARY:[SPLASH OOPSLA] Deep Learning Robustness Verification for Few-Pixel Attacks - Yuval Shapira\, Eran Avneri\, Dana Drachsler Cohen
DESCRIPTION:While successful\, neural networks have been shown to be vulnerable to adversarial example attacks. In $L_0$ adversarial attacks\, also known as few-pixel attacks\, the attacker picks $t$ pixels from the image and arbitrarily perturbs them. To understand the robustness level of a network to these attacks\, it is required to check the robustness of the network to perturbations of every set of $t$ pixels. Since the number of sets is exponentially large\, existing robustness verifiers\, which can reason about a single set of pixels at a time\, are impractical for $L_0$ robustness verification. We introduce Calzone\, an $L_0$ robustness verifier for neural networks. To the best of our knowledge\, Calzone is the first to provide a sound and complete analysis for $L_0$ adversarial attacks. Calzone builds on the following observation: if a classifier is robust to any perturbation of a set of $k$ pixels\, for $k&gt\;t$\, then it is robust to any perturbation of its subsets of size $t$. Thus\, to reduce the verification time\, Calzone predicts the largest $k$ that can be proven robust\, via dynamic programming and sampling. It then relies on covering designs to compute a covering of the image with sets of size $k$. For each set in the covering\, Calzone submits its corresponding box neighborhood to an existing $L_\infty$ robustness verifier. If a set's neighborhood is not robust\, Calzone repeats this process and covers this set with sets of size $k'&lt\;k$. We evaluate Calzone on several datasets and networks\, for $t\leq 5$. Typically\, Calzone verifies $L_0$ robustness within few minutes. On our most challenging instances (e.g.\, $t=5$)\, Calzone completes within few hours. We compare to a MILP baseline and show that it does not scale already for $t=3$.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T130000Z
DTEND:20231025T131800Z
DTSTAMP:20231021T100631Z
UID:91e659e6-44b1-4ff2-b418-fd2aba280c22@conf.researchr.org
CREATED:20230912T182955Z
SUMMARY:[SPLASH OOPSLA] Mobius: Synthesizing Relational Queries with Recursive and Invented Predicates - Aalok Thakkar\, Nathaniel Sands\, Georgios Petrou\, Rajeev Alur\, Mayur Naik\, Mukund Raghothaman
DESCRIPTION:Synthesizing relational queries from data is challenging in the presence of recursion and invented predicates. We propose a fully automated approach to synthesize such queries. Our approach comprises of two steps: it first synthesizes a non-recursive query consistent with the given data\, and then identifies recursion schemes in it and thereby generalizes to arbitrary data. This generalization is achieved by an iterative predicate unification procedure which exploits the notion of data provenance to accelerate convergence. In each iteration of the procedure\, a constraint solver proposes a candidate query\, and a query evaluator checks if the proposed program is consistent with the given data. The data provenance for a failed query allows us to construct additional constraints for the constraint solver and refine the search. We have implemented our approach in a tool named Mobius. On a suite of 21 challenging recursive query synthesis tasks\, Mobius outperforms three state-of-the-art baselines Gensynth\, ILASP\, and Popper\, both in terms of runtime and accuracy. We also demonstrate that the synthesized queries generalize well to unseen data.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T131800Z
DTEND:20231025T133600Z
DTSTAMP:20231021T100631Z
UID:186325b5-9a8e-4e5b-bfb8-e1ff9516f653@conf.researchr.org
CREATED:20230912T182955Z
SUMMARY:[SPLASH OOPSLA] Data Extraction via Semantic Regular Expression Synthesis - Qiaochu Chen\, Arko Banerjee\, Çağatay Demiralp\, Greg Durrett\, Işıl Dillig
DESCRIPTION:Many data extraction tasks of practical relevance require not only syntactic pattern matching but also semantic reasoning about the content of the underlying text. While regular expressions are very well suited for tasks that require only syntactic pattern matching\, they fall short for data extraction tasks that involve both a syntactic and semantic component. To address this issue\, we introduce semantic regexes\, a generalization of regular expressions that facilitates combined syntactic and semantic reasoning about textual data. We also propose a novel learning algorithm that can synthesize semantic regexes from a small number of positive and negative examples. Our proposed learning algorithm uses a combination of neural sketch generation and compositional type-directed synthesis for fast and effective generalization from a small number of examples. We have implemented these ideas in a new tool called Smore and evaluated it on representative data extraction tasks involving several textual datasets. Our evaluation shows that semantic regexes can better support complex data extraction tasks than standard regular expressions and that our learning algorithm significantly outperforms existing tools\, including state-of-the-art neural networks and program synthesis tools.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T133600Z
DTEND:20231025T135400Z
DTSTAMP:20231021T100631Z
UID:03de927b-9920-4a3c-8d74-c33f0ceac82e@conf.researchr.org
CREATED:20230912T182955Z
SUMMARY:[SPLASH OOPSLA] Synthesizing Efficient Memoization Algorithms - Yican Sun\, Xuanyu Peng\, Yingfei Xiong
DESCRIPTION:In this paper\, we propose an automated approach to finding correct and efficient memoization algorithms from a given declarative specification. This problem has two major challenges: (i) a memoization algorithm is too large to be handled by conventional program synthesizers\; (ii) we need to guarantee the efficiency of the memoization algorithm. To address this challenge\, we structure the synthesis of memoization algorithms by introducing the local objective function and the memoization partition function and reduce the synthesis task to two smaller independent program synthesis tasks. Moreover\, the number of distinct outputs of the function synthesized in the second synthesis task also decides the efficiency of the synthesized memoization algorithm\, and we only need to minimize the number of different output values of the synthesized function. However\, the generated synthesis task is still too complex for existing synthesizers. Thus\, we propose a novel synthesis algorithm that combines the deductive and inductive methods to solve these tasks. To evaluate our algorithm\, we collect 42 real-world benchmarks from Leetcode\, the National Olympiad in Informatics in Provinces-Junior (a national-wide algorithmic programming contest in China)\, and previous approaches. Our approach successfully synhesizes 39/42 problems in a reasonable time\, outperforming the baselines.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T135400Z
DTEND:20231025T141200Z
DTSTAMP:20231021T100631Z
UID:09faca3d-b411-4b5e-b313-d6c9ac892a67@conf.researchr.org
CREATED:20230915T183959Z
SUMMARY:[SPLASH OOPSLA] Algebro-geometric Algorithms for Template-Based Synthesis of Polynomial Programs - Amir Kafshdar Goharshady\, S. Hitarth\, Fatemeh Mohammadi\, Harshit Jitendra Motwani
DESCRIPTION:Template-based synthesis\, also known as sketching\, is a localized approach to program synthesis in which the programmer provides not only a specification\, but also a high-level “sketch” of the program. The sketch is basically a partial program that models the general intuition of the programmer\, while leaving the low-level details as unimplemented “holes”. The role of the synthesis engine is then to fill in these holes such that the completed program satisfies the desired specification. In this work\, we focus on template-based synthesis of polynomial imperative programs with real variables\, i.e. imperative programs in which all expressions appearing in assignments\, conditions and guards are polynomials over program variables. While this problem can be solved in a sound and complete manner by a reduction to the first-order theory of the reals\, the resulting formulas will contain a quantifier alternation and are extremely hard for modern SMT solvers\, even when considering toy programs with a handful of lines. Moreover\, the classical algorithms for quantifier elimination are notoriously unscalable and not at all applicable to this use-case. \nIn contrast\, our main contribution is an algorithm\, based on several well-known theorems in polyhedral and real algebraic geometry\, namely Putinar’s Positivstellensatz\, the Real Nullstellensatz\, Handelman’s Theorem and Farkas’ Lemma\, which sidesteps the quantifier elimination difficulty and reduces the problem directly to Quadratic Programming (QP). Alternatively\, one can view our algorithm as an efficient way of eliminating quantifiers in the particular formulas that appear in the synthesis problem. The resulting QP instances can then be handled quite easily by SMT solvers. Notably\, our reduction to QP is sound and semi-complete\, i.e. it is complete if polynomials of a sufficiently high degree are used in the templates. Thus\, we provide the first method for sketching-based synthesis of polynomial programs that does not sacrifice completeness\, while being scalable enough to handle meaningful programs. Finally\, we provide experimental results over a variety of examples from the literature.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T141200Z
DTEND:20231025T143000Z
DTSTAMP:20231021T100631Z
UID:daf6087f-f4f9-4855-9bc8-1e4076dbba68@conf.researchr.org
CREATED:20230915T183959Z
SUMMARY:[SPLASH OOPSLA] Modular Component-Based Quantum Circuit Synthesis - Chan Gu Kang\, Hakjoo Oh
DESCRIPTION:In this article\, we present a novel method for synthesizing quantum circuits from user-supplied components. Given input-output state vectors and component quantum gates\, our synthesizer aims to construct a quantum circuit that implements the provided functionality in terms of the supplied component gates.&nbsp\;To achieve this\, we basically use an enumerative search with pruning. To accelerate the procedure\, however\, we perform the search and pruning at the module level\; instead of simply enumerating candidate circuits by appending component gates in sequence\, we stack modules\, which are groups of gate operations. With this modular approach\, we can effectively reduce the search space by directing the search in a way that bridges the gap between the current circuit and the input-output specification. Evaluation on 17 benchmark problems shows that our technique is highly effective at synthesizing quantum circuits. Our method successfully synthesized 16 out of 17 benchmark circuits in 96.6 seconds on average. On the other hand\, the conventional\, gate-level synthesis algorithm succeeded in 10 problems with an average time of 639.1 seconds. Our algorithm increased the speed of the baseline by 20.3x for the 10 problems commonly solved by both approaches.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T130000Z
DTEND:20231025T133000Z
DTSTAMP:20231021T100631Z
UID:ab2e1af6-4404-4092-b572-5b3e436e7fe6@conf.researchr.org
CREATED:20230907T154554Z
SUMMARY:[SPLASH Onward! Papers] Could No-Code be Code? -- Toward a No-Code Programming Language for Citizen Developers - David H. Lorenz\, Assaf Zeira
DESCRIPTION:By 2030 for each filled position in Software Engineering\, two positions would remain unfilled. This already apparent loss of productivity has the software industry scrambling to fill the missing positions with citizen developers – technical people with little or no programming skills – who would be using No-Code platforms to program various software solutions in specific domains. However\, currently available platforms have fairly limited abstractions\, lacking the flexibility of a general purpose programming language. \nTo break the No-Code abstraction barrier\, a very simple yet expressive general purpose No-Code programming language might provide citizen developers with an alternative to domain-specific No-Code platforms. Unfortunately\, these requirements seem contradictory. Making a language very simple and specific might render it crippled\, thus limited to a certain domain of problems. Conversely\, making a language very expressive and general\, might render it too complicated for citizen developers. \nIn this work we argue that a multi-paradigm minimalist approach can bridge the gap between simplicity and expressiveness by including only abstractions considered intuitive to citizens. As a concrete proof-of-concept\, we present a general purpose programming language designed for citizen developers that is on the one hand very powerful and on the other hand very simple. In fact\, this language is so simple that the entire development is accomplished by flowcharts using mouse actions only\, without typing a single line of code\, thus demonstrating a general purpose No-Code programming language candidate for citizen developers.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T173022Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T133000Z
DTEND:20231025T140000Z
DTSTAMP:20231021T100631Z
UID:fb0ab2e6-83b9-4f9e-963f-b7559df77a4e@conf.researchr.org
CREATED:20230907T154554Z
SUMMARY:[SPLASH Onward! Papers] Toward Programming Languages for Reasoning -- Humans\, Symbolic Systems\, and AI Agents - Mark Marron
DESCRIPTION:Integration\, composition\, mechanization\, and AI assisted development are the driving themes in the future of software development. At their core these concepts are rooted in the increasingly important role of computing in our world\, the desire to deliver functionality faster\, with higher quality\, and to empower more people to benefit from programmatic automation. These themes\, and how they impact the human developers driving them\, are the foundations for the next generation of programming languages. At first glance the needs of mechanization tools\, AI agents\, and human developers along with the various goals around development velocity\, software quality\, and software democratization are a broad and seemingly diverse set of needs. However\, at their core is a single challenge that\, once resolved\, enables us to make radical progress in all of these areas. \nOur hypothesis is that\, fundamentally\, software development is a problem of reasoning about code and semantics. This is true for human developers implementing a feature\, symbolic tools building models of application behaviour\, and even for language based AI agents as they perform tasks. While the particular aspects of reasoning that each agent struggles with varies to some degree\, they share many common themes and\, surprisingly\, most mainstream languages extensively employ features that make this task harder or infeasible! This paper proposes a novel approach to this challenge – instead of new language features or logical constructs\, that add more complexity to what is already a problem of complexity\, we propose radical simplification in the form of a new platform and programming language.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T074045Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T140000Z
DTEND:20231025T143000Z
DTSTAMP:20231021T100631Z
UID:89a3e92f-c8c2-4b75-96ef-fe7784986caf@conf.researchr.org
CREATED:20230907T154554Z
SUMMARY:[SPLASH Onward! Papers] Trustworthy Formal Natural Language Specifications - Colin Gordon\, Sergey Matskevich
DESCRIPTION:Interactive proof assistants are computer programs carefully constructed to check a human-designed proof of a mathematical claim with high confidence in the implementation. However\, this only validates truth of a formal claim\, which may have been mistranslated from a claim made in natural language. This is especially problematic when using proof assistants to formally verify the correctness of software with respect to a natural language specification. The translation from informal to formal remains a challenging\, time-consuming process that is difficult to audit for correctness. \nThis paper shows that it is possible to build support for specifications written in expressive subsets of natural language\, within existing proof assistants\, in a way that complements the principles used to establish trust and auditability in proof assistants themselves. We implement a means to provide specifications in a modularly extensible formal subset of English\, and have them automatically translated into formal claims\, entirely within the Lean proof assistant. Our approach is extensible (placing no permanent restrictions on grammatical structure)\, modular (allowing information about new words to be distributed alongside libraries)\, and produces proof certificates explaining how each word was interpreted and how the sentence’s structure was used to compute the meaning. \nWe apply our prototype to the translation of various English descriptions of formal specifications from a popular textbook into Lean formalizations\; all can be translated correctly with a modest lexicon with only minor modifications related to lexicon size.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T074045Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T130000Z
DTEND:20231025T133000Z
DTSTAMP:20231021T100631Z
UID:3a7d307c-818b-43bb-b2a2-a96d5f7d7ca0@conf.researchr.org
CREATED:20230918T204714Z
SUMMARY:[SPLASH -E] Just-In-Time Introductions & Non-Archival Presentations
DESCRIPTION:
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T110940Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T133000Z
DTEND:20231025T140000Z
DTSTAMP:20231021T100631Z
UID:cc32a195-bf45-49ae-92f8-bde9dc0a0b89@conf.researchr.org
CREATED:20230918T204518Z
SUMMARY:[SPLASH -E] Composing Turing Machines in FSM - Marco T Morazan
DESCRIPTION:
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T073445Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T140000Z
DTEND:20231025T143000Z
DTSTAMP:20231021T100631Z
UID:3cf9bed4-edec-4b5f-bbe4-c52a3e900449@conf.researchr.org
CREATED:20230918T204802Z
SUMMARY:[SPLASH -E] Witter: A Library for White-Box Testing of Introductory Programming Algorithms - Afonso B. Caniço\, André L. Santos
DESCRIPTION:Software testing is mostly performed in a black-box manner\, that is\, without incorporating any knowledge of the internal workings of programs into the tests. This practice usually suffices for enterprises and general practitioners\, where the focus lies on producing reliable results while most algorithmic tasks are provided by third-party libraries. However\, for computer science students and the like\, it might not be straightforward to discern the underlying causes of an incorrect test result or to understand why certain algorithmic goals are not met. We present Witter\, a software testing library that allows programming educators to define white-box tests for Java source code. Our tests analyze the execution of a method against a reference solution\, to verify that the code not only produces correct results but is also in accordance with a desired algorithm behavior.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231019T193043Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T150000Z
DTEND:20231025T151800Z
DTSTAMP:20231021T100631Z
UID:ea91b6d4-061c-4dc9-8bfa-4822ecf60311@conf.researchr.org
CREATED:20230912T184650Z
SUMMARY:[SPLASH OOPSLA] A Deductive Verification Infrastructure for Probabilistic Programs - Philipp Schröer\, Kevin Batz\, Benjamin Lucien Kaminski\, Joost-Pieter Katoen\, Christoph Matheja
DESCRIPTION:This paper presents a quantitative program verification infrastructure for discrete probabilistic programs. Our infrastructure can be viewed as the probabilistic analogue of Boogie: its central components are an intermediate verification language (IVL) together with a real-valued logic. Our IVL provides a programming-language-style for expressing verification conditions whose validity implies the correctness of a program under investigation. As our focus is on verifying quantitative properties such as bounds on expected outcomes\, expected run-times\, or termination probabilities\, off-the-shelf IVLs based on Boolean first-order logic do not suffice. Instead\, a paradigm shift from the standard Boolean to a real-valued domain is required. \nOur IVL features quantitative generalizations of standard verification constructs such as assume- and assert-statements. Verification conditions are generated by a weakest-precondition-style semantics\, based on our real-valued logic. We show that our verification infrastructure supports natural encodings of numerous verification techniques from the literature. With our SMT-based implementation\, we automatically verify a variety of benchmarks. To the best of our knowledge\, this establishes the first deductive verification infrastructure for expectation-based reasoning about probabilistic programs.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T151800Z
DTEND:20231025T153600Z
DTSTAMP:20231021T100631Z
UID:6ca58638-d69d-4255-bc10-1d526a0add2a@conf.researchr.org
CREATED:20230912T184650Z
SUMMARY:[SPLASH OOPSLA] A Gradual Probabilistic Lambda Calculus - Wenjia Ye\, Matías Toro\, Federico Olmedo
DESCRIPTION:Probabilistic programming languages have recently gained a lot of attention\, in particular due to their applications in domains such as machine learning and differential privacy. To establish invariants of interest\, many such languages include some form of static checking in the form of type systems. However\, adopting such a type discipline can be cumbersome or overly conservative. Gradual typing addresses this problem by supporting a smooth transition between static and dynamic checking\, and has been successfully applied for languages with different constructs and type abstractions. Nevertheless\, its benefits have never been explored in the context of probabilistic languages. In this work\, we present and formalize GPLC\, a gradual source probabilistic lambda calculus. GPLC includes a binary probabilistic choice operator and allows programmers to gradually introduce/remove static type–and probability–annotations. The static semantics of GPLC heavily relies on the notion of probabilistic couplings\, as required for defining several relations\, such as consistency\, precision\, and consistent transitivity. The dynamic semantics of GPLC is given via elaboration to the target language TPLC\, which features a distribution-based semantics interpreting programs as probability distributions over final values. Regarding the language metatheory\, we establish that TPLC–and therefore also GPLC–is type safe and satisfies two of the so-called refined criteria for gradual languages\, namely\, that it is a conservative extension of a fully static variant and that it satisfies the gradual guarantee\, behaving smoothly with respect to type precision.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T153600Z
DTEND:20231025T155400Z
DTSTAMP:20231021T100631Z
UID:8c4b8dc6-01bb-43a8-9bd2-b7c3272607ac@conf.researchr.org
CREATED:20230912T184650Z
SUMMARY:[SPLASH OOPSLA] Lower Bounds for Possibly Divergent Probabilistic Programs - Shenghua Feng\, Mingshuai Chen\, Han Su\, Benjamin Lucien Kaminski\, Joost-Pieter Katoen\, Naijun Zhan
DESCRIPTION:We present a new proof rule for verifying lower bounds on quantities of probabilistic programs. Our proof rule is not confined to almost-surely terminating programs – as is the case for existing rules – and can be used to establish non-trivial lower bounds on\, e.g.\, termination probabilities and expected values\, for possibly divergent probabilistic loops\, e.g.\, the well-known three-dimensional random walk on a lattice.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T155400Z
DTEND:20231025T161200Z
DTSTAMP:20231021T100631Z
UID:d78050a2-763c-4288-97a0-db0db4cf0c49@conf.researchr.org
CREATED:20230912T184650Z
SUMMARY:[SPLASH OOPSLA] Exact Recursive Probabilistic Programming - David Chiang\, Colin McDonald\, Chung-chieh Shan
DESCRIPTION:Recursive calls over recursive data are useful for generating probability distributions\, and probabilistic programming allows computations over these distributions to be expressed in a modular and intuitive way. Exact inference is also useful\, but unfortunately\, existing probabilistic programming languages do not perform exact inference on recursive calls over recursive data\, forcing programmers to code many applications manually. We introduce a probabilistic language in which a wide variety of recursion can be expressed naturally\, and inference carried out exactly. For instance\, probabilistic pushdown automata and their generalizations are easy to express\, and polynomial-time parsing algorithms for them are derived automatically. We eliminate recursive data types using program transformations related to defunctionalization and refunctionalization. These transformations are assured correct by a linear type system\, and a successful choice of transformations\, if there is one\, is guaranteed to be found by a greedy algorithm.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T161200Z
DTEND:20231025T163000Z
DTSTAMP:20231021T100631Z
UID:4ad04134-615c-432e-ad04-5066b6afd267@conf.researchr.org
CREATED:20230915T153231Z
SUMMARY:[SPLASH OOPSLA] Solving String Constraints with Lengths by Stabilization - Yu-Fang Chen\, David Chocholatý\, Vojtěch Havlena\, Lukáš Holík\, Ondřej Lengál\, Juraj Síč
DESCRIPTION:We present a new algorithm for solving string constraints. The algorithm builds upon a recent method for solving word equations and regular constraints that interprets string variables as languages rather than strings and\, consequently\, mitigates the combinatorial explosion that plagues other approaches. We extend the approach to handle linear integer arithmetic length constraints by combination with a known principle of equation alignment and splitting\, and by extension to other common types of string constraints\, yielding a fully-fledged string solver. The ability of the framework to handle unrestricted disequalities even extends one of the largest decidable classes of string constraints\, the chain-free fragment. We integrate our algorithm into a DPLL-based SMT solver. The performance of our implementation is competitive and even significantly better than state-of-the-art string solvers on several established benchmarks obtained from applications in verification of string programs.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T150000Z
DTEND:20231025T151800Z
DTSTAMP:20231021T100631Z
UID:d92d47c7-0c1b-4c9f-84a5-e4b137b46c31@conf.researchr.org
CREATED:20230918T150929Z
SUMMARY:[SPLASH OOPSLA] Fluent APIs in Functional Languages - Ori Roth\, Yossi Gil
DESCRIPTION:Fluent API is an object-oriented pattern for elegant APIs and embedded DSLs. A smart fluent API can enforce the API protocol or DSL syntax at compile time. Since fluent API implementations typically rely on overloading function names\, they are hard to realize in functional programming languages. This work shows how functional fluent APIs can be implemented in the absence of name overloading\, by relying on parametric polymorphism and Hindley-Milner type inference. The implementation supports fluent API protocols in the regular- and deterministic context-free language classes\, and even beyond.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T151800Z
DTEND:20231025T153600Z
DTSTAMP:20231021T100631Z
UID:68d7325f-9417-4856-91b3-92d42122b644@conf.researchr.org
CREATED:20230918T150929Z
SUMMARY:[SPLASH OOPSLA] A Pretty Expressive Printer - Sorawee Porncharoenwase\, Justin Pombrio\, Emina Torlak
DESCRIPTION:Pretty printers make trade-offs between the expressiveness of their pretty printing language\, the optimality objective that they minimize when choosing between different ways to lay out a document\, and the performance of their algorithm. This paper presents a new pretty printer\, $\Pi_e$\, that is strictly more expressive than all pretty printers in the literature and provably minimizes an optimality objective. Furthermore\, the time complexity of $\Pi_e$ is better than many existing pretty printers. When choosing among different ways to lay out a document\, $\Pi_e$ consults a user-supplied cost factory\, which determines the optimality objective\, giving $\Pi_e$ a unique degree of flexibility. We use the Lean theorem prover to verify the correctness (validity and optimality) of $\Pi_e$\, and implement $\Pi_e$ concretely as a pretty printer that we call PrettyExpressive. To evaluate our pretty printer against others\, we develop a formal framework for reasoning about the expressiveness of pretty printing languages\, and survey pretty printers in the literature\, comparing their expressiveness\, optimality\, worst-case time complexity\, and practical running time. Our evaluation shows that PrettyExpressive is efficient and effective at producing optimal layouts. PrettyExpressive has also seen real-world adoption: it serves as a foundation of a code formatter for Racket.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T153600Z
DTEND:20231025T155400Z
DTSTAMP:20231021T100631Z
UID:3c01c1c1-1a6f-4edf-8994-56f5b1d6eb5e@conf.researchr.org
CREATED:20230918T150929Z
SUMMARY:[SPLASH OOPSLA] How Domain Experts Use an Embedded DSL - Lisa Rennels\, Sarah E. Chasins
DESCRIPTION:Programming tools are increasingly integral to research and analysis in myriad domains\, including specialized areas with no formal relation to computer science. Embedded domain-specific languages (eDSLs) have the potential to serve these programmers while placing relatively light implementation burdens on language designers. However\, barriers to eDSL use reduce their practical value and adoption. In this paper\, we aim to deepen our understanding of how programmers use eDSLs and identify user needs to inform future eDSL designs. We performed a contextual inquiry (9 participants) with domain experts using Mimi\, an eDSL for climate change economics modeling. A thematic analysis identified five key themes\, including: the interaction between the eDSL and the host language has significant and sometimes unexpected impacts on eDSL user experience\, and users preferentially engage with domain-specific communities and code templates rather than host language resources. The needs uncovered in our study offer design considerations for future eDSLs and suggest directions for future DSL usability research.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T155400Z
DTEND:20231025T161200Z
DTSTAMP:20231021T100631Z
UID:8de0beb5-fcf9-4042-a7bd-db53231111bc@conf.researchr.org
CREATED:20230918T150929Z
SUMMARY:[SPLASH OOPSLA] Saggitarius: A DSL for Specifying Grammatical Domains - Anders Miltner\, Devon Loehr\, Arnold Mong\, Kathleen Fisher\, David Walker
DESCRIPTION:Common data types like dates\, addresses\, phone numbers and tables can have multiple textual representations\, and many heavily-used languages\, such as SQL\, come in several dialects. These variations can cause data to be misinterpreted\, leading to silent data corruption\, failure of data processing systems\, or even security vulnerabilities. Saggitarius is a new language and system designed to help programmers reason about the format of data\, by describing grammatical domains—that is\, sets of context-free grammars that describe the many possible representations of a datatype. We describe the design of Saggitarius via example and provide a relational semantics. We show how Saggitarius may be used to analyze a data set: given example data\, it uses an algorithm based on semi-ring parsing and MaxSAT to infer which grammar in a given domain best matches that data. We evaluate the effectiveness of the algorithm on a benchmark suite of 110 example problems\, and we demonstrate that our system typically returns a satisfying grammar within a few seconds with only a small number of examples. We also delve deeper into a more extensive case study on using Saggitarius for CSV dialect detection. Despite being general-purpose\, we find that Saggitarius offers comparable results to hand-tuned\, specialized tools\; in the case of CSV\, it infers grammars for 84% of benchmarks within 60 seconds\, and has comparable accuracy to custom-built dialect detection tools.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T161200Z
DTEND:20231025T163000Z
DTSTAMP:20231021T100631Z
UID:a4213676-0450-416d-b587-6371cadbf0d9@conf.researchr.org
CREATED:20230918T150929Z
SUMMARY:[SPLASH OOPSLA] Mat2Stencil: A Modular Matrix-Based DSL for Explicit and Implicit Matrix-Free PDE Solvers on Structured Grid - Huanqi Cao\, Shizhi Tang\, Qianchao Zhu\, Bowen Yu\, Wenguang Chen
DESCRIPTION:Partial differential equation (PDE) solvers are extensively utilized across numerous scientific and engineering fields. However\, achieving high performance and scalability often necessitates intricate and low-level programming\, particularly when leveraging deterministic sparsity patterns in structured grids. \nIn this paper\, we propose an innovative domain-specific language (DSL)\, Mat2Stencil\, with its compiler\, for PDE solvers on structured grids. Mat2Stencil introduces a structured sparse matrix abstraction\, facilitating modular\, flexible\, and easy-to-use expression of solvers across a broad spectrum\, encompassing components such as Jacobi or Gauss-Seidel preconditioners\, incomplete LU or Cholesky decompositions\, and multigrid methods built upon them. Our DSL compiler subsequently generates matrix-free code consisting of generalized stencils through multi-stage programming. The code allows spatial loop-carried dependence in the form of quasi-affine loops\, in addition to the Jacobi-style stencil's embarrassingly parallel on spatial dimensions. We further propose a novel automatic parallelization technique for the spatially dependent loops\, which offers a compile-time deterministic task partitioning for threading\, calculates necessary inter-thread synchronization automatically\, and generates an efficient multi-threaded implementation with fine-grained synchronization. \nImplementing 4 benchmarking programs\, 3 of them being the pseudo-applications in NAS Parallel Benchmarks with $6.3%$ lines of code and 1 being matrix-free High Performance Conjugate Gradients with $16.4%$ lines of code\, we achieve up to $1.67\times$ and on average $1.03\times$ performance compared to manual implementations.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T163000Z
DTEND:20231025T164800Z
DTSTAMP:20231021T100631Z
UID:d0702142-1c50-4791-98c3-24bf29d98a55@conf.researchr.org
CREATED:20231020T191217Z
SUMMARY:[SPLASH OOPSLA] Translating canonical SQL to imperative code in Coq - Véronique Benzaken\, Évelyne Contejean\, Houssem Hachmaoui\, Chantal Keller\, Louis Mandel\, Avraham Shinnar\, Jerome Simeon
DESCRIPTION:SQL is by far the most widely used and implemented query language. Yet\, on some key features\, such as correlated queries and NULL value semantics\, many implementations diverge or contain bugs. We leverage recent advances in the formalization of SQL and query compilers to develop DBCert\, the first mechanically verified compiler from SQL queries written in a canonical form to imperative code. Building DBCert required several new contributions which are described in this paper. First\, we specify and mechanize a complete translation from SQL to the Nested Relational Algebra which can be used for query optimization. Second\, we define Imp\, a small imperative language sufficient to express SQL and which can target several execution languages including JavaScript. Finally\, we develop a mechanized translation from the nested relational algebra to Imp\, using the nested relational calculus as an intermediate step.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T150000Z
DTEND:20231025T154500Z
DTSTAMP:20231021T100631Z
UID:08a0989b-bc63-4957-80fa-3596faafd031@conf.researchr.org
CREATED:20230907T154641Z
SUMMARY:[SPLASH Onward! Papers] Will code remain a relevant user interface for end-user programming with generative AI models? - Advait Sarkar
DESCRIPTION:The research field of end-user programming has largely been concerned with helping non-experts learn to code sufficiently well in order to achieve their tasks. Generative AI stands to obviate this entirely by allowing users to generate code from naturalistic language prompts. In this essay\, we explore the extent to which "traditional'' programming languages remain relevant for non-expert end-user programmers in a world with generative AI. We posit the "generative shift hypothesis'': that generative AI will create qualitative and quantitative expansions in the traditional scope of end-user programming. We outline some reasons that traditional programming languages may still be relevant and useful for end-user programmers. We speculate whether each of these reasons might be fundamental and enduring\, or whether they may disappear with further improvements and innovations in generative AI. Finally\, we articulate a set of implications for end-user programming research\, including the possibility of needing to revisit many well-established core concepts\, such as Ko’s learning barriers and Blackwell’s attention investment model.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231018T102738Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T154500Z
DTEND:20231025T163000Z
DTSTAMP:20231021T100631Z
UID:9321b612-5908-441a-b0a5-9b41f94c8e50@conf.researchr.org
CREATED:20230907T154641Z
SUMMARY:[SPLASH Onward! Papers] programmingLanguage as Language\; - James Noble\, Robert Biddle
DESCRIPTION:Programming languages are languages — “unnatural” languages because they are constructed explicitly\; “formal” languages because they rely on mathematical notations and are described mathematically\; “machine” languages because they are used to communicate with machines: but because they are read and written by humans\, supported by human communities and forming those communities in turn\, programming languages are “human” languages above all. \nProgramming languages adopt structural elements from natural language\, including syntax\, grammar\, vocabulary\, and even some sentence structure. Other aspects of language have received less attention\, including noun declension\, verb tense\, and situation-appropriate register. Semiotics shows how language use can connote and imply\, and will lead to interpretation. Language involves larger level structure too: conversations\, stories\, and documents of all kinds. Language supports both cognitive and affective processes\, and is involved in building mental models that we use to recall\, reason\, and respond. \nProgramming is a complex activity\, uncertain yet precise\, individual and social\, involving intent and interpretation. \nLanguage is not the accident of programming - it is the essence.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T074050Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T150000Z
DTEND:20231025T153000Z
DTSTAMP:20231021T100631Z
UID:db655eb9-562b-4040-9f98-40ea4cb0c32a@conf.researchr.org
CREATED:20230918T204542Z
SUMMARY:[SPLASH -E] Centering Humans in the Programming Languages Classroom: Building a Text for the Next Generation - Rose Bohrer
DESCRIPTION:
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T073449Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T153000Z
DTEND:20231025T160000Z
DTSTAMP:20231021T100631Z
UID:e302b10b-7901-4859-b351-ce1c4d5a2595@conf.researchr.org
CREATED:20230918T204542Z
SUMMARY:[SPLASH -E] Exploring Engagement and Self-Efficacy in an Introductory Computer Science Course - Rory Kelly\, Meghan Allen
DESCRIPTION:
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T073449Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T160000Z
DTEND:20231025T163000Z
DTSTAMP:20231021T100631Z
UID:3b96dbef-35d9-48fe-bb8f-845dafccc0d7@conf.researchr.org
CREATED:20230918T204839Z
SUMMARY:[SPLASH -E] Past\, Present & Future of SPLASH-E Discussion
DESCRIPTION:
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T073449Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231025T164500Z
DTEND:20231025T183000Z
DTSTAMP:20231021T100631Z
UID:53580850-d498-4e6e-a914-22f36a4b0200@conf.researchr.org
CREATED:20231012T051913Z
SUMMARY:[SPLASH Catering] Reception
DESCRIPTION:
LOCATION:Gallery - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231012T051913Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T083000Z
DTEND:20231026T093000Z
DTSTAMP:20231021T100631Z
UID:213d4787-d379-45bb-9aa8-8c7d83b389af@conf.researchr.org
CREATED:20230915T185002Z
SUMMARY:[SPLASH OOPSLA] Hydroflow: A Compiler Target for Fast\, Correct Distributed Programs - Joseph M. Hellerstein
DESCRIPTION:Traditional compilers offer little assistance in ensuring the correctness of distributed programs. The Hydro project at Berkeley is an effort to build a compiler stack to address these issues. The lowest layer of the Hydro stack is Hydroflow\, a Rust-based dataflow runtime with an IR based on a semilattice formalism. Hydroflow enables correct program transformations that are natural in the context of distributed systems. Transformations include: \n \n Refactoring: Given an arbitrary block of code\, refactor it into smaller blocks that can be launched on independent machines \n Replication: Given an arbitrary block of code\, determine whether it can be safely replicated in deployment \n Partitioning: Given an arbitrary block of code\, determine how its inputs can be safely partitioned (``sharded'') to multiple machines in deployment \n \nThese transformations in turn allow distributed programs to be optimized for various goals\, including parallelism (both pipelines and partitioning)\, memory scaling\, performance isolation\, geoproximity and physical security. \nWe present case studies showing correctness\, latency and scaling results when optimizing programs ranging from infrastructure like key-value stores\, applications like shopping carts and messaging systems\, and tricky consensus protocols.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T100000Z
DTEND:20231026T101800Z
DTSTAMP:20231021T100631Z
UID:81687b26-051b-4b61-90c9-92a4e710292a@conf.researchr.org
CREATED:20230915T184600Z
SUMMARY:[SPLASH OOPSLA] Reference Capabilities for Flexible Memory Management - Ellen Arvidsson\, Elias Castegren\, Sylvan Clebsch\, Sophia Drossopoulou\, James Noble\, Matthew J. Parkinson\, Tobias Wrigstad
DESCRIPTION:Verona is a concurrent object-oriented programming language that organises all the objects in a program into a forest of isolated regions. Memory is managed locally for each region\, so programmers can control a program's memory use by adjusting objects' partition into regions\, and by setting each region's memory management strategy. A thread can only mutate (allocate\, deallocate) objects within one active region—its "window of mutability". Memory management costs are localised to the active region\, ensuring overheads can be predicted and controlled. Moving the mutability window between regions is explicit\, so code can be executed wherever it is required\, yet programs remain in control of memory use. An ownership type system based on reference capabilities enforces region isolation\, controlling aliasing within and between regions\, yet supporting objects moving between regions and threads. Data accesses never need expensive atomic operations\, and are always thread-safe.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T101800Z
DTEND:20231026T103600Z
DTSTAMP:20231021T100631Z
UID:0145b847-47b3-4260-baef-afe92393faa4@conf.researchr.org
CREATED:20230915T184600Z
SUMMARY:[SPLASH OOPSLA] A Grounded Conceptual Model for Ownership Types in Rust - Will Crichton\, Gavin Gray\, Shriram Krishnamurthi
DESCRIPTION:Programmers learning Rust struggle to understand ownership types\, Rust's core mechanism for ensuring memory safety without garbage collection. This paper describes our attempt to systematically design a pedagogy for ownership types. First\, we studied Rust developers' misconceptions of ownership to create the Ownership Inventory\, a new instrument for measuring a person's knowledge of ownership. We found that Rust learners could not connect Rust's static and dynamic semantics\, such as determining why an ill-typed program would (or would not) exhibit undefined behavior. Second\, we created a conceptual model of Rust's semantics that explains borrow checking in terms of flow-sensitive permissions on paths into memory. Third\, we implemented a Rust compiler plugin that visualizes programs under the model. Fourth\, we integrated the permissions model and visualizations into a broader pedagogy of ownership by writing a new ownership chapter for \textit{The Rust Programming Language}\, a popular Rust textbook. Fifth\, we evaluated an initial deployment of our pedagogy against the original version\, using reader responses to the Ownership Inventory as a point of comparison. Thus far\, the new pedagogy has improved learner scores on the Ownership Inventory by an average of 9% $N = 342\, d = 0.56$.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T103600Z
DTEND:20231026T105400Z
DTSTAMP:20231021T100631Z
UID:7f8028f8-e1dc-4d90-ba51-4316e06a5d5e@conf.researchr.org
CREATED:20230915T184600Z
SUMMARY:[SPLASH OOPSLA] Inference of Resource Management Specifications - Narges Shadab\, Pritam Gharat\, Shrey Tiwari\, Michael D. Ernst\, Martin Kellogg\, Shuvendu K. Lahiri\, Akash Lal\, Manu Sridharan
DESCRIPTION:A resource leak occurs when a program fails to free some finite resource after it is no longer needed. Such leaks are a significant cause of real-world crashes and performance problems. Recent work proposed an approach to prevent resource leaks based on checking resource management specifications. A resource management specification expresses how the program allocates resources\, passes them around\, and releases them\; it also tracks the ownership relationship between objects and resources\, and aliasing relationships between objects. While this specify-and-verify approach has several advantages compared to prior techniques\, the need to manually write annotations presents a significant barrier to its practical adoption. \nThis paper presents a novel technique to automatically infer a resource management specification for a program\, broadening the applicability of specify-and-check verification for resource leaks. Inference in this domain is challenging because resource management specifications differ significantly in nature from the types that most inference techniques target. Further\, for practical effectiveness\, we desire a technique that can infer the resource management specification intended by the developer\, even in cases when the code does not fully adhere to that specification. We address these challenges through a set of inference rules carefully designed to capture real-world coding patterns\, yielding an effective fixed-point-based inference algorithm. \nWe have implemented our inference algorithm in two different systems\, targeting programs written in Java and C#. In an experimental evaluation\, our technique inferred 85.5% of the annotations that programmers had written manually for the benchmarks. Further\, the verifier issued nearly the same rate of false alarms with the manually-written and automatically-inferred annotations.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T105400Z
DTEND:20231026T111200Z
DTSTAMP:20231021T100631Z
UID:b2992508-0918-4e2f-995c-4bdb3a91f33e@conf.researchr.org
CREATED:20230915T184600Z
SUMMARY:[SPLASH OOPSLA] Resource-Aware Soundness for Big-Step Semantics - Riccardo Bianchini\, Francesco Dagnino\, Paola Giannini\, Elena Zucca
DESCRIPTION:We extend the semantics and type system of a lambda calculus equipped with common constructs to be \emph{resource-aware}. That is\, reduction is instrumented to keep track of the usage of resources\, and the type system guarantees\, besides standard soundness\, that for well-typed programs there is a computation where no needed resource gets exhausted. The resource-aware extension is parametric on an arbitrary \emph{grade algebra}\, and does not require ad-hoc changes to the underlying language. To this end\, the semantics needs to be formalized in big-step style\; as a consequence\, expressing and proving (resource-aware) soundness is challenging\, and is achieved by applying recent techniques based on coinductive reasoning.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T111200Z
DTEND:20231026T113000Z
DTSTAMP:20231021T100631Z
UID:c5513459-3296-465c-ab1a-26eadb978af9@conf.researchr.org
CREATED:20230915T184600Z
SUMMARY:[SPLASH OOPSLA] Verus: Verifying Rust Programs using Linear Ghost Types - Andrea Lattuada\, Travis Hance\, Chanhee Cho\, Matthias Brun\, Isitha Subasinghe\, Yi Zhou\, Jon Howell\, Bryan Parno\, Chris Hawblitzel
DESCRIPTION:The Rust programming language provides a powerful type system that checks linearity and borrowing\, allowing code to safely manipulate memory without garbage collection and making Rust ideal for developing low-level\, high-assurance systems. For such systems\, formal verification can be useful to prove functional correctness properties beyond type safety. This paper presents Verus\, an SMT-based tool for formally verifying Rust programs. With Verus\, programmers express proofs and specifications using the Rust language\, allowing proofs to take advantage of Rust's linear types and borrow checking. We show how this allows proofs to manipulate linearly typed permissions that let Rust code safely manipulate memory\, pointers\, and concurrent resources. Verus organizes proofs and specifications using a novel mode system that distinguishes specifications\, which are not checked for linearity and borrowing\, from executable code and proofs\, which are checked for linearity and borrowing. We formalize Verus' linearity\, borrowing\, and modes in a small lambda calculus\, for which we prove type safety and termination of specifications and proofs. We demonstrate Verus on a series of examples\, including pointer-manipulating code (an xor-based doubly linked list)\, code with interior mutability\, and concurrent code.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T100000Z
DTEND:20231026T101800Z
DTSTAMP:20231021T100631Z
UID:462b1a65-1f9e-4800-8d43-b8e10e480b14@conf.researchr.org
CREATED:20230915T153134Z
SUMMARY:[SPLASH OOPSLA] The Essence of Verilog: A Tractable and Tested Operational Semantics for Verilog - Qinlin Chen\, Nairen Zhang\, Jinpeng Wang\, Tian Tan\, Chang Xu\, Xiaoxing Ma\, Yue Li
DESCRIPTION:With the increasing need to apply modern software techniques to hardware design\, Verilog\, the most popular Hardware Description Language (HDL)\, plays an infrastructure role. However\, Verilog has several semantic pitfalls that often confuse software and hardware developers. Although prior research on formal semantics for Verilog exists\, it is not comprehensive and has not fully addressed these issues. In this work\, we present a novel scheme inspired by previous work on defining core languages for software languages like JavaScript and Python. Specifically\, we define the formal semantics of Verilog using a core language called $\lambda_V$\, which captures the essence of Verilog using as few language structures as possible. $\lambda_V$ not only covers the most complete set of language features to date\, but also addresses the aforementioned pitfalls. We implemented $\lambda_V$ with about 27\,000 lines of Java code\, and comprehensively tested its totality and conformance with Verilog. As a reliable reference semantics\, $\lambda_V$ can detect semantic bugs in real-world Verilog simulators and expose ambiguities in Verilog's standard specification. Moreover\, as a useful core language\, $\lambda_V$ has the potential to facilitate the development of tools such as a state-space explorer and a concolic execution tool for Verilog.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T101800Z
DTEND:20231026T103600Z
DTSTAMP:20231021T100631Z
UID:3f08ac5e-04fc-46be-bfe7-d2d12cbb6ab8@conf.researchr.org
CREATED:20230915T153134Z
SUMMARY:[SPLASH OOPSLA] Regular Expression Matching using Bit Vector Automata - Alexis Le Glaunec\, Lingkun Kong\, Konstantinos Mamouras
DESCRIPTION:Regular expressions (regexes) are ubiquitous in modern software. There is a variety of implementation techniques for regex matching\, which can be roughly categorized as (1) relying on backtracking search\, or (2) being based on finite-state automata. The implementations that use backtracking are often chosen due to their ability to support advanced pattern-matching constructs. Unfortunately\, they are known to suffer from severe performance problems. For some regular expressions\, the running time for matching can be exponential in the size of the input text. In order to provide stronger guarantees of matching efficiency\, automata-based regex matching is the preferred choice. However\, even these regex engines may exhibit severe performance degradation for some patterns. The main reason for this is that regexes used in practice are not exclusively built from the classical regular constructs\, i.e.\, concatenation\, nondeterministic choice and Kleene's star. They involve additional constructs that provide succinctness and convenience of expression. The most common such construct is bounded repetition (also called counting)\, which describes the repetition of the pattern a fixed number of times. \nIn this paper\, we propose a new algorithm for the efficient matching of regular expressions that involve bounded repetition. Our algorithms are based on a new model of automata\, which we call nondeterministic bit vector automata (NBVA). This model is chosen to be expressively equivalent to nondeterministic counter automata with bounded counters\, a very natural model for expressing patterns with bounded repetition. We show that there is a class of regular expressions with bounded repetition that can be matched in time that is independent from the repetition bounds. Our algorithms are general enough to cover the vast majority of challenging bounded repetitions that arise in practice. We provide an implementation of our approach in a regex engine\, which we call BVA-Scan. We compare BVA-Scan against state-of-the-art regex engines on several real datasets.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T103600Z
DTEND:20231026T105400Z
DTSTAMP:20231021T100631Z
UID:88e4f780-f9c8-4062-a3d4-4f3d16f84a7c@conf.researchr.org
CREATED:20230915T153134Z
SUMMARY:[SPLASH OOPSLA] Bidirectional Object-Oriented Programming: Towards Programmatic and Direct Manipulation of Objects - Xing Zhang\, Guanchen Guo\, Xiao He\, Zhenjiang Hu
DESCRIPTION:Many bidirectional programming languages\, which are mainly functional and relational\, have been designed to support writing programs that run in both forward and backward directions. Nevertheless\, there is little study on the bidirectionalization of object-oriented languages that are more popular in practice. This paper presents the first bidirectional object-oriented language that supports programmatic and direct manipulation of objects. Specifically\, we carefully extend a core object-oriented language\, which has a standard forward evaluation semantics\, with backward updating semantics for class inheritance hierarchies and references. We formally prove that the bidirectional evaluation semantics satisfies the round-tripping properties if the output is altered consistently. To validate the utility of our approach\, we have developed a tool called BiOOP for generating HTML documents through bidirectional GUI design. We evaluate the expressiveness and effectiveness of BiOOP for HTML webpage development by reproducing ten classic object-oriented applications from a Java Swing tutorial and one large project from GitHub. The experimental results show the response time of direct manipulation programming on object-oriented programs that produce HTML webpages is acceptable for developers.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T105400Z
DTEND:20231026T111200Z
DTSTAMP:20231021T100631Z
UID:6738bbe8-21a7-419a-bc98-299678e4024c@conf.researchr.org
CREATED:20230915T153134Z
SUMMARY:[SPLASH OOPSLA] Bring Your Own Data Structures to Datalog - Arash Sahebolamri\, Langston Barrett\, Scott Moore\, Kristopher Micinski
DESCRIPTION:The restricted logic programming language Datalog has become a popular implementation target for deductive-analytic workloads including social-media analytics and program analysis. Modern Datalog engines compile Datalog rules to joins over explicit representations of relations—often B-trees or hash maps. While these modern engines have enabled high scalability in many application domains\, they have a crucial weakness: achieving the desired algorithmic complexity may be impossible due to representation-imposed overhead of the engine’s data structures. In this paper\, we present the "Bring Your Own Data Structures" (Byods) approach\, in the form of a DSL embedded in Rust. Using Byods\, an engineer writes logical rules which are implicitly parametric on the concrete data structure representation\; our implementation provides an interface to enable "bringing their own" data structures to represent relations\, which harmoniously interact with code generated by our compiler (implemented as Rust procedural macros). We formalize the semantics of Byods as an extension of Datalog’s\; our formalization captures the key properties demanded of data structures compatible with Byods\, including properties required for incrementalized (semi-naïve) evaluation. We detail many applications of the Byods approach\, implementing analyses requiring specialized data structures for transitive and equivalence relations to scale\, including an optimized version of the Rust borrow checker Polonius\; highly-parallel PageRank made possible by lattices\; and a large-scale analysis of LLVM utilizing index-sharing to scale. Our results show that Byods offers both improved algorithmic scalability (reduced time and/or space complexity) and runtimes competitive with state-of-the-art parallelizing Datalog solvers.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T111200Z
DTEND:20231026T113000Z
DTSTAMP:20231021T100631Z
UID:f7da580d-262c-4175-a703-54d56be2bce1@conf.researchr.org
CREATED:20230915T153134Z
SUMMARY:[SPLASH OOPSLA] Rhombus: A New Spin on Macros without All the Parentheses - Matthew Flatt\, Taylor Allred\, Nia Angle\, Stephen De Gabrielle\, Robert Bruce Findler\, Jack Firth\, Kiran Gopinathan\, Ben Greenman\, Siddhartha Kasivajhula\, Alex Knauth\, Jay McCarthy\, Sam Phillips\, Sorawee Porncharoenwase\, Jens Axel Søgaard\, Sam Tobin-Hochstadt
DESCRIPTION:Rhombus is a new language that is built on Racket. It offers the same kind of language extensibility as Racket itself\, but using traditional (infix) notation. Although Rhombus is far from the first language to support Lisp-style macros without Lisp-style parentheses\, Rhombus offers a novel synthesis of macro technology that is practical and expressive. A key element is the use of multiple binding spaces for context-specific sublanguages. For example\, expressions and pattern-matching forms can use the same operators with different meanings and without creating conflicts. Context-sensitive bindings\, in turn\, facilitate a language design that reduces the notational distance between the core language and macro facilities. For example\, repetitions can be defined and used in binding and expression contexts generally\, which enables a smoother transition from programming to metaprogramming. Finally\, since handling static information (such as types) is also a necessary part of growing macros beyond Lisp\, Rhombus includes support in its expansion protocol for communicating static information among bindings and expressions. The Rhombus implementation demonstrates that all of these pieces can work together in a coherent and user-friendly language.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T100000Z
DTEND:20231026T103000Z
DTSTAMP:20231021T100631Z
UID:fd3bf2f0-7321-4965-b66e-041032dea84d@conf.researchr.org
CREATED:20230907T154514Z
SUMMARY:[SPLASH Onward! Papers] Cloning And Beyond: A Quantum Solution to Duplicate Code - Samyak Jhaveri\, Alberto Krone-Martins\, Crista Lopes
DESCRIPTION:Quantum computers are becoming a reality. The advantage of quantum computing is that it has the potential to solve computationally several complex problems in a fixed amount time\, independent of the size of the problem. However\, the kinds of problems for which these computers are a good fit\, and the ways to express those problems\, are substantially different from the kinds of problems and expressions used in classical computing. Quantum annealers\, in particular\, are currently the most promising and available quantum computing devices in the short term. However\, they are also the most foreign compared to classical programs\, as they require a different kind of computational thinking. \nIn order to ease the transition into this new world of quantum computing\, we present a novel quantum approach to a well-known software problem: code clone detection. We express code clone detection as a subgraph isomorphism problem that is mapped into a quadratic optimization problem\, and solve it using a DWave quantum annealing computer. We developed a quantum annealing algorithm that compares Abstract Syntax Trees (AST) and reports an energy value that indicates how similar they are. \nThe motivation behind this research goes well beyond code duplicate detection: our approach paves the way into how to express software engineering problems as optimization problems that can be solved by quantum annealers.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071921Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T103000Z
DTEND:20231026T110000Z
DTSTAMP:20231021T100631Z
UID:b813d5d6-0f83-4532-a983-41c608059598@conf.researchr.org
CREATED:20230907T154514Z
SUMMARY:[SPLASH Onward! Papers] Towards an Industrial Stateful Software Rejuvenation Toolchain Using Model Learning - Mathijs Schuts\, Jozef Hooman
DESCRIPTION:We present our vision for creating an industrial legacy software rejuvenation toolchain. The goal is to semi automatically remove code smells from stateful software used in Cyber Physical Systems (CPS). Compared to existing tools that remove code smells\, our toolchain can remove more than one type of code smell. Additionally\, our approach supports multiple programming languages because we use abstract models obtained by means of model learning. Supporting more than one programming language is often lacking in state of art refactoring tools.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071921Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T110000Z
DTEND:20231026T113000Z
DTSTAMP:20231021T100631Z
UID:45930a56-7a61-48d5-9662-3724c64c230e@conf.researchr.org
CREATED:20230907T154514Z
SUMMARY:[SPLASH Onward! Papers] Concept-Centric Software Development: An Experience Report - Peter Wilczynski\, Taylor Gregoire-Wright\, Daniel Jackson
DESCRIPTION:Developers have long recognized the importance of the concepts underlying the systems they build\, and the primary role concepts play in shaping user experience. To date\, however\, concepts have tended to be only implicit in software design with development being organized instead around more concrete artifacts (such as wireframes and code modules). \nCompany-X\, a software company whose data analytics products are widely used by major corporations\, recently reworked its internal representation of its software development process to bring concepts to the center\, making explicit the concepts underlying its products\, how they are clustered\, used across applications\, and governed by teams. With a centralized repository of concepts\, Company-X engineers are able to align products more closely based on shared concepts\, evolve concepts in response to user needs\, and communicate more effectively with non-engineering groups within the company. \nThis paper reports on Company-X’s experiences to date\, analyzing both successes and challenges\, and offers advice to other organizations considering adopting a concept-centric approach to software development.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071921Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T130000Z
DTEND:20231026T131800Z
DTSTAMP:20231021T100631Z
UID:fd26da02-9a12-4e9c-8191-cf195d586e61@conf.researchr.org
CREATED:20230915T184644Z
SUMMARY:[SPLASH OOPSLA] Greedy Implicit Bounded Quantification - Chen Cui\, Shengyi Jiang\, Bruno C. d. S. Oliveira
DESCRIPTION:Mainstream object-oriented programming languages such as Java\, Scala\, C#\, or TypeScript have polymorphic type systems with subtyping and bounded quantification. Bounded quantification\, despite being a pervasive and widely used feature\, has attracted little research work on type-inference algorithms to support it. A notable exception is local type inference\, which is the basis of most current implementations of type inference for mainstream languages. However\, support for bounded quantification in local type inference has important restrictions\, and its non-algorithmic specification is complex. \nIn this paper\, we present a variant of kernel $F_{\le}$\, which is the canonical calculus with bounded quantification\, with implicit polymorphism. Our variant\, called $F_{\le}^b$\, comes with a declarative and an algorithmic formulation of the type system. The declarative type system is based on previous work on bidirectional typing for predicative higher-rank polymorphism and a greedy approach to implicit instantiation. This allows for a clear declarative specification where programs require few type annotations and enables implicit polymorphism where applications omit type parameters. Just as local type inference\, explicit type applications are also available in $F_{\le}^b$ if desired. This is useful to deal with impredicative instantiations\, which would not be allowed otherwise in $F_{\le}^b$. Due to the support for impredicative instantiations\, we can obtain a completeness result with respect to kernel $F_{\le}$\, showing that all the well-typed kernel $F_{\le}$ programs can type-check in $F_{\le}^b$. The corresponding algorithmic version of the type system is shown to be sound\, complete\, and decidable. All the results have been mechanically formalized in the Abella theorem prover.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T131800Z
DTEND:20231026T133600Z
DTSTAMP:20231021T100631Z
UID:79a64a80-265d-4b54-bd63-6bae2e6b18b5@conf.researchr.org
CREATED:20230915T184644Z
SUMMARY:[SPLASH OOPSLA] Structural Subtyping as Parametric Polymorphism - Wenhao Tang\, Daniel Hillerström\, James McKinna\, Michel Steuwer\, Ornela Dardha\, Rongxiao Fu\, Sam Lindley
DESCRIPTION:Structural subtyping and parametric polymorphism provide similar flexibility and reusability to programmers. For example\, both features enable the programmer to provide a wider record as an argument to a function that expects a narrower one. However\, the means by which they do so differs substantially\, and the precise details of the relationship between them exists\, at best\, as folklore in literature. \nIn this paper\, we systematically study the relative expressive power of structural subtyping and parametric polymorphism. We focus our investigation on establishing the extent to which parametric polymorphism\, in the form of row and presence polymorphism\, can encode structural subtyping for variant and record types. We base our study on various Church-style $\lambda$-calculi extended with records and variants\, different forms of structural subtyping\, and row and presence polymorphism. \nWe characterise expressiveness by exhibiting compositional translations between calculi. For each translation we prove a type preservation and operational correspondence result. We also prove a number of non-existence results. By imposing restrictions on both source and target types\, we reveal further subtleties in the expressiveness landscape\, the restrictions enabling otherwise impossible translations to be defined. More specifically\, we prove that full subtyping cannot be encoded via polymorphism\, but we show that several restricted forms of subtyping can be encoded via particular forms of polymorphism.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T133600Z
DTEND:20231026T135400Z
DTSTAMP:20231021T100631Z
UID:576ca814-e151-4b2a-bc87-d7cb2b2edf0c@conf.researchr.org
CREATED:20230915T184644Z
SUMMARY:[SPLASH OOPSLA] Simple Reference Immutability for System F<sub>&lt\;:</sub> - Edward Lee\, Ondřej Lhoták
DESCRIPTION:Reference immutability is a type based technique for taming mutation that has long been studied in the context of object-oriented languages\, like Java. Recently\, though\, languages like Scala have blurred the lines between functional programming languages and object oriented programming languages. We explore how reference immutability interacts with features commonly found in these hybrid languages\, in particular with higher-order functions – polymorphism – and subtyping. We construct a calculus System F&lt\;:M which encodes a reference immutability system as a simple extension of System F&lt\;: and prove that it satisfies the standard soundness and immutability safety properties.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T135400Z
DTEND:20231026T141200Z
DTSTAMP:20231021T100631Z
UID:40df3671-1ce9-48f0-b7d9-056959d4e105@conf.researchr.org
CREATED:20230915T184644Z
SUMMARY:[SPLASH OOPSLA] Mutually Iso-Recursive Subtyping - Andreas Rossberg
DESCRIPTION:Iso-recursive types are often taken as a type-theoretic model for type recursion as present in many programming languages\, e.g.\, classes in object-oriented languages or algebraic datatypes in functional languages. Their main advantage over an equi-recursive semantics is that they are simpler and algorithmically less expensive\, which is an important consideration when the cost of type checking matters\, such as for intermediate or low-level code representations\, virtual machines\, or runtime casts. However\, a closer look reveals that iso-recursion cannot\, in its standard form\, efficiently express essential type system features like mutual recursion or non-uniform recursion. While it has been folklore that mutual recursion and non-uniform type parameterisation can nicely be handled by generalising to higher kinds\, this encoding breaks down when combined with subtyping: the classic ``Amber'' rule for subtyping iso-recursive types is too weak to express mutual recursion without falling back to encodings of quadratic size. \nWe present a foundational core calculus of iso-recursive types with \emph{declared} subtyping that can express both inter- and intra-recursion subtyping without such blowup\, including subtyping between constructors of higher or mixed kind. In a second step\, we identify a syntactic fragment of this general calculus that allows for more efficient type checking without deep&amp\;#39\;&amp\;#39\; substitutions\, by observing that higher-kinded iso-recursive types can be inserted toguard'' against unwanted $\beta$-reductions. This fragment closely resembles the structure of typical nominal subtype systems\, but without requiring nominal semantics. It has been used as the basis for a proposed extension of WebAssembly with recursive types.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T141200Z
DTEND:20231026T143000Z
DTSTAMP:20231021T100631Z
UID:ba130b05-230b-4b18-b7de-4835b1dcedee@conf.researchr.org
CREATED:20230915T184644Z
SUMMARY:[SPLASH OOPSLA] Getting into the Flow: Towards Better Type Error Messages for Constraint-Based Type Inference - Ishan Bhanuka\, Lionel Parreaux\, David Binder\, Jonathan Immanuel Brachthäuser
DESCRIPTION:Creating good type error messages for constraint-based type inference systems is difficult. Typical type error messages reflect implementation details of the underlying constraint-solving algorithms rather than the specific factors leading to type mismatches. We propose using subtyping constraints that capture data flow to classify and explain type errors. Our algorithm explains type errors as faulty data flows\, which programmers are already used to reasoning about\, and illustrates these data flows as sequences of relevant program locations. We show that our ideas and algorithm are not limited to languages with subtyping\, as they can be readily integrated with Hindley-Milner type inference. In addition to these core contributions\, we present the results of a user study to evaluate the quality of our messages compared to other implementations. While the quantitative evaluation does not show that flow-based messages improve the localization or understanding of the causes of type errors\, the qualitative evaluation suggests a real need and demand for flow-based messages.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T130000Z
DTEND:20231026T131800Z
DTSTAMP:20231021T100631Z
UID:15a25c8a-bea3-44fa-b518-00044caaf591@conf.researchr.org
CREATED:20230912T183126Z
SUMMARY:[SPLASH OOPSLA] The Bounded Pathwidth of Control-Flow Graphs - Giovanna Kobus Conrado\, Amir Kafshdar Goharshady\, Chun Kit Lam
DESCRIPTION:Pathwidth and treewidth are standard and well-studied graph sparsity parameters which intuitively model the degree to which a given graph resembles a path or a tree\, respectively. It is well-known that the control-flow graphs of structured goto-free programs have a tree-like shape and bounded treewidth. This fact has been exploited to design considerably more efficient algorithms for a wide variety of static analysis and compiler optimization problems\, such as register allocation\, $\mu$-calculus model-checking and parity games\, data-flow analysis\, cache management\, and liftetime-optimal redundancy elimination. However\, there is no bound in the literature for the \emph{pathwidth} of programs\, except the general inequality that the pathwidth of a graph is at most $O(\lg n)$ times its treewidth\, where $n$ is the number of vertices of the graph. \nIn this work\, we prove that control-flow graphs of structured programs have bounded pathwidth and provide a linear-time algorithm to obtain a path decomposition of small width. Specifically\, we establish a bound of $2 \cdot d$ on the pathwidth of programs with nesting depth $d.$ Since real-world programs have small nesting depth\, they also have bounded pathwidth. This is significant for a number of reasons: (i)~pathwidth is a strictly stronger parameter than treewidth\, i.e.~any graph family with bounded pathwidth has bounded treewidth\, but the converse does not hold\; (ii)~any algorithm that is designed with treewidth in mind can be applied to bounded-pathwidth graphs with no change\; (iii)~there are problems that are fixed-parameter tractable with respect to pathwidth but not treewidth\; (iv)~verification algorithms that are designed based on treewidth would become significantly faster when using pathwidth as the parameter\; and (v)~it is easier to design algorithms based on bounded pathwidth since one does not have to consider the often-challenging case of merge nodes in treewidth-based dynamic programming. Thus\, we invite the static analysis and compiler optimization communities to adopt pathwidth as their parameter of choice instead of\, or in addition to\, treewidth. Intuitively\, control-flow graphs are not only tree-like\, but also path-like and one can obtain simpler and more scalable algorithms by relying on path-likeness instead of tree-likeness. \nAs a motivating example\, we provide a simpler and more efficient algorithm for spill-free register allocation using bounded pathwidth instead of treewidth. Our algorithm reduces the runtime from $O(n \cdot r^{{2 \cdot tw \cdot r + 2 \cdot r}})$ to $O(n \cdot pw \cdot r^{{pw\cdot r + r + 1}})$\, where $n$ is the number of lines of code\, $r$ is the number of registers\, $pw$ is the pathwidth of the control-flow graph and $tw$ is its treewidth. We provide extensive experimental results showing that our approach is applicable to a wide variety of real-world embedded benchmarks from SDCC and obtains runtime improvements of 2-3 orders of magnitude. This is because the pathwidth is equal to the treewidth\, or one more\, in the overwhelming majority of real-world CFGs and thus our algorithm provides an exponential runtime improvement. As such\, the benefits of using pathwidth are not limited to the theoretical side and simplicity in algorithm design\, but are also apparent in practice.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T131800Z
DTEND:20231026T133600Z
DTSTAMP:20231021T100632Z
UID:7830c4e1-d0ab-4998-b060-5f4227f1f0d5@conf.researchr.org
CREATED:20230912T183126Z
SUMMARY:[SPLASH OOPSLA] How Profilers Can Help Navigate Type Migration - Ben Greenman\, Matthias Felleisen\, Christos Dimoulas
DESCRIPTION:Sound migratory typing envisions a safe and smooth refactoring of untyped code bases to typed ones. However\, the cost of enforcing safety with run-time checks is often prohibitively high\, thus performance regressions are a likely occurrence. Additional types can often recover performance\, but choosing the right components to type is difficult because of the exponential size of the migratory typing lattice. In principal though\, migration could be guided by off-the-shelf profiling tools. To examine this hypothesis\, this paper follows the rational programmer method and reports on the results of an experiment on tens of thousands of performance-debugging scenarios via seventeen strategies for turning profiler output into an actionable next step. The most effective strategy is the use of deep types to eliminate the most costly boundaries between typed and untyped components\; this strategy succeeds in more than 50% of scenarios if two performance degradations are tolerable along the way.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T133600Z
DTEND:20231026T135400Z
DTSTAMP:20231021T100632Z
UID:07091252-06cc-49d5-ad16-b2011f3afd28@conf.researchr.org
CREATED:20230912T183126Z
SUMMARY:[SPLASH OOPSLA] Synthesizing Precise Static Analyzers for Automatic Differentiation - Jacob Laurel\, Siyuan Brant Qian\, Gagandeep Singh\, Sasa Misailovic
DESCRIPTION:We present Pasado\, a technique for synthesizing precise static analyzers for Automatic Differentiation. Our technique allows one to automatically construct a static analyzer specialized for the Chain Rule\, Product Rule\, and Quotient Rule computations for Automatic Differentiation in a way that abstracts all of the nonlinear operations of each respective rule simultaneously. By directly synthesizing an abstract transformer for the composite expressions of these 3 most common rules of AD\, we are able to obtain significant precision improvement compared to prior works which compose standard abstract transformers together suboptimally. We prove our synthesized static analyzers sound and additionally demonstrate the generality of our approach by instantiating these AD static analyzers with different nonlinear functions\, different abstract domains (both intervals and zonotopes) and both forward-mode and reverse-mode AD. \nWe evaluate Pasado on multiple case studies\, namely soundly computing bounds on a neural network’s local Lipschitz constant\, soundly bounding the sensitivities of financial models\, certifying monotonicity\, and lastly\, bounding sensitivities of the solutions of differential equations from climate science and chemistry for verified ranges of initial conditions and parameters. The local Lipschitz constants computed by Pasado on our largest CNN are up to 2750× more precise compared to the existing state-of-the-art zonotope analysis. The bounds obtained on the sensitivities of the climate\, chemical\, and financial differential equation solutions are between 1.31 − 2.81× more precise (on average) compared to a state-of-the-art zonotope analysis.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T135400Z
DTEND:20231026T141200Z
DTSTAMP:20231021T100632Z
UID:b8270354-9a55-4846-8200-13d5a13e3860@conf.researchr.org
CREATED:20230912T183126Z
SUMMARY:[SPLASH OOPSLA] A Container-Usage-Pattern-Based Context Debloating Approach for Object-Sensitive Pointer Analysis - Dongjie He\, Yujiang Gui\, Wei Li\, Yonggang Tao\, Changwei Zou\, Yulei Sui\, Jingling Xue
DESCRIPTION:In this paper\, we introduce DebloaterX\, a new approach for automatically identifying context-independent objects to debloat contexts in object-sensitive pointer analysis (kobj). Object sensitivity achieves high precision\, but its context construction mechanism combines objects with their contexts indiscriminately. This leads to a combinatorial explosion of contexts in large programs\, resulting in inefficiency. Previous research has proposed a context-debloating approach that inhibits a pre-selected set of context-independent objects from forming new contexts\, improving the efficiency of kobj. However\, this earlier context-debloating approach under-approximates the set of context-independent objects identified\, limiting performance speedups. \nWe introduce a novel context-debloating pre-analysis approach that identifies objects as context-dependent only when they are potentially precision-critical to kobj based on three general container-usage patterns. Our research finds that objects containing no fields of "abstract" (i.e.\, open) types can be analyzed context-insensitively with negligible precision loss in real-world applications. We provide clear rules and efficient algorithms to recognize these patterns\, selecting more context-independent objects for better debloating. We have implemented DebloaterX in the Qilin framework and will release it as an open-source tool. Our experimental results on 12 standard Java benchmarks and real-world programs show that DebloaterX selects 92.4% of objects to be context-independent on average\, enabling kobj to run significantly faster (an average of 19.3x when k = 2 and 150.2x when k = 3) and scale up to 8 more programs when k = 3\, with only a negligible loss of precision (less than 0.2%). Compared to state-of-the-art alternative pre-analyses in accelerating kobj\, DebloaterX outperforms Zipper significantly in both precision and efficiency and outperforms Conch (the earlier context-debloating approach) in efficiency substantially while achieving nearly the same precision.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T141200Z
DTEND:20231026T143000Z
DTSTAMP:20231021T100632Z
UID:30e188ed-2cf0-438a-b11a-12d14211f5b9@conf.researchr.org
CREATED:20230915T153323Z
SUMMARY:[SPLASH OOPSLA] Static Analysis of Memory Models for SMT Encodings - Thomas Haas\, René Maseli\, Roland Meyer\, Hernán Ponce de León
DESCRIPTION:The goal of this work is to improve the efficiency of bounded model checkers that are modular in the memory model. Our first contribution is a static analysis for the given memory model that is performed as a preprocessing step and helps us significantly reduce the encoding size. Memory model make use of relations to judge whether an execution is consistent. The analysis computes bounds on these relations: which pairs of events may or must be related. What is new is that the bounds are relativized to the execution of events. This makes it possible to derive\, for the first time\, not only upper but also meaningful lower bounds. Another important feature is that the analysis can import information about the verification instance from external sources to improve its precision. Our second contribution are new optimizations for the SMT encoding. Notably\, the lower bounds allow us to simplify the encoding of acyclicity constraints. We implemented our analysis and optimizations within a bounded model checker and evaluated it on challenging benchmarks. The evaluation shows up-to 40% reduction in verification time (including the analysis) over previous encodings. Our optimizations allow us to efficiently check safety\, liveness\, and data race freedom in Linux kernel code.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T130000Z
DTEND:20231026T134500Z
DTSTAMP:20231021T100632Z
UID:57850ea6-cbc3-4a0b-aa15-a66a40c0cd9f@conf.researchr.org
CREATED:20230907T154713Z
SUMMARY:[SPLASH Onward! Papers] Sharing a Perspective on the lambda-Calculus - Beniamino Accattoli
DESCRIPTION:The $\lambda$-calculus models the core of functional programming languages. This essay discusses a gap between the theory of the $\lambda$-calculus and functional languages\, namely the fact that the former does not give a status to \textit{sharing}\, the essential ingredient for efficiency in the lattter. \nThe essay overviews the perspective of the author\, who studied and studies sharing from various angles. In particular\, it explains how sharing impacts on the \textit{equational} and \textit{denotational} semantics of the $\lambda$-calculus\, breaking some expected properties\, and requiring the development of new\, richer semantics of the $\lambda$-calculus.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071928Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T134500Z
DTEND:20231026T143000Z
DTSTAMP:20231021T100632Z
UID:1222dbf9-3c45-49c0-a854-f9fd0649c33b@conf.researchr.org
CREATED:20230907T154713Z
SUMMARY:[SPLASH Onward! Papers] Whither Problem-Solving Environments? - Matthew Dinmore
DESCRIPTION:During the 1990s and first decade of the 2000s\, problem-solving environments (PSEs) were a topic of research among a community with the vision to create software systems “with all of the computational facilities necessary to solve a target class of problems.” Use of the term has since declined\, with fewer papers focused on core PSE research topics. What happened? Did we achieve the design vision for PSEs through other means – namely computational notebooks – or is there more to do? In this essay\, we explore the history and objectives of PSE research\, the rise of computational notebooks\, whether they achieve these objectives\, and why the time is right to renew our PSE research efforts.
LOCATION:Room VII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T071928Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T150000Z
DTEND:20231026T151800Z
DTSTAMP:20231021T100632Z
UID:0fa63ae6-1ddf-4241-8717-6e74fb56b0e0@conf.researchr.org
CREATED:20230915T152928Z
SUMMARY:[SPLASH OOPSLA] Fast and Efficient Boolean Unification for Hindley-Milner-Style Type and Effect Systems - Magnus Madsen\, Jaco van de Pol\, Troels Henriksen
DESCRIPTION:As type and effect systems become more expressive there is an increasing need for efficient type inference. We consider a polymorphic effect system based on Boolean formulas where inference requires Boolean unification. Since Boolean unification involves semantic equivalence\, conventional syntax-driven unification is insufficient. At the same time\, existing Boolean unification techniques are ill-suited for type inference. We propose a hybrid algorithm for solving Boolean unification queries based on Boole’s Successive Variable Elimination (SVE) algorithm. The proposed approach builds on several key observations regarding the Boolean unification queries encountered in practice\, including: (i) most queries are simple\, (ii) most queries involve a few flexible variables\, (iii) queries are likely to repeat due similar programming patterns\, and (iv) there is a long tail of complex queries. We exploit these observations to implement several strategies for formula minimization\, including ones based on tabling and binary decision diagrams. We implement the new hybrid approach in the Flix programming language. Experimental results show that by reducing the overhead of Boolean unification\, the compilation throughput increases from 8\,580 lines/sec to 15\,917 lines/sec corresponding to a 1.8x speed-up. Further\, the overhead on type and effect inference time is only 16% which corresponds to an overhead of less than 7% on total compilation time. We study the hybrid approach and demonstrate that each design choice improves performance.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T151800Z
DTEND:20231026T153600Z
DTSTAMP:20231021T100632Z
UID:880b7532-199c-4f28-b50e-32609056bde3@conf.researchr.org
CREATED:20230915T152928Z
SUMMARY:[SPLASH OOPSLA] From Capabilities to Regions: Enabling Efficient Compilation of Lexical Effect Handlers - Marius Müller\, Philipp Schuster\, Jonathan Lindegaard Starup\, Klaus Ostermann\, Jonathan Immanuel Brachthäuser
DESCRIPTION:Effect handlers are a high-level abstraction that enables programmers to use effects in a structured way. They have gained a lot of popularity within academia and subsequently also in industry. However\, the abstraction often comes with a significant runtime cost and there has been intensive research recently on how to reduce this price. \nA promising approach in this regard is to implement effect handlers using a CPS translation and to provide sufficient information about the nesting of handlers. With this information the CPS translation can decide how effects have to be lifted through handlers\, i.e.\, which handlers need to be skipped\, in order to handle the effect at the correct place. A structured way to make this information available is to use a calculus with a region system and explicit subregion evidence. Such calculi\, however\, are quite verbose\, which makes them impractical to use as a source-level language. \nWe present a method to infer the lifting information for a calculus underlying a source-level language. This calculus uses second-class capabilities for the safe use of effects. To do so\, we define a typed translation to a calculus with regions and evidence and we show that this lift-inference translation is typability- and semantics-preserving. On the one hand\, this exposes the precise relation between the second-class property and the structure given by regions. On the other hand\, it closes a gap in a compiler pipeline enabling efficient compilation of the source-level language. We have implemented lift inference in this compiler pipeline and conducted benchmarks which indicate that the approach is indeed working.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T153600Z
DTEND:20231026T155400Z
DTSTAMP:20231021T100632Z
UID:ba555ec4-dd04-451c-b7ca-e9d6354c5d03@conf.researchr.org
CREATED:20230915T152928Z
SUMMARY:[SPLASH OOPSLA] Gradual Typing for Effect Handlers - Max S. New\, Eric Giovannini\, Daniel R. Licata
DESCRIPTION:We present a gradually typed language\, GrEff\, with effects and handlers that supports migration from unchecked to checked effect typing. This serves as a simple model of the integration of an effect typing discipline with an existing effectful typed language that does not track fine-grained effect information. Our language supports a simple module system to model the programming model of gradual migration from unchecked to checked effect typing in the style of Typed Racket. \nThe surface language GrEff is given semantics by elaboration to a core language Core GrEff. We equip Core GrEff with an inequational theory for reasoning about the semantic error ordering and desired program equivalences for programming with effects and handlers. We derive an operational semantics for the language from the equations provable in the theory. We then show that the theory is sound by constructing an operational logical relations model to prove the graduality theorem. This extends prior work on embedding-projection pair models of gradual typing to handle effect typing and subtyping.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T155400Z
DTEND:20231026T161200Z
DTSTAMP:20231021T100632Z
UID:65380063-3e93-4bb3-a636-440f56c498fd@conf.researchr.org
CREATED:20230915T152928Z
SUMMARY:[SPLASH OOPSLA] When Concurrency Matters: Behaviour-Oriented Concurrency - Luke Cheeseman\, Matthew J. Parkinson\, Sylvan Clebsch\, Marios Kogias\, Sophia Drossopoulou\, David Chisnall\, Tobias Wrigstad\, Paul Liétar
DESCRIPTION:Expressing parallelism and coordination is central for modern concurrent programming. Many mechanisms exist for expressing both parallelism and coordination. However\, the design decisions for these two mechanisms are tightly intertwined. We believe that the interdependence of these two mechanisms should be recognised and achieved through a single\, powerful primitive. We are not the first to realise this: the prime example is actor model programming\, where parallelism arises through fine-grained decomposition of a program’s state into actors that are able to execute independently in parallel. However\, actor model programming has a serious pain point: updating multiple actors as a single atomic operation is a challenging task. We address this pain point by introducing a new concurrency paradigm: Behaviour-Oriented Concurrency (BoC). In BoC\, we are revisiting the fundamental concept of a behaviour to provide a more transactional concurrency model. BoC enables asynchronously creating atomic and ordered units of work with exclusive access to a collection of independent resources. In this paper\, we describe BoC informally in terms of examples\, which demonstrate the advantages of exclusive access to several independent resources\, as well as the need for ordering. We define it through a formal model. We demonstrate its practicality by implementing a C++ runtime. We argue its applicability through the Savina benchmark suite: benchmarks in this suite can be more compactly represented using BoC in place of Actors\, and we observe comparable\, if not better\, performance.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T161200Z
DTEND:20231026T163000Z
DTSTAMP:20231021T100632Z
UID:f42a960e-39a6-440b-a5f5-18d206eed483@conf.researchr.org
CREATED:20230915T152928Z
SUMMARY:[SPLASH OOPSLA] Continuing WebAssembly with Effect Handlers - Luna Phipps-Costin\, Andreas Rossberg\, Arjun Guha\, Daan Leijen\, Daniel Hillerström\, KC Sivaramakrishnan\, Matija Pretnar\, Sam Lindley
DESCRIPTION:WebAssembly (Wasm) is a low-level portable code format offering near native performance. It is intended as a compilation target for a wide variety of source languages. However\, Wasm provides no direct support for non-local control flow features such as async/await\, generators/iterators\, lightweight threads\, first-class continuations\, etc. This means that compilers for source languages with such features must ceremoniously transform whole source programs in order to target Wasm. \nWe present WasmFX an extension to Wasm which provides a universal target for non-local control features via effect handlers\, enabling compilers to translate such features directly into Wasm. Our extension is minimal and only adds three main instructions for creating\, suspending\, and resuming continuations. Moreover\, our primitive instructions are type-safe providing typed continuations which are well-aligned with the design principles of Wasm whose stacks are typed. We present a formal specification of WasmFX and show that the extension is sound. We have implemented WasmFX as an extension to the Wasm reference interpreter and also built a prototype WasmFX extension for Wasmtime\, a production-grade Wasm engine\, piggybacking on Wasmtime's existing fibers API. The preliminary performance results for our prototype are encouraging\, and we outline future plans to realise a native implementation.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T150000Z
DTEND:20231026T151800Z
DTSTAMP:20231021T100632Z
UID:489029ce-4f81-4d35-88f2-d2d08179fcb7@conf.researchr.org
CREATED:20230912T183537Z
SUMMARY:[SPLASH OOPSLA] Historia: Refuting Callback Reachability with Message-History Logics - Shawn Meier\, Sergio Mover\, Gowtham Kaki\, Bor-Yuh Evan Chang
DESCRIPTION:This paper considers the callback reachability problem — determining if a callback can be called by an event-driven framework in an unexpected state. Event-driven programming frameworks are pervasive for creating user-interactive applications (apps) on just about every modern platform. Control flow between callbacks is determined by the framework and largely opaque to the programmer. This opacity of the callback control flow not only causes difficulty for the programmer but is also difficult for those developing static analysis. Previous static analysis techniques address this opacity either by assuming an arbitrary framework implementation or attempting to eagerly specify all possible callback control flow\, but this is either too coarse to prove properties requiring callback-ordering constraints or too burdensome and tricky to get right. Instead\, we present a middle way where the callback control flow can be gradually refined in a targeted manner to prove assertions of interest. The key insight to get this middle way is by reasoning about the history of method invocations at the boundary between app and framework code — enabling a decoupling of the specification of callback control flow from the analysis of app code. We call the sequence of such boundary-method invocations message histories and develop message-history logics to do this reasoning. In particular\, we define the notion of an application-only transition system with boundary transitions\, a message-history program logic for programs with such transitions\, and a temporal specification logic for capturing callback control flow in a targeted and compositional manner. Then to utilize the logics in a goal-directed verifier\, we define a way to combine after-the-fact an assertion about message histories with a specification of callback control flow. We implemented a prototype message history-based verifier called Historia and provide evidence that our approach is uniquely capable of distinguishing between buggy and fixed versions on challenging examples drawn from real-world issues and that our targeted specification approach enables proving the absence of multi-callback bug patterns in real-world open-source Android apps.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T151800Z
DTEND:20231026T153600Z
DTSTAMP:20231021T100632Z
UID:f2d55624-6dd9-454e-b360-c5a65275fb49@conf.researchr.org
CREATED:20230912T183537Z
SUMMARY:[SPLASH OOPSLA] Exploiting the Sparseness of Control-Flow and Call Graphs for Efficient and On-Demand Algebraic Program Analysis - Giovanna Kobus Conrado\, Amir Kafshdar Goharshady\, Kerim Kochekov\, Yun Chen Tsai\, Ahmed Khaled Zaher
DESCRIPTION:Algebraic Program Analysis (APA) is a ubiquitous framework that has been employed as a unifying model for various problems in data-flow analysis\, termination analysis\, invariant generation\, predicate abstraction and a wide variety of other standard static analysis tasks. APA models program summaries as elements of a regular algebra $\alg.$ Suppose that a summary in $A$ is assigned to every transition of the program and that we aim to compute the effect of running the program starting at line $s$ and ending at line $t.$ APA first computes a regular expression $\regexp$ capturing all program paths of interest. In case of intraprocedural analysis\, $\regexp$ models all paths from $s$ to $t$\, whereas in the interprocedural case it models all interprocedurally-valid paths\, i.e.~paths that go back to the right caller function when a callee returns. This regular expression $\regexp$ is then interpreted over the algebra $\alg$ to obtain the desired result. Suppose the program has $n$ lines of code and each evaluation of an operation in the regular algebra takes $O(k)$ time. It is well-known that a single APA query\, or a set of queries with the same starting point $s\,$ can be answered in $O(n \cdot \alpha(n) \cdot k)\,$ where $\alpha$ is the inverse Ackermann function. \n	In this work\, we consider an on-demand setting for APA: the program is given in the input and can be preprocessed. The analysis has to then answer a large number of on-line queries\, each providing a pair $(s\, t)$ of program lines which are the start and end point of the query\, respectively. The goal is to avoid the significant cost of running a fresh APA instance for each query. Our main contribution is a series of algorithms that\, after a lightweight preprocessing of $O(n \cdot \lg n \cdot k)$\, answer each query in $O(k)$ time. In other words\, our preprocessing has almost the same asymptotic complexity as a single APA query\, except for a sub-logarithmic factor\, and then every future query is answered instantly\, i.e.~by a constant number of operations in the algebra. We achieve this remarkable speedup by relying on certain structural sparsity properties of control-flow and call graphs (CFGs and CGs). Specifically\, we exploit the fact that control-flow graphs of real-world programs have a tree-like structure and bounded treewidth and nesting depth and that their call graphs have small treedepth in comparison to the size of the program. Finally\, we provide experimental results demonstrating the effectiveness and efficiency of our approach and showing that it beats the runtime of classical APA by several orders of magnitude.\n
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T153600Z
DTEND:20231026T155400Z
DTSTAMP:20231021T100632Z
UID:00ecba17-b9c7-4bbd-99f3-21d5fec6fcc6@conf.researchr.org
CREATED:20230912T183537Z
SUMMARY:[SPLASH OOPSLA] A Cocktail Approach to Practical Call Graph Construction - Yuandao Cai\, Charles Zhang
DESCRIPTION:After decades of research\, constructing call graphs for modern C-based software remains either imprecise or inefficient when scaling up to the ever-growing complexity. The main culprit is the difficulty of resolving function pointers\, as precise pointer analyses are cubic in nature and become exponential when considering calling contexts. This paper takes a practical stance by first conducting a comprehensive empirical study of function pointer manipulations in the wild. By investigating 5355 indirect calls in five popular open-source systems\, we conclude that\, instead of the past uniform treatments for function pointers\, a cocktail approach can be more effective in “squeezing” the number of difficult pointers to a minimum using a potpourri of cheap methods. In particular\, we decompose the costs of constructing highly precise call graphs of big code by tailoring several increasingly precise algorithms and synergizing them into a concerted workflow. As a result\, many indirect calls can be precisely resolved in an efficient and principled fashion\, thereby reducing the final\, expensive refinements. This is\, in spirit\, similar to the well-known cocktail medical therapy. \nThe results are encouraging — our implemented prototype called Coral can achieve similar precision versus the previous field-\, flow-\, and context-sensitive Andersen-style call graph construction\, yet scale up to millions of lines of code for the first time\, to the best of our knowledge. Moreover\, by evaluating the produced call graphs through the lens of downstream clients (i.e.\, use-after-free detection\, thin slicing\, and directed grey-box fuzzing)\, the results show that Coral can dramatically improve their effectiveness for better vulnerability hunting\, understanding\, and reproduction. More excitingly\, we found twelve confirmed bugs (six impacted by indirect calls) in popular systems (e.g.\, MariaDB)\, spreading across multiple historical versions.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T155400Z
DTEND:20231026T161200Z
DTSTAMP:20231021T100632Z
UID:68c9c6ce-cab2-4f70-a6bd-aae2d069c30a@conf.researchr.org
CREATED:20230912T183537Z
SUMMARY:[SPLASH OOPSLA] Building Dynamic System Call Sandbox with Partial Order Analysis - Quan Zhang\, Chijin Zhou\, Yiwen Xu\, Zijing Yin\, Mingzhe Wang\, Zhuo Su\, Chengnian Sun\, Yu Jiang\, Jiaguang Sun
DESCRIPTION:Attack surface reduction is a security technique that secures the operating system by removing the unnecessary code or features of a program. By restricting the system calls that programs can use\, the system call sandbox is able to reduce the exposed attack surface of the operating system and prevent attackers from damaging it through vulnerable programs. Ideally\, programs should only retain access to system calls they require for normal execution. Many researchers focus on adopting static analysis to automatically restrict the system calls for each program. However\, these methods do not adjust the restriction policy along with program execution. Thus\, they need to permit all system calls required for program functionalities. \nWe observe that some system calls\, especially security-sensitive ones\, are used a few times in certain stages of a program's execution and then never used again. This motivates us to minimize the set of required system calls dynamically. In this paper\, we propose \Model\, which gradually disables access to unnecessary system calls throughout the program's execution. To accomplish this\, we utilize partial order analysis to transform the program into a partially ordered graph\, which enables efficient identification of the necessary system calls at any given point during program execution. Once a system call is no longer required by the program\, \Model can restrict it immediately. To evaluate \Model\, we applied it to seven widely-used programs with an average of 615 KLOC\, including web servers and databases. With partial order analysis\, \Model restricts an average of 23.50\, 16.86\, and 15.89 more system calls than the state-of-the-art Chestnut\, Temporal Specialization\, and the configuration-aware sandbox\, C2C\, respectively. For mitigating malicious exploitations\, on average\, \Model defeats 83.42% of 1726 exploitation payloads with only a 5.07% overhead.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T161200Z
DTEND:20231026T163000Z
DTSTAMP:20231021T100632Z
UID:dd03f60f-1b92-4dc8-a828-17d875a26443@conf.researchr.org
CREATED:20230915T153411Z
SUMMARY:[SPLASH OOPSLA] Improving Oracle-Guided Inductive Synthesis by Efficient Question Selection - Ruyi Ji\, Chaozhe Kong\, Yingfei Xiong\, Zhenjiang Hu
DESCRIPTION:Oracle-guided inductive synthesis (OGIS) is a widely-used framework to apply program synthesis techniques in practice. The question selection problem aims at reducing the number of iterations in OGIS by selecting a proper input for each OGIS iteration. Theoretically\, a question selector can generally improve the performance of OGIS solvers on both interactive and non-interactive tasks if it is not only effective for reducing iterations but also efficient. However\, all existing effective question selectors fail in satisfying the requirement of efficiency. To ensure effectiveness\, they convert the question selection problem into an optimization one\, which is difficult to solve within a short time. \nIn this paper\, we propose a novel question selector\, named \textit{LearnSy}. \textit{LearnSy} is both efficient and effective and thus achieves general improvement for OGIS solvers for the first time. Since we notice that the optimization tasks in previous studies are difficult because of the complex behavior of operators\, we estimate these behaviors in \textit{LearnSy} as simple random events. Subsequently\, we provide theoretical results for the precision of this estimation and design an efficient algorithm for its calculation. \nAccording to our evaluation\, when dealing with interactive tasks\, \textit{LearnSy} can offer competitive performance compared to existing selectors while being more efficient and more general. Moreover\, when working on non-interactive tasks\, \textit{LearnSy} can generally reduce the time cost of existing CEGIS solvers by up to $43.0%$.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T150000Z
DTEND:20231026T151800Z
DTSTAMP:20231021T100632Z
UID:03d6d464-a0bb-49c6-9d63-9ca0dfde24c0@conf.researchr.org
CREATED:20230918T151029Z
SUMMARY:[SPLASH OOPSLA] Graph IRs for Impure Higher-Order Languages: Making Aggressive Optimizations Affordable with Precise Effect Dependencies - Oliver Bračevac\, Guannan Wei\, Songlin Jia\, Supun Abeysinghe\, Yuxuan Jiang\, Yuyan Bao\, Tiark Rompf
DESCRIPTION:Graph-based intermediate representations (IRs) are widely used for powerful compiler optimizations\, either interprocedurally in pure functional languages\, or intraprocedurally in imperative languages. Yet so far\, no suitable graph IR exists for aggressive global optimizations in languages with both effects and higher-order functions: aliasing and indirect control transfers make it difficult to maintain sufficiently granular dependency information for optimizations to be effective. To close this long-standing gap\, we propose a novel typed graph IR combining a notion of reachability types with an expressive effect system to compute precise and granular effect dependencies at an affordable cost while supporting local reasoning and separate compilation. Our high-level graph IR imposes lexical structure to represent structured control flow and nesting\, enabling aggressive and yet inexpensive code motion and other optimizations for impure higher-order programs. We formalize the new graph IR based on a $\lambda$-calculus with a reachability type-and-effect system along with a specification of various optimizations. We present performance case studies for tensor loop fusion\, CUDA kernel fusion\, symbolic execution of LLVM IR\, and SQL query compilation in the Scala LMS compiler framework using the new graph IR. We observe significant speedups of up to 21$x$.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T151800Z
DTEND:20231026T153600Z
DTSTAMP:20231021T100632Z
UID:6d510fc4-1fbc-49ef-b6b4-88bd0d4523cc@conf.researchr.org
CREATED:20230918T151029Z
SUMMARY:[SPLASH OOPSLA] AST vs. Bytecode: Interpreters in the Age of Meta-Compilation - Octave Larose\, Sophie Kaleba\, Humphrey Burchell\, Stefan Marr
DESCRIPTION:Thanks to partial evaluation and meta-tracing\, it became practical to build language implementations that reach state-of-the-art peak performance by implementing only an interpreter. Systems such as RPython and GraalVM provide components such as a garbage collector and just-in-time compiler in a language-agnostic manner\, greatly reducing implementation effort. \nHowever\, meta-compilation-based language implementations still need to improve further to reach the low memory use and fast warmup behavior that custom-built systems provide. A key element in this endeavor is interpreter performance. Folklore tells us that bytecode interpreters are superior to abstract-syntax-tree (AST) interpreters both in terms of memory use and run-time performance. \nThis work assesses the trade-offs between AST and bytecode interpreters to verify common assumptions and whether they hold in the context of meta-compilation systems. We implemented four interpreters\, each an AST and a bytecode one using RPython and GraalVM. We keep the difference between the interpreters as small as feasible to be able to evaluate interpreter performance\, peak performance\, warmup\, memory use\, and the impact of individual optimizations. \nOur results show that both systems indeed reach performance close to Node.js/V8. Looking at interpreter-only performance\, our AST interpreters are on par with\, or even slightly faster than their bytecode counterparts. After just-in-time compilation\, the results are roughly on par. This means bytecode interpreters do not have their widely assumed performance advantage. However\, we can confirm that bytecodes are more compact in memory than ASTs\, which becomes relevant for larger applications. However\, for smaller applications\, we noticed that bytecode interpreters allocate more memory because boxing avoidance is not as applicable\, and because the bytecode interpreter structure requires memory\, e.g.\, for a reified stack. \nOur results show AST interpreters to be competitive on top of meta-compilation systems. Together with possible engineering benefits\, they should thus not be discounted so easily in favor of bytecode interpreters.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T153600Z
DTEND:20231026T155400Z
DTSTAMP:20231021T100632Z
UID:c25f233a-6941-4f20-a3ae-8f6057974736@conf.researchr.org
CREATED:20230918T151029Z
SUMMARY:[SPLASH OOPSLA] Reusing Just-in-Time Compiled Code - Meetesh Kalpesh Mehta\, Sebastián Krynski\, Hugo Musso Gualandi\, Manas Thakur\, Jan Vitek
DESCRIPTION:Most code is executed more than once. If not entire programs then libraries remain unchanged from one run to the next. Just-in-time compilers expend considerable effort gathering insights about code they compiled many times\, and often end up generating the same binary over and over again. We explore how to reuse compiled code across runs of different programs to reduce warm-up costs of dynamic languages. We propose to use \emph{speculative contextual dispatch} to select versions of functions from an \emph{off-line curated code repository}. That repository is a persistent database of previously compiled functions indexed by the context under which they were compiled. The repository is curated to remove redundant code and to optimize dispatch. We assess practicality by extending Ř\, a compiler for the R language\, and evaluating its performance. Our results suggest that the approach improves warmup times while preserving peak performance.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T155400Z
DTEND:20231026T161200Z
DTSTAMP:20231021T100632Z
UID:c2ce4538-a28b-42d8-906c-d8ade16ea417@conf.researchr.org
CREATED:20230918T151029Z
SUMMARY:[SPLASH OOPSLA] TASTyTruffle: Just-in-Time Specialization of Parametric Polymorphism - Matt D'Souza\, James You\, Ondřej Lhoták\, Aleksandar Prokopec
DESCRIPTION:Parametric polymorphism enables programmers to express algorithms independently of the types of values that they operate on. The approach used to implement parametric polymorphism can have important performance implications. One popular approach\, erasure\, uses a uniform representation for generic data\, which entails primitive boxing and other indirections that harm performance. Erasure destroys type information that could be used by language implementations to optimize generic code. \nWe present TASTyTruffle\, an implementation for a subset of the Scala programming language. Instead of JVM bytecode\, TASTyTruffle interprets Scala's TASTy intermediate representation\, a typed representation wherein generic types are not erased. TASTy's precise type information empowers TASTyTruffle to implement generic code more effectively. In particular\, it allows TASTyTruffle to reify types as run-time objects that can be passed around. Using reified types\, TASTyTruffle supports heterogeneous box-free representations for generic values. TASTyTruffle also uses reified types to specialize generic code\, producing monomorphic copies of generic code that can be easily and reliably optimized by its just-in-time (JIT) compiler. \nEmpirically\, TASTyTruffle is competitive with standard JVM implementations on a small set of benchmark programs\; when generic code is used with multiple types\, TASTyTruffle consistently outperforms the JVM. The precise type information in TASTy enables TASTyTruffle to find additional optimization opportunities that could not be uncovered with erased JVM bytecode.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T161200Z
DTEND:20231026T163000Z
DTSTAMP:20231021T100632Z
UID:7de9607b-5ac2-4e8a-853c-1dc1e1bb6b62@conf.researchr.org
CREATED:20230918T151029Z
SUMMARY:[SPLASH OOPSLA] Beacons: An End-to-End Compiler Framework for Predicting and Utilizing Dynamic Loop Characteristics - Girish Mururu\, Sharjeel Khan\, Bodhisatwa Chatterjee\, Chao Chen\, Chris Porter\, Ada Gavrilovska\, Santosh Pande
DESCRIPTION:Efficient management of shared resources is a critical problem in high-performance computing (HPC) environments. Existing workload management systems often promote non-sharing of resources among different co-executing applications to achieve performance isolation. Such schemes lead to poor resource utilization and suboptimal process throughput\, adversely affecting user productivity. Tackling this problem in a scalable fashion is extremely challenging\, since it requires the workload scheduler to possess an in-depth knowledge about various application resource requirements and runtime phases at fine granularities within individual applications. \nIn this work\, we show that \textit{applications' resource requirements and execution phase behaviour can be captured} in a scalable and lightweight manner at runtime by estimating important program artifacts termed as ``\textbf{dynamic loop characteristics}''. Specifically\, \textit{we propose a solution to the problem of efficient workload scheduling by designing a compiler and runtime cooperative framework that leverages novel loop-based compiler analysis for resource allocation}. \nWe present \textbf{Beacons Framework}\, an end-to-end compiler and scheduling framework\, that \textit{estimates} dynamic loop characteristics\, \textit{encapsulates} them in compiler-instrumented \textbf{beacons} in an application\, and \textit{broadcasts} them during application runtime\, for proactive workload scheduling. \textit{We focus on estimating four important loop characteristics}: \textbf{loop trip-count}\, \textbf{loop timing}\, \textbf{loop memory footprint}\, and \textbf{loop data-reuse behaviour}\, through a combination of compiler analysis and machine learning. \nThe novelty of the Beacons Framework also lies in its ability to tackle \textit{irregular loops that exhibit complex control flow with indeterminate loop bounds involving structure fields\, aliased variables and function calls}\, which are highly prevalent in modern workloads. At the backend\, Beacons Framework entails a \textit{proactive workload scheduler that leverages the runtime information to orchestrate aggressive process co-locations\, for maximizing resource concurrency\, without causing cache thrashing}. Our results show that Beacons Framework can predict different loop characteristics with an accuracy of \textbf{85%} to \textbf{95%} on average\, and the proactive scheduler obtains an average throughput improvement of \textbf{1.9x} (up to \textbf{3.2x}) over the state-of-the-art schedulers on an Amazon Graviton2 machine on consolidated workloads involving 1000-10000 co-executing processes\, across 51 benchmarks.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T163000Z
DTEND:20231026T183000Z
DTSTAMP:20231021T100632Z
UID:0c5bf8c7-cec9-43d3-b8b0-61af6afb9a6d@conf.researchr.org
CREATED:20231011T033122Z
SUMMARY:[SPLASH Student Research Competition] Partial Gradual Dependent Type Theory - Zhan Shi
DESCRIPTION:Gradual typing supports imprecise types in the type system\, allowing incremental migration from untyped code to typed in the same language. However\, the gradualization of dependent types is challenging\, as it complicates type checking\, introduces more runtime performance overhead\, and potentially breaks some crucial properties. The infamous no-go result by Lennon-Bertrand et al. shows that one may only choose two from normalization\, graduality\, and semantic conservativity\, while all of them are important and desirable. \nThis ongoing work proposes a gradual dependent type theory based on the Martin-Löf type theory\, called Partial Gradual Dependent Type Theory\, which is an attempt to challenge this impossibility. As a trade-off\, we impose restrictions on imprecise types to prevent the embedding of untyped lambda calculus. PGTT restricts entirely unknown types and only permits dynamic terms on the type indices. However\, it allows us to simplify runtime type checks into type parameter checks and elaborate the surface language into a static\, dependently typed language\, thereby reducing the performance overhead associated with gradual typing.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082523Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T163000Z
DTEND:20231026T183000Z
DTSTAMP:20231021T100632Z
UID:3775ec0a-928a-47bc-9857-a28c064666e6@conf.researchr.org
CREATED:20231011T033122Z
SUMMARY:[SPLASH Student Research Competition] Modular educational languages - Jesse Hoobergs
DESCRIPTION:Teaching novices to program is an unsolved problem. One part of the problem lies in the fact that industrial languages are used for teaching novices\, while they were not made for this purpose. I am designing a Programming Education Runtime System to easily create modular languages for education. This system utilizes object algebras\, trampolining and algebraic effects and handlers. It has been used to implement an interpreter for the Hedy programming language. This implementation has several important advantages over the existing one\, such as better debugging support and better integration with the Hedy platform.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082523Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T163000Z
DTEND:20231026T183000Z
DTSTAMP:20231021T100632Z
UID:4cc1db02-b872-4a74-aaa3-57b954f321a6@conf.researchr.org
CREATED:20231011T033122Z
SUMMARY:[SPLASH Student Research Competition] Clearing the Trail: Motivations for Maintenance Work in Open Source - Katrina Wilson
DESCRIPTION:Almost all software development projects rely heavily on open-source infrastructure. For instance\, 94% of respondents surveyed in the 2017 GitHub Open Source Survey reported using open source software (OSS) professionally. Despite their importance\, open-source projects are often abandoned due to maintainer disengagement. Thus\, introducing new maintainers to established projects is critical to the long-term sustainability of open-source projects. While there is significant research about why people create new OSS projects\, we have less of an understanding of the motivations behind joining and maintaining already-established OSS projects. \nOpen-source grey literature contrasts the thrill of creating a new project and solving problems with the burnout from triaging reported issues and responding to demands of seemingly entitled users. Furthermore\, open source maintenance is becoming less attractive and sustainable often due to a high volume of pull requests and negative contribution feedback. Additionally\, we suspect that the motivations behind open-source creation and maintenance work are different because volunteer literature suggests that volunteers’ motivations may depend on the type of volunteer work being done\, like comparing human services volunteering to public benefit volunteering. \nTo better understand the motivations behind these types of work\, our research is guided by the following question: How do the motivations behind doing creation and maintenance work differ for open-source contributors? \nThrough a literature review on volunteer motivation and surveys of open-source contributors\, we can improve the understanding of contributor motivation and the effectiveness of community and research efforts to attract\, support\, and sustain developer engagement in OSS.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082523Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T163000Z
DTEND:20231026T183000Z
DTSTAMP:20231021T100632Z
UID:75e52634-400e-41c4-84fd-c5e86db73b4c@conf.researchr.org
CREATED:20231011T033122Z
SUMMARY:[SPLASH Student Research Competition] Rose: Extensible Autodiff on the Web - Raven Rothkopf
DESCRIPTION:Automatic differentiation (autodiff) has become the backbone for a new wave of optimization-driven domains such as computer graphics and machine learning over the past decade. However\, existing autodiff systems face limitations\, either lacking support for in-browser development or failing to harness more recent\, compiler-based approaches to achieve both expressiveness and size-preserving differentiation. This work introduces Rose\, a portable\, extensible autodiff language that runs on the web. Through Rose\, we aim to increase accessibility to autodiff algorithms and empower end-user programming in optimization-driven domains. We plan to evaluate Rose by replacing the autodiff engines of real-world\, client-side optimization systems and assess the improvements on the computation power\, expressiveness\, and efficiency of such systems.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082523Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T163000Z
DTEND:20231026T183000Z
DTSTAMP:20231021T100632Z
UID:7a04ecfe-a143-48e0-8a62-5ef05577e22f@conf.researchr.org
CREATED:20231011T033122Z
SUMMARY:[SPLASH Student Research Competition] Historiographer: Strongly-Consistent Distributed Reactive Programming with Minimal Locking - Julia Freeman\, Timothy Zhou
DESCRIPTION:We propose a novel approach to distributed reactive prop- agation that provides strong consistency guarantees with minimal locking. This is achieved by decoupling propagation of the reactive graph from transaction execution\, utilizing reactive histories to avoid propagating in-progress results. We formally define soundness properties in terms of histories\, and sketch how our semantics upholds them. We implement Histogriographer\, a runtime incorporating our methods\, and conduct a preliminary evaluation demonstrating perfor- mance improvements of up to 38% on select benchmarks.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082523Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T163000Z
DTEND:20231026T183000Z
DTSTAMP:20231021T100632Z
UID:b1a8239c-4850-4666-9294-bf02a6632e13@conf.researchr.org
CREATED:20231011T033122Z
SUMMARY:[SPLASH Student Research Competition] Towards the formal verification of Wigderson's algorithm - Siraphob Phipathananunth
DESCRIPTION:We present progress towards the formal verification of Wigderson’s graph coloring algorithm in Coq. We have created a library of formalized graph theory that aims to bridge the literature gap between introductory material on Coq and large-scale formal developments\, while providing a motivating case study. Our library contains over 180 proven theorems. The development is at https://github.com/siraben/coq-wigderson.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082523Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T163000Z
DTEND:20231026T183000Z
DTSTAMP:20231021T100632Z
UID:b2010fda-8d59-413f-9c47-04805038e224@conf.researchr.org
CREATED:20231011T033122Z
SUMMARY:[SPLASH Student Research Competition] Design and implementation of facets of dynamic policies - Antonio Zegarelli
DESCRIPTION:In Information Flow Control (IFC) expressiveness\, i.e. being able to model multiple scenarios\, is a crucial aspect\, especially in the context of dynamically evolving security requirements. Those dynamic scenarios introduce complexities due to varying security interpretations. Broberg et al. identified “facets of dynamic policies”\, patterns of information flow that may be considered secure or insecure depending on the context. Typically\, most existing definitions of security conditions do not delve into the analysis of these facets\, making it difficult to model a wide range of scenarios. Therefore\, our research aims to establish a robust framework that facilitates the design and implementation of the different interpretations of facets within a single\, modular enforcement mechanism. We propose\, in Haskell\, an abstract definition of a monadic IFC mechanism\, that\, based on the instantiation\, can account for the different interpretations of facets. Our ongoing work involves the formalization of the respective security conditions\, the study of their combination and a LiquidHaskell proof mechanization. This with the aspiration to improve the reasoning about dynamic policies and their associated facets\, especially in the case of future extensions.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082523Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T163000Z
DTEND:20231026T183000Z
DTSTAMP:20231021T100632Z
UID:b64abe07-0259-4395-bfd1-92671d809a02@conf.researchr.org
CREATED:20231011T033122Z
SUMMARY:[SPLASH Student Research Competition] An optimal structure-aware code difference framework with MaxSAT-Solver - Haolin Ye
DESCRIPTION:The Abstract Syntax Tree (AST) serves as a pivotal representation of program codes\, offering a structured and hierarchical view of the program’s syntax. When developers modify code\, the underlying AST also evolves to reflect these changes. Tree-diff algorithms\, such as \truediff\cite{truediff} and \Gumtree {\textit{diff}}\cite{gumtree}\, are developed to compare different versions of the AST and identify the modifications made between them. However\, these heuristics are based on certain vertex matching methods that do not ensure optimality and preciseness. In this study\, I propose a novel tree-diff approach that utilizes a MaxSAT (\textit{Maximum satisfiability}) solver to address this issue. By encoding potential vertex matches and edges with associated costs as a tree-diff SAT problem\, the MaxSAT solver effectively minimizes the edit distance and reveals the optimal vertex matching plan.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082523Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231026T163000Z
DTEND:20231026T183000Z
DTSTAMP:20231021T100632Z
UID:ff3f0f3f-949a-48dc-b78b-264d33426957@conf.researchr.org
CREATED:20231011T033122Z
SUMMARY:[SPLASH Student Research Competition] Synthesizing Recursive Programs Through Dataflow Constraints - Marta Davila Mateu
DESCRIPTION:Despite great progress in recursive program synthesis\, state of the art approaches continue to have several limitations. Current recursive synthesizers are unable to invent auxiliary functions\, resulting in (a) the inability to synthesize mutually recursive functions\, (b) sensitivity to the provided auxiliary functions\, and (c) occasionally producing asymptotically sub-optimal implementations. In this paper\, we present an alternative approach where we recover a recursive program from a non-recursive implementation. We develop a system of constraints that characterizes patterns of data flow in recursive program unrollings. Combined with a generator of seed non-recursive circuits and an appropriate constraint solver\, these constraints will naturally form the basis of a general algorithm to synthesize recursive circuits.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231017T082523Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T083000Z
DTEND:20231027T093000Z
DTSTAMP:20231021T100632Z
UID:82126f7e-56c4-47eb-9f9f-9533b5334031@conf.researchr.org
CREATED:20230915T185019Z
SUMMARY:[SPLASH OOPSLA] All the Languages Together - Amal Ahmed
DESCRIPTION:Designers of typed programming languages commonly prove meta-theoretic properties such as type soundness and\, if applicable\, security properties such as noninterference\, for at least a core of their language. But any practical language implementation must provide some way of interoperating with code written in other languages – usually via a foreign-function interface (FFI) – which opens the door to new\, potentially unsafe and insecure\, behaviors that aren’t accounted for in the original type soundness or security proofs. Despite the prevalence of interoperability in practical software\, principled foundations for the end-to-end design\, implementation\, and verification of interoperability mechanisms have been largely neglected. \nIn this talk\, I’ll advocate a proof technique for ensuring soundness or security properties of practical languages\, which implement interoperability using glue code that mediates interaction between languages after compilation to a common lower-level intermediate representation (IR). This proof technique involves building a semantic intermediate representation: a semantic model of source-language types as relations on terms of the lower-level IR. Semantic IRs can be used to guide the design and implementation of sound FFIs and to verify that the IR glue code used to implement conversions ensures type soundness. More interestingly\, semantic IRs provide a basis for numerous avenues of future work on the principled design of language interoperability: how to support the inclusion of libraries whose behavior is foreign to the original language\, how to prove soundness and security properties that are robust to behaviors (attackers) outside of the semantic IR\, and how to develop a semantic-IR compiler backend that makes it easier to implement and verify sound or secure interoperability for a wide array of source languages.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T100000Z
DTEND:20231027T101800Z
DTSTAMP:20231021T100632Z
UID:60256deb-3405-4335-8757-bc629ab91898@conf.researchr.org
CREATED:20230912T185604Z
SUMMARY:[SPLASH OOPSLA] Solving Conditional Linear Recurrences for Program Verification: The Periodic Case - Chenglin Wang\, Fangzhen Lin
DESCRIPTION:In program verification\, one method for reasoning about loops is to convert them into sets of recurrences\, and then try to solve these recurrences by computing their closed-form solutions. While there are solvers for computing closed-form solutions to these recurrences\, their capabilities are limited when the recurrences have conditional expressions\, which arise when the body of a loop contains conditional statements. In this paper\, we take a step towards solving these recurrences. Specifically\, we consider what we call conditional linear recurrences and show that given such a recurrence and an initial value\, if the index sequence generated by the recurrence on the initial value is what we call ultimately periodic\, then it has a closed-form solution. However\, checking whether such a sequence is ultimately periodic is undecidable so we propose a heuristic "generate and verify" algorithm for checking the ultimate periodicity of the sequence and computing closed-form solutions at the same time. We implemented a solver based on this algorithm\, and our experiments show that a straightforward program verifier based on our solver and using the SMT solver Z3 is effective in verifying properties of many benchmark programs that contain conditional statements in their loops\, and compares favorably to other recurrence-based verification tools. Finally\, we also consider extending our results to computing closed-form solutions of recurrences with unknown initial values.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T101800Z
DTEND:20231027T103600Z
DTSTAMP:20231021T100632Z
UID:4f639983-9ddf-4bf6-882a-3b7a875e3343@conf.researchr.org
CREATED:20230912T185604Z
SUMMARY:[SPLASH OOPSLA] Melocoton: A Program Logic for Verified Interoperability Between OCaml and C - Armaël Guéneau\, Johannes Hostert\, Simon Spies\, Michael Sammler\, Lars Birkedal\, Derek Dreyer
DESCRIPTION:In recent years\, there has been tremendous progress on developing program logics for verifying the correctness of programs in a rich and diverse array of languages. Thus far\, however\, such logics have assumed that programs are written entirely in a single programming language. In practice\, this assumption rarely holds since programs are often composed of components written in different programming languages\, which interact with one another via some kind of foreign function interface (FFI). In this paper\, we take the first steps towards the goal of developing program logics for multi-language verification. Specifically\, we present Melocoton\, a multi-language program verification system for reasoning about OCaml\, C\, and their interactions through the OCaml FFI. Melocoton consists of the first formal semantics of (a large subset of) the OCaml FFI—previously only described in prose in the OCaml manual—as well as the first program logic to reason about the interactions of program components written in OCaml and C. Melocoton is fully mechanized in Coq on top of the Iris separation logic framework.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T103600Z
DTEND:20231027T105400Z
DTSTAMP:20231021T100632Z
UID:9e33e95a-5dc0-4a29-9955-435abadbf181@conf.researchr.org
CREATED:20230912T185604Z
SUMMARY:[SPLASH OOPSLA] Outcome Logic: A Unifying Foundation for Correctness and Incorrectness Reasoning - Noam Zilberstein\, Derek Dreyer\, Alexandra Silva
DESCRIPTION:Program logics for bug-finding (such as the recently introduced Incorrectness Logic) have framed correctness and incorrectness as dual concepts requiring different logical foundations. In this paper\, we argue that a single unified theory can be used for both correctness and incorrectness reasoning. We present Outcome Logic (OL)\, a novel generalization of Hoare Logic that is both monadic (to capture computational effects) and monoidal (to reason about outcomes and reachability). OL is guaranteed to find true bugs\, while retaining correctness reasoning abilities as well. To formalize the applicability of OL to both correctness and incorrectness\, we prove that any false OL specification can be disproven in OL itself. We also use our framework to reason about new types of incorrectness in non-deterministic and probabilistic programs. Given these advances\, we advocate for OL as a new foundational theory of correctness and incorrectness.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T105400Z
DTEND:20231027T111200Z
DTSTAMP:20231021T100632Z
UID:b1ac8b8a-e114-4510-8b37-e3de5f1a6a69@conf.researchr.org
CREATED:20230915T184741Z
SUMMARY:[SPLASH OOPSLA] Formal Abstractions for Packet Scheduling - Anshuman Mohan\, Yunhe Liu\, Nate Foster\, Tobias Kappé\, Dexter Kozen
DESCRIPTION:Early programming models for software-defined networking (SDN) focused on basic features for controlling network-wide forwarding paths\, but more recent work has considered richer features\, such as packet scheduling and queueing\, that affect performance. In particular\, \emph{PIFO trees}\, proposed by Sivaraman et al.\, offer a flexible and efficient primitive for \emph{programmable} packet scheduling. Prior work has shown that PIFO trees can express a wide range of practical algorithms including strict priority\, weighted fair queueing\, and hierarchical schemes. However\, the semantic properties of PIFO trees are not well understood. \nThis paper studies PIFO trees from a programming language perspective. We formalize the syntax and semantics of PIFO trees in an operational model that decouples the scheduling policy running on a tree from the topology of the tree. Building on this formalization\, we develop compilation algorithms that allow the behavior of a PIFO tree written against one topology to be realized using a tree with a different topology. Such a compiler could be used to optimize an implementation of PIFO trees\, or realize a logical PIFO tree on a target with a fixed topology baked into the hardware. To support experimentation\, we develop a software simulator for PIFO trees\, and we present case studies illustrating its behavior on standard and custom algorithms.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T111200Z
DTEND:20231027T113000Z
DTSTAMP:20231021T100632Z
UID:802a5b55-cc71-4015-ba1d-d1a440fe49fa@conf.researchr.org
CREATED:20230915T184741Z
SUMMARY:[SPLASH OOPSLA] P4R-Type: A Verified API for P4 Control Plane Programs - Jens Kanstrup Larsen\, Roberto Guanciale\, Philipp Haller\, Alceste Scalas
DESCRIPTION:Software-Defined Networking (SDN) significantly simplifies programming\, reconfiguring\, and optimizing network devices\, such as switches and routers. The \emph{de facto} standard for programming SDN devices is the P4 language. However\, the flexibility and power of P4\, and SDN more generally\, gives rise to important risks. As a number of incidents at major cloud providers have shown\, errors in SDN programs can compromise the availability of networks\, leaving them in a non-functional state. The focus of this paper are errors in control-plane programs that interact with P4-enabled network devices via the standardized P4Runtime API. For clients of the P4Runtime API it is easy to make mistakes that may lead to catastrophic failures\, despite the use of Google's Protocol Buffers as an interface definition language. \nThis paper proposes \texttt{P4R-Type}\, a novel verified P4Runtime API for Scala that performs static checks for P4 control plane operations\, ruling out mismatches between P4 tables\, allowed actions\, and action parameters. As a formal foundation of \texttt{P4R-Type}\, we present the $F_{\text{P4R}}$ calculus and its typing system\, which ensure that well-typed programs never get stuck by issuing invalid P4Runtime operations. We evaluate the safety and flexibility of \texttt{P4R-Type} with 3 case studies. To the best of our knowledge\, this is the first work that formalises P4Runtime control plane applications\, and a typing discipline ensuring the correctness of P4Runtime operations.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T100000Z
DTEND:20231027T101800Z
DTSTAMP:20231021T100632Z
UID:3382ba70-ab1e-4823-b812-eee50cd9f6ad@conf.researchr.org
CREATED:20230912T154453Z
SUMMARY:[SPLASH OOPSLA] Initializing Global Objects: Time and Order - Fengyun Liu\, Ondřej Lhoták\, David Hua\, Enze Xing
DESCRIPTION:Object-oriented programming has been bothered by an awkward feature for a long time: \textit{static members}. Static members not only compromise the conceptual integrity of object-oriented programming\, but also give rise to subtle initialization errors\, such as reading non-initialized fields and deadlocks. \nThe Scala programming language eliminated static members from the language\, replacing them with \emph{global objects} that present a unified object-oriented programming model. However\, the problem of global object initialization remains open\, and programmers still suffer from initialization errors. \nWe propose \textit{partial ordering} and \textit{initialization-time irrelevance} as two fundamental principles for initializing global objects. Based on these principles\, we put forward an effective static analysis to ensure safe initialization of global objects\, which eliminates initialization errors at compile time. The analysis also enables static scheduling of global object initialization to avoid runtime overhead. The analysis is modular at the granularity of objects and it avoids whole-program analysis. To make the analysis explainable and tunable\, we introduce the concept of \textit{regions} to make context-sensitivity understandable and customizable by programmers.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T101800Z
DTEND:20231027T103600Z
DTSTAMP:20231021T100632Z
UID:03abea89-570f-4477-82a8-94fd8424ee75@conf.researchr.org
CREATED:20230912T154453Z
SUMMARY:[SPLASH OOPSLA] Type-Safe Dynamic Placement with First-Class Placed Values - George Zakhour\, Pascal Weisenburger\, Guido Salvaneschi
DESCRIPTION:Several distributed programming language solutions have been proposed to reason about the placement of data\, computations\, and peers interaction. Such solutions include\, among the others\, multitier programming\, choreographic programming and various approaches based on behavioral types. These methods statically ensure safety properties thanks to a complete knowledge about placement of data and computation at compile time. In distributed systems\, however\, dynamic placement of computation and data is crucial to enable performance optimizations\, e.g.\, driven by data locality or in presence of a number of other constraints such as security and compliance regarding data storage location. Unfortunately\, in existing programming languages\, dynamic placement conflicts with static reasoning about distributed programs: the flexibility required by dynamic placement hinders statically tracking the location of data and computation. \nIn this paper we present Dyno\, a programming language that enables static reasoning about dynamic placement. Dyno features a type system where values are explicitly placed\, but in contrast to existing approaches\, placed values are also first class\, ensuring that they can be passed around and referred to from other locations. Building on top of this mechanism\, we provide a novel interpretation of dynamic placement as unions of placement types. We formalize type soundness\, placement correctness (as part of type soundness) and architecture conformance. In case studies and benchmarks\, our evaluation shows that Dyno enables static reasoning about programs even in presence of dynamic placement\, ensuring type safety and placement correctness of programs at negligible performance cost. We reimplement an Android app with ∼ 7 K LOC in Dyno\, find a bug in the existing implementation\, and show that the app's approach is representative of a common way to implement dynamic placement found in over 100 apps in a large open-source app store.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T103600Z
DTEND:20231027T105400Z
DTSTAMP:20231021T100632Z
UID:90b62fa2-c0df-4daa-9d15-e77179b17dad@conf.researchr.org
CREATED:20230912T154453Z
SUMMARY:[SPLASH OOPSLA] Secure RDTs: Enforcing Access Control Policies for Offline Available JSON Data - Thierry Renaux\, Sam Van den Vonder\, Wolfgang De Meuter
DESCRIPTION:Replicated Data Types (RDTs) are a type of data structure that can be replicated over a network\, where each replica can be kept (eventually) consistent with the other replicas. They are used in applications with intermittent network connectivity\, since local (offline) edits can later be merged with the other replicas. Applications that want to use RDTs often have an inherent security component that restricts data access for certain clients. However\, access control for RDTs is difficult to enforce for clients that are not running within a secure environment\, e.g.\, web applications where the client-side software can be freely tampered with. In essence\, an application cannot prevent a client from reading data which they are not supposed to read\, and any malicious changes will also affect well-behaved clients. \nThis paper proposes Secure RDTs (SRDTs)\, a data type that specifies role-based access control for offline-available JSON data. In brief\, a trusted application server specifies a security policy based on roles with read and write privileges for certain fields of an SRDT. The server enforces read privileges by projecting the data and security policy to omit any non-readable fields for the user's given role\, and it acts as an intermediary to enforce write privileges. The approach is presented as an operational semantics engineered in PLT Redex\, which is validated by formal proofs and randomised testing in Redex to ensure that the formal specification is secure.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T105400Z
DTEND:20231027T111200Z
DTSTAMP:20231021T100632Z
UID:b29fb330-4791-41f2-b535-f62df2dc95d7@conf.researchr.org
CREATED:20230915T152341Z
SUMMARY:[SPLASH OOPSLA] AtomiS: Data-Centric Synchronization Made Practical - Hervé Paulino\, Ana Almeida Matos\, Jan Cederquist\, Marco Giunti\, João Batista Pereira Matos Júnior\, António Ravara
DESCRIPTION:Data-Centric Synchronization (DCS) shifts the reasoning about concurrency restrictions from control structures to data declaration. It is a high-level declarative approach that abstracts away from the actual concurrency control mechanism(s) in use. Despite its advantages\, the practical use of DCS is hindered by the fact that it may require many annotations and/or multiple implementations of the same method to cope with differently qualified parameters. \nTo overcome these limitations\, in this paper we present AtomiS\, a new DCS approach that requires only qualifying types of parameters and return values in interface definitions\, and of fields in class definitions. The latter may also be abstracted away in type parameters\, rendering class implementations virtually annotation-free. From this high level specification\, a static analysis infers the atomicity constraints that are local to each method\, considering valid only the method variants that are consistent with the specification\, and performs code generation for all valid variants of each method. The generated code is then the target for automatic injection of concurrency control primitives that are responsible for ensuring the absence of data-races\, atomicity-violations and deadlocks. \nWe provide a Java implementation and showcase the applicability of AtomiS in real-life code. For the benchmarks analysed\, AtomiS requires fewer annotations than the original number of regions requiring locks\, as well as fewer annotations than Atomic Sets (a reference DCS proposal).
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T111200Z
DTEND:20231027T113000Z
DTSTAMP:20231021T100632Z
UID:0fd6f205-57fc-4cbb-9694-06c7c3498080@conf.researchr.org
CREATED:20230917T153258Z
SUMMARY:[SPLASH OOPSLA] Enabling Bounded Verification of Doubly-Unbounded Distributed Agreement-Based Systems via Bounded Regions - Christopher Wagner\, Nouraldin Jaber\, Roopsha Samanta
DESCRIPTION:The ubiquity of distributed agreement protocols\, such as consensus\, has galvanized interest in verification of such protocols as well as applications built on top of them. The complexity and unboundedness of such systems\, however\, makes their verification onerous in general\, and\, particularly prohibitive for full automation. An exciting\, recent breakthrough reveals that\, through careful modeling\, it becomes possible to reduce verification of interesting distributed agreement-based (DAB) systems\, that are unbounded in the number of processes\, to model checking of small\, finite-state systems. It is an open question if such reductions are also possible for DAB systems that are doubly-unbounded\, in particular\, DAB systems that additionally have unbounded data domains. We answer this question in the affirmative in this work thereby broadening the class of DAB systems which can be automatically and efficiently verified. We present a novel reduction which leverages value symmetry and a new notion of data saturation to reduce verification of doubly-unbounded DAB systems to model checking of small\, finite-state systems. We develop a tool\, Venus\, that can efficiently verify sophisticated DAB system models such as the arbitration mechanism for a consortium blockchain\, a distributed register\, and a simple key-value store.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T100000Z
DTEND:20231027T101800Z
DTSTAMP:20231021T100632Z
UID:c0352b77-df34-48a5-bc49-ab87e7f5b716@conf.researchr.org
CREATED:20231001T111524Z
SUMMARY:[SPLASH OOPSLA] Towards Better Semantics Exploration for Browser Fuzzing - Chijin Zhou\, Quan Zhang\, Lihua Guo\, Mingzhe Wang\, Yu Jiang\, Qing Liao\, Zhiyong Wu\, Shanshan Li\, Bin Gu
DESCRIPTION:Web browsers exhibit rich semantics that enable a plethora of web-based functionalities. However\, these intricate semantics present significant challenges for the implementation and testing of browsers. For example\, fuzzing\, a widely adopted testing technique\, typically relies on handwritten context-free grammars (CFGs) for automatically generating inputs. However\, these CFGs fall short in adequately modeling the complex semantics of browsers\, resulting in generated inputs that cover only a portion of the semantics and are prone to semantic errors. In this paper\, we present SaGe\, an automated method that enhances browser fuzzing through the use of production-context sensitive grammars (PCSGs) incorporating semantic information. Our approach begins by extracting a rudimentary CFG from W3C standards and iteratively enhancing it to create a PCSG. The resulting PCSG enables our fuzzer to generate inputs that explore a broader range of browser semantics with a higher proportion of semantically-correct inputs. To evaluate the efficacy of SaGe\, we conducted 24-hour fuzzing campaigns on mainstream browsers\, including Chrome\, Safari\, and Firefox. Our approach demonstrated better performance compared to existing browser fuzzers\, with a 6.03%-277.80% improvement in edge coverage\, a 3.56%-161.71% boost in semantic correctness rate\, twice the number of bugs discovered. Moreover\, we identified 62 bugs across the three browsers\, with 40 confirmed and 10 assigned CVEs.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T101800Z
DTEND:20231027T103600Z
DTSTAMP:20231021T100632Z
UID:27d5977f-87ad-499d-9741-f7a7d0d688f8@conf.researchr.org
CREATED:20231001T111524Z
SUMMARY:[SPLASH OOPSLA] Live Pattern Matching with Typed Holes - Yongwei Yuan\, Scott Guest\, Eric Griffis\, Hannah Potter\, David Moon\, Cyrus Omar
DESCRIPTION:Several modern programming systems\, including GHC Haskell\, Agda\, Idris\, and Hazel\, support \emph{typed holes}. Assigning static and\, to varying degree\, dynamic meaning to programs with holes allows program editors and other tools to offer meaningful feedback and assistance throughout editing\, i.e. in a \emph{live} manner. Prior work\, however\, has considered only holes appearing in expressions and types. This paper considers\, from type theoretic and logical first principles\, the problem of typed pattern holes. We confront two main difficulties\, (1) statically reasoning about exhaustiveness and irredundancy when patterns are not fully known\, and (2) live evaluation of expressions containing both pattern and expression holes. In both cases\, this requires reasoning conservatively about all possible hole fillings. We develop a typed lambda calculus\, Peanut\, where reasoning about exhaustiveness and redundancy is mapped to the problem of deriving first order entailments. We equip Peanut with an operational semantics in the style of Hazelnut Live that allows us to evaluate around holes in both expressions and patterns. We mechanize the metatheory of Peanut in Agda and formalize a procedure capable of deciding the necessary entailments. Finally\, we scale up and implement these mechanisms within Hazel\, a programming environment for a dialect of Elm that automatically inserts holes during editing to provide static and dynamic feedback to the programmer in a maximally live manner\, i.e. for every possible editor state. Hazel is the first maximally live environment for a general-purpose functional language.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T103600Z
DTEND:20231027T105400Z
DTSTAMP:20231021T100632Z
UID:9dc37975-3027-4def-b41e-6bc82b2217c4@conf.researchr.org
CREATED:20231001T111524Z
SUMMARY:[SPLASH OOPSLA] Interactive Debugging of Datalog Programs - André Pacak\, Sebastian Erdweg
DESCRIPTION:Datalog is used for complex programming tasks nowadays\, consisting of numerous inter-dependent predicates. But Datalog lacks interactive debugging techniques that support the stepwise execution and inspection of the execution state. In this paper\, we propose interactive debugging of Datalog programs following a top-down evaluation strategy called recursive query/subquery. While the recursive query/subquery approach is well-known in the literature\, we are the first to provide a complete programming-language semantics based on it. Specifically\, we develop the first small-step operational semantics for top-down Datalog\, where subqueries occur as nested intermediate terms. The small-step semantics forms the basis of step-into interactions in the debugger. Moreover\, we show how step-over interactions can be realized efficiently based on a hybrid Datalog semantics that adds a bottom-up database to our top-down operational semantics. We implemented a debugger for core Datalog following these semantics and explain how to adopt it for debugging the frontend languages of Soufflé and IncA. Our evaluation shows that our hybrid Datalog semantics can be used to debug real-world Datalog programs with realistic workloads.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T105400Z
DTEND:20231027T111200Z
DTSTAMP:20231021T100632Z
UID:c723a893-65b5-44b9-8595-3cfd649f0ca9@conf.researchr.org
CREATED:20231001T111524Z
SUMMARY:[SPLASH OOPSLA] Accelerating Fuzzing through Prefix-Guided Execution - Shaohua Li\, Zhendong Su
DESCRIPTION:Coverage-guided fuzzing is one of the most effective approaches for discovering software defects and vulnerabilities. It executes all mutated tests from seed inputs to expose coverage-increasing tests. However\, executing all mutated tests incurs significant performance penalties—most of the mutated tests are discarded because they do not increase code coverage. Thus\, determining if a test increases code coverage without actually executing it is beneficial\, but a paradoxical challenge. In this paper\, we introduce the notion of prefix-guided execution (PGE) to tackle this challenge. PGE leverages two key observations: (1) Only a tiny fraction of the mutated tests increase coverage\, thus requiring full execution\; and (2) whether a test increases coverage may be accurately inferred from its partial execution. PGE monitors the execution of a test and applies early termination when the execution prefix indicates that the test is unlikely to increase coverage. \nTo demonstrate the potential of PGE\, we implement a prototype on top of AFL++\, which we call AFL++-PGE. We evaluate AFL++-PGE on MAGMA\, a ground-truth benchmark set that consists of 21 programs from nine popular real-world projects. Our results show that\, after 48 hours of fuzzing\, AFL++-PGE finds more bugs\, discovers bugs faster\, and achieves higher coverage. Prefix-guided execution is general and can benefit the AFL-based family of fuzzers.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T111200Z
DTEND:20231027T113000Z
DTSTAMP:20231021T100632Z
UID:71957c92-03f0-44ae-a3fd-386c4cba68af@conf.researchr.org
CREATED:20231001T111524Z
SUMMARY:[SPLASH OOPSLA] MemPerf: Profiling Allocator-Induced Performance Slowdowns - Jin Zhou\, Sam Silvestro\, Steven (Jiaxun) Tang\, Hanmei Yang\, Hongyu Liu\, Guangming Zeng\, Bo Wu\, Cong Liu\, Tongping Liu
DESCRIPTION:The memory allocator plays a key role in the performance of applications\, but none of the existing profilers can pinpoint performance slowdowns caused by a memory allocator. Consequently\, programmers may spend time improving application code incorrectly or unnecessarily\, achieving low or no performance improvement. This paper designs the first profiler—MemPerf—to identify allocator-induced performance slowdowns without comparing against another allocator. Based on the key observation that an allocator may impact the whole life-cycle of heap objects\, including the accesses (or uses) of these objects\, MemPerf proposes a life-cycle based detection to identify slowdowns caused by slow memory management operations and slow accesses separately. For the prior one\, MemPerf proposes a thread-aware and type-aware performance modeling to identify slow management operations. For slow memory accesses\, MemPerf utilizes a top-down approach to identify all possible reasons for slow memory accesses introduced by the allocator\, mainly due to cache and TLB misses\, and further proposes a unified method to identify them correctly and efficiently. Based on our extensive evaluation\, MemPerf reports 98% medium and large allocator-reduced slowdowns (larger than 5%) correctly without reporting any false positives. MemPerf also pinpoints multiple known and unknown design issues in widely-used allocators.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T130000Z
DTEND:20231027T131800Z
DTSTAMP:20231021T100632Z
UID:fecd8f35-ad3e-4b18-b6b3-b742fb5b38b2@conf.researchr.org
CREATED:20230912T185629Z
SUMMARY:[SPLASH OOPSLA] Stuttering for Free - Minki Cho\, Youngju Song\, Dongjae Lee\, Lennard Gäher\, Derek Dreyer
DESCRIPTION:One of the most common tools for proving behavioral refinements between transition systems is the method of \emph{simulation} proofs\, which has been explored extensively over the past several decades. Stuttering simulations are an extension of traditional simulations—used\, for example\, in CompCert—in which either the source or target of the simulation is permitted to ``stutter'' (stay in place) while the other side steps forward. In the interest of ensuring soundness\, however\, existing stuttering simulations restrict proofs to only perform a finite number of stuttering steps before making \emph{synchronous progress}—a step of reasoning in which both sides of the simulation progress forward together. This restriction guarantees that a terminating program cannot be proven to simulate a non-terminating one. \nIn this paper\, we observe that the requirement to eventually achieve synchronous progress is burdensome and\, what's more\, unnecessary: it is possible to ensure soundness of stuttering simulations while only requiring \emph{asynchronous progress} (progress on both sides of the simulation that may be achieved with only stuttering steps). Building on this observation\, we develop a new simulation technique we call \textbf{FreeSim} (short for ``freely-stuttering simulations'')\, mechanized in Coq\, and we demonstrate its effectiveness on a range of interesting case studies. These include a simplification of the meta-theory of CompCert\, as well as the \textbf{DTrees} library\, which enriches the ITrees (Interaction Trees) library with dual non-determinism.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T131800Z
DTEND:20231027T133600Z
DTSTAMP:20231021T100632Z
UID:2e43ba55-bb75-469a-8d28-3f44ec85c52b@conf.researchr.org
CREATED:20230912T185629Z
SUMMARY:[SPLASH OOPSLA] Generating Proof Certificates for a Language-Agnostic Deductive Program Verifier - Zhengyao Lin\, Xiaohong Chen\, Minh-Thai Trinh\, John Wang\, Grigore Roşu
DESCRIPTION:Previous work on rewriting and reachability logic establishes a vision for a language-agnostic program verifier\, which takes three inputs: a program\, its formal specification\, and the formal semantics of the programming language in which the program is written. The verifier then uses a language-agnostic verification algorithm to prove the program correct with respect to the specification and the formal language semantics. Such a complex verifier can easily have bugs. This paper proposes a method to certify the correctness of each successful verification run by generating a proof certificate. The proof certificate can be checked by a small proof checker. The preliminary experiments apply the method to generate proof certificates for program verification in an imperative language\, a functional language\, and an assembly language\, showing that the proposed method is language-agnostic.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T133600Z
DTEND:20231027T135400Z
DTSTAMP:20231021T100632Z
UID:31535c65-15b0-470a-ad58-983e0189e300@conf.researchr.org
CREATED:20230912T185629Z
SUMMARY:[SPLASH OOPSLA] Complete First-Order Reasoning for Properties of Functional Programs - Adithya Murali\, Lucas Peña\, Ranjit Jhala\, P. Madhusudan
DESCRIPTION:Several practical tools for automatically verifying functional programs (e.g.\, Liquid Haskell and Leon for Scala programs) rely on a heuristic based on unrolling recursive function definitions followed by quantifier-free reasoning using SMT solvers. We uncover foundational theoretical properties of this heuristic\, revealing that it can be generalized and formalized as a technique that is in fact &lt\;i&gt\;complete&lt\;/i&gt\; for reasoning with combined First-Order theories of algebraic datatypes and background theories\, where background theories support decidable quantifier-free reasoning. The theory developed in this paper explains the efficacy of these heuristics when they succeed\, explain why they fail when they fail\, and the precise role that user help plays in making proofs succeed.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T135400Z
DTEND:20231027T141200Z
DTSTAMP:20231021T100632Z
UID:727a576d-07e0-4bcd-ba81-25654cfded8a@conf.researchr.org
CREATED:20230915T184856Z
SUMMARY:[SPLASH OOPSLA] Counterexample Driven Quantifier Instantiations with Applications to Distributed Protocols - Orr Tamir\, Marcelo Taube\, Kenneth L. McMillan\, Sharon Shoham\, Jon Howell\, Guy Gueta\, Mooly Sagiv
DESCRIPTION:Formally verifying infinite-state systems can be a daunting task\, especially when it comes to reasoning about quantifiers. In particular\, quantifier alternations in conjunction with function symbols can create function cycles that result in infinitely many ground terms\, making it difficult for solvers to instantiate quantifiers and causing them to diverge. This can leave users with no useful information on how to proceed. \nTo address this issue\, we propose an interactive verification methodology that uses a relational abstraction technique to mitigate solver divergence in the presence of quantifiers. This technique abstracts functions in the verification conditions (VCs) as one-to-one relations\, which avoids the creation of function cycles and the resulting proliferation of ground terms. \nRelational abstraction is sound and guarantees correctness if the solver cannot find counter-models. However\, it may also lead to false counterexamples\, which can be addressed by refining the abstraction and requiring the existence of corresponding elements. In the domain of distributed protocols\, we can refine the abstraction by diagnosing counterexamples and manually instantiating elements in the range of the original function. If the verification conditions are correct\, there always exist finitely many refinement steps that eliminate all spurious counter-models\, making the approach complete. \nWe applied this approach in Ivy to verify the safety properties of consensus protocols and found that: (1) most verification goals can be automatically verified using relational abstraction\, while SMT solvers often diverge when given the original VC\, (2) only a few manual instantiations were needed\, and the counterexamples provided valuable guidance for the user compared to timeouts produced by the traditional approach\, and (3) the technique can be used to derive efficient low-level implementations of tricky algorithms.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T141200Z
DTEND:20231027T143000Z
DTSTAMP:20231021T100632Z
UID:90a90d77-39c1-4561-a5a4-a0e8fd14a76f@conf.researchr.org
CREATED:20231008T182408Z
SUMMARY:[SPLASH OOPSLA] A conceptual framework for safe object initialization: a principled and mechanized soundness proof of the Celsius model - Clément Blaudeau\, Fengyun Liu
DESCRIPTION:An object under initialization does not fulfill its class specification yet and can be unsafe to use as it may have uninitialized fields. It can sometimes be useful to call methods on such a partially initialized object in order to compute a complex initial value\, or to let the object escape its constructor in order to create mutually recursive objects. However\, inadvertent usage of uninitialized fields can lead to run-time crashes. Those subtle programming errors are not statically detected by most modern compilers. \nWhile many other features of object-oriented programming languages have been thoroughly studied over the years\, object initialization lacks a simple\, systematic\, and principled treatment. Building on the insights of previous work\, we identify a set of four core principles for safe initialization: monotonicity\, authority\, stackability\, and scopability. We capture the essence of the principles with a minimal calculus\, Celsius\, and show that the principles give rise to a practical initialization system that strikes a balance between expressiveness and simplicity. The meta-theory of the system is entirely mechanized using the Coq proof assistant. We believe that our approach based on well-identified core principles sheds new light on the underlying mechanisms ensuring safety and could serve as a basis for language design when faced with similar challenges.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T130000Z
DTEND:20231027T131800Z
DTSTAMP:20231021T100632Z
UID:930c30bb-aafe-4fef-a003-409777826e96@conf.researchr.org
CREATED:20231001T111602Z
SUMMARY:[SPLASH OOPSLA] Formally Verifying Optimizations with Block Simulations - Léo Gourdin\, Benjamin Bonneau\, Sylvain Boulmé\, David Monniaux\, Alexandre Bérard
DESCRIPTION:CompCert (ACM Software System Award 2021) is the first industrial-strength compiler with a mechanically checked proof of correctness. Yet\, CompCert remains a moderately optimizing C compiler. Indeed\, some optimizations of ``\texttt{gcc~-O1}'' such as \emph{Lazy Code Motion} (LCM) or \emph{Strength Reduction} (SR) were still missing: developing these efficient optimizations together with their formal proofs remained a challenge. \nCyril Six et al. have developed efficient formally verified translation validators for certifying the results of superblock schedulers and peephole optimizations. We revisit and generalize their approach into a framework (integrated into CompCert) able to validate many more optimizations: an enhanced superblock scheduler\, but also \emph{Dead Code Elimination} (DCE)\, \emph{Constant Propagation} (CP)\, and more noticeably\, LCM and SR. In contrast to other approaches to translation validation\, we co-design our untrusted optimizations and their validators. Our optimizations provide hints\, in the forms of \emph{invariants} or \emph{CFG morphisms}\, that help keep the formally verified validators both simple and efficient. Such designs seem applicable beyond CompCert.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T131800Z
DTEND:20231027T133600Z
DTSTAMP:20231021T100632Z
UID:1d67b1e6-5b71-4019-8ed3-0bb80af2426a@conf.researchr.org
CREATED:20231001T111602Z
SUMMARY:[SPLASH OOPSLA] Back to Direct Style: Typed and Tight - Marius Müller\, Philipp Schuster\, Jonathan Immanuel Brachthäuser\, Klaus Ostermann
DESCRIPTION:Translating programs into continuation-passing style is a well-studied tool to explicitly deal with the control structure of programs. This is useful\, for example\, for compilation. In a typed setting\, there also is a logical interpretation of such a translation as an embedding of classical logic into intuitionistic logic. A naturally arising question is whether there is an inverse translation back to direct style. The answer to this question depends on how the continuation-passing translation is defined and on the domain of the inverse translation. In general\, translating programs from continuation-passing style back to direct style requires the use of control operators to account for the use of continuations in non-trivial ways. \nWe present two languages\, one in direct style and one in continuation-passing style. Both languages are typed and equipped with an abstract machine semantics. Moreover\, both languages allow for non-trivial control flow. We further present a translation to continuation-passing style and a translation back to direct style. We show that both translations are type-preserving and also preserve semantics in a very precise way giving an operational correspondence between the two languages. Moreover\, we show that the compositions of the translations are well-behaved. In particular\, they are syntactic one-sided inverses on the full language and full syntactic inverses when restricted to trivial control flow.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T133600Z
DTEND:20231027T135400Z
DTSTAMP:20231021T100632Z
UID:29dfc43c-7c9f-47bc-b219-59ad4a9d24ac@conf.researchr.org
CREATED:20231001T111602Z
SUMMARY:[SPLASH OOPSLA] Hardware-Aware Static Optimization of Hyperdimensional Computations - Pu (Luke) Yi\, Sara Achour
DESCRIPTION:Binary spatter code (BSC)-based hyperdimensional computing (HDC) is a highly error-resilient approximate computational paradigm suited for error-prone\, emerging hardware platforms. In BSC HDC\, the basic datatype is a \textit{hypervector}\, a typically large binary vector\, where the size of the hypervector has a significant impact on the fidelity and resource usage of the computation. Typically\, the hypervector size is dynamically tuned to deliver the desired accuracy\; this process is time-consuming and often produces hypervector sizes that lack accuracy guarantees and produce poor results when reused for very similar workloads. We present Heim\, a hardware-aware static analysis and optimization framework for BSC HD computations. Heim analytically derives the minimum hypervector size that minimizes resource usage and meets the target accuracy requirement. Heim \textit{guarantees} the optimized computation converges to the user-provided accuracy target on expectation\, even in the presence of hardware error. Heim deploys a novel static analysis procedure that unifies theoretical results from the neuroscience community to systematically optimize HD computations. \nWe evaluate Heim against dynamic tuning-based optimization on 25 benchmark data structures. Given a 99% accuracy requirement\, Heim-optimized computations achieve a 99.2%-100.0% median accuracy\, up to 49.5% higher than dynamic tuning-based optimization\, while achieving 1.15x-7.14x reductions in hypervector size compared to HD computations that achieve comparable query accuracy and finding parametrizations 30.0x-100167.4x faster than dynamic tuning-based approaches. We also use Heim to systematically evaluate the performance benefits of using analog CAMs and multiple-bit-per-cell ReRAM over conventional hardware\, while maintaining iso-accuracy – for both emerging technologies\, we find usages where the emerging hardware imparts significant benefits.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T135400Z
DTEND:20231027T141200Z
DTSTAMP:20231021T100632Z
UID:eb4a8f20-5d94-491b-9dd1-7e1acc6659c8@conf.researchr.org
CREATED:20231001T111602Z
SUMMARY:[SPLASH OOPSLA] Rapid: Region-Based Pointer Disambiguation - Khushboo Chitre\, Piyus Kedia\, Rahul Purandare
DESCRIPTION:Interprocedural alias analyses often sacrifice precision for scalability. Thus\, modern compilers such as GCC and LLVM implement more scalable but less precise intraprocedural alias analyses. This compromise makes the compilers miss out on potential optimization opportunities\, affecting the performance of the application. Modern compilers implement loop-versioning with dynamic checks for pointer disambiguation to enable the missed optimizations. Polyhedral access range analysis and symbolic range analysis enable 𝑂 (1) range checks for non-overlapping of memory accesses inside loops. However\, these approaches work only for the loops in which the loop bounds are loop invariants. To address this limitation\, researchers proposed a technique that requires 𝑂 (𝑙𝑜𝑔 𝑛) memory accesses for pointer disambiguation. Others improved the performance of dynamic checks to single memory access by constraining the object size and alignment. However\, the former approach incurs noticeable overhead due to its dynamic checks\, whereas the latter has a noticeable allocator overhead. Thus\, scalability remains a challenge. \nIn this work\, we present a tool\, Rapid\, that further reduces the overheads of the allocator and dynamic checks proposed in the existing approaches. The key idea is to identify objects that need disambiguation checks using a profiler and allocate them in different regions\, which are disjoint memory areas. The disambiguation checks simply compare the regions corresponding to the objects. The regions are aligned such that the top 32 bits in the addresses of any two objects allocated in different regions are always different. As a consequence\, the dynamic checks do not require any memory access to ensure that the objects belong to different regions\, making them efficient. \nRapid achieved a maximum performance benefit of around 52.94% for Polybench and 1.88% for CPU SPEC 2017 benchmarks. The maximum CPU overhead of our allocator is 0.57% with a geometric mean of -0.2% for CPU SPEC 2017 benchmarks. Due to the low overhead of the allocator and dynamic checks\, Rapid could improve the performance of 12 out of 16 CPU SPEC 2017 benchmarks. In contrast\, a state-of-the-art approach used in the comparison could improve only five CPU SPEC 2017 benchmarks.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T141200Z
DTEND:20231027T143000Z
DTSTAMP:20231021T100632Z
UID:b4cec933-e217-4a99-b62e-0a87581feaff@conf.researchr.org
CREATED:20231001T111602Z
SUMMARY:[SPLASH OOPSLA] Automated Ambiguity Detection in Layout-Sensitive Grammars - Jiangyi Liu\, Fengmin Zhu\, Fei He
DESCRIPTION:Layout-sensitive grammars have been adopted in many modern programming languages. In a serious language design phase\, the specified syntax—typically a grammar—must be unambiguous. Although checking ambiguity is undecidable for context-free grammars and (trivially also) layout-sensitive grammars\, &lt\;i&gt\;ambiguity detection&lt\;/i&gt\;\, on the other hand\, is possible and can benefit language designers from &lt\;i&gt\;exposing potential design flaws&lt\;/i&gt\;. \nIn this paper\, we tackle the ambiguity detection problem in layout-sensitive grammars. Inspired by a previous work on checking the &lt\;i&gt\;bounded ambiguity&lt\;/i&gt\; of context-free grammars via &lt\;i&gt\;SAT solving&lt\;/i&gt\;\, we intensively extend their approach to support layout-sensitive grammars but via &lt\;i&gt\;SMT solving&lt\;/i&gt\; to express the ordering and quantitative relations over line/column numbers. Our key novelty lies in a &lt\;i&gt\;reachability&lt\;/i&gt\; condition\, which takes the impact of layout constraints on ambiguity into careful account. With this condition in hand\, we propose an equivalent ambiguity notion called &lt\;i&gt\;local ambiguity&lt\;/i&gt\; for the convenience of SMT encoding. We translate local ambiguity into an SMT formula and developed a &lt\;i&gt\;bounded ambiguity checker&lt\;/i&gt\; that &lt\;i&gt\;automatically&lt\;/i&gt\; finds a &lt\;i&gt\;shortest&lt\;/i&gt\; nonempty ambiguous sentence (if exists) for a user-input grammar. The &lt\;i&gt\;soundness&lt\;/i&gt\; and &lt\;i&gt\;completeness&lt\;/i&gt\; of our SMT encoding are mechanized in the Coq proof assistant. We conducted an evaluation on both grammar fragments and &lt\;i&gt\;full&lt\;/i&gt\; grammars extracted from the language manuals of domain-specific languages like YAML as well as general-purpose languages like Python\, which reveals the effectiveness of our approach.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T130000Z
DTEND:20231027T131800Z
DTSTAMP:20231021T100632Z
UID:20a3a68b-8e05-4c17-bbad-dac117d86b56@conf.researchr.org
CREATED:20230912T184710Z
SUMMARY:[SPLASH OOPSLA] Compositional Security Definitions for Higher-Order Where Declassification - Jan Menz\, Andrew K. Hirsch\, Peixuan Li\, Deepak Garg
DESCRIPTION:To ensure programs do not leak private data\, we often want to be able to provide formal guarantees ensuring such data is handled correctly. Often\, we cannot keep such data secret entirely\; instead programmers specify how private data may be declassified. While security definitions for declassification exist\, they mostly do not handle higher-order programs. In fact\, in the higher-order setting no compositional security definition exists for intensional information-flow properties such as where declassification\, which allows declassification in specific parts of a program. We use logical relations to build a model (and thus security definition) of where declassification. The key insight required for our model is that we must stop enforcing indistinguishability once a relevant declassification has occurred. We show that the resulting security definition provides more security than the most related previous definition\, which is for the lower-order setting.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T131800Z
DTEND:20231027T133600Z
DTSTAMP:20231021T100632Z
UID:86e8c70d-a1da-4973-aa45-3e992b68ad83@conf.researchr.org
CREATED:20230912T184710Z
SUMMARY:[SPLASH OOPSLA] Fat Pointers for Temporal Memory Safety of C - Jie Zhou\, John Criswell\, Michael Hicks
DESCRIPTION:Temporal memory safety bugs\, especially use-after-free and double free bugs\, pose a major security threat to C programs. Real-world exploits utilizing these bugs enable attackers to read and write arbitrary memory locations\, causing disastrous violations of confidentiality\, integrity\, and availability. Many previous solutions retrofit temporal memory safety to C\, but they all either incur high performance overhead and/or miss detecting certain types of temporal memory safety bugs. \nIn this paper\, we propose a temporal memory safety solution that is both efficient and comprehensive. Specifically\, we extend Checked C\, a spatially-safe extension to C\, with temporally-safe pointers. These are implemented by combining two techniques: fat pointers and dynamic key-lock checks. We show that the fat-pointer solution significantly improves running time and memory overhead compared to the disjoint-metadata approach that provides the same level of protection. With empirical program data and hands-on experience porting real-world applications\, we also show that our solution is practical in terms of backward compatibility—one of the major complaints about fat pointers.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T133600Z
DTEND:20231027T135400Z
DTSTAMP:20231021T100632Z
UID:b6647d8d-0ba3-4934-bc70-766e4a46ff08@conf.researchr.org
CREATED:20230912T184710Z
SUMMARY:[SPLASH OOPSLA] Quantifying and Mitigating Cache Side Channel Leakage with Differential Set - Cong Ma\, Dinghao Wu\, Gang Tan\, Mahmut Taylan Kandemir\, Danfeng Zhang
DESCRIPTION:Cache side-channel attacks leverage secret-dependent footprints in CPU cache to steal confidential information\, such as encryption keys. Due to the lack of a proper abstraction for reasoning about cache side channels\, existing static program analysis tools that can quantify or mitigate cache side channels are built on very different kinds of abstractions. As a consequence\, it is hard to bridge advances in quantification and mitigation research. Moreover\, existing abstractions lead to imprecise results. In this paper\, we present a novel abstraction\, called differential set\, for analyzing cache side channels at compile time. A distinguishing feature of differential sets is that it allows compositional and precise reasoning about cache side channels. Moreover\, it is the first abstraction that carries sufficient information for both side channel quantification and mitigation. Based on this new abstraction\, we develop a static analysis tool DSA that automatically quantifies and mitigates cache side channel leakage at the same time. Experimental evaluation on a set of commonly used benchmarks shows that DSA can produce more precise leakage bound as well as mitigated code with fewer memory footprints\, when compared with state-of-the-art tools that only quantify or mitigate cache side channel leakage.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T135400Z
DTEND:20231027T141200Z
DTSTAMP:20231021T100632Z
UID:88fc892d-9697-4f5b-9e0d-7d7c6eb90745@conf.researchr.org
CREATED:20230912T184710Z
SUMMARY:[SPLASH OOPSLA] A Verification Methodology for the Arm® Confidential Computing Architecture: From a Secure Specification to Safe Implementations - Anthony C. J. Fox\, Gareth Stockwell\, Shale Xiong\, Hanno Becker\, Dominic P. Mulligan\, Gustavo Petri\, Nathan Chong
DESCRIPTION:We present Arm's efforts in verifying the specification and prototype reference implementation of the Realm Management Monitor (RMM)\, an essential firmware component of Arm Confidential Computing Architecture (Arm CCA)\, the recently-announced Confidential Computing technologies incorporated in the Armv9-A architecture. Arm CCA introduced the Realm Management Extension (RME)\, an architectural extension for Armv9-A\, and a technology that will eventually be deployed in hundreds of millions of devices. Given the security-critical nature of the RMM\, and its taxing threat model\, we use a combination of interactive theorem proving\, model checking\, and concurrency-aware testing to validate and verify security and safety properties of both the specification and a prototype implementation of the RMM. Crucially\, our verification efforts were\, and are still being\, developed and refined contemporaneously with active development of both specification and implementation\, and have been adopted by Arm's product teams. \nWe describe our major achievements\, realized through the application of formal techniques\, as well as challenges that remain for future work. We believe that the work reported in this paper is the most thorough application of formal techniques to the design and implementation of any current commercially-viable Confidential Computing implementation\, setting a new high-water mark for work in this area.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T141200Z
DTEND:20231027T143000Z
DTSTAMP:20231021T100632Z
UID:84c6ab36-a04a-447c-8441-1919b19f0ee5@conf.researchr.org
CREATED:20230915T184345Z
SUMMARY:[SPLASH OOPSLA] Verifying Indistinguishability of Privacy-Preserving Protocols - Kirby Linvill\, Gowtham Kaki\, Eric Wustrow
DESCRIPTION:Internet users rely on the protocols they use to protect their private information including their identity and the websites they visit. Formal verification of these protocols can detect subtle bugs that compromise these protections at design time\, but is a challenging task as it involves probabilistic reasoning about random sampling\, cryptographic primitives\, and concurrent execution. Existing approaches either reason about symbolic models of the protocols that sacrifice precision for automation\, or reason about more precise computational models that are harder to automate and require cryptographic expertise. In this paper we propose a novel approach to verifying privacy-preserving protocols that is more precise than symbolic models yet more accessible than computational models. Our approach permits &lt\;i&gt\;direct-style&lt\;/i&gt\; proofs of privacy\, as opposed to indirect game-based proofs in computational models\, by formalizing privacy as &lt\;i&gt\;indistinguishability&lt\;/i&gt\; of possible network traces induced by a protocol. We ease automation by leveraging insights from the distributed systems verification community to create sound synchronous models of concurrent protocols. Our verification framework is implemented in F* as a library we call Waldo. We describe two large case studies of using Waldo to verify indistinguishability\; one on the &lt\;i&gt\;Encrypted Client Hello&lt\;/i&gt\; (ECH) extension of the TLS protocol and another on a &lt\;i&gt\;Private Information Retrieval&lt\;/i&gt\; (PIR) protocol. We uncover subtle flaws in the TLS ECH specification that were missed by other models.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T150000Z
DTEND:20231027T151800Z
DTSTAMP:20231021T100632Z
UID:aef61183-6680-4221-ba66-d06d779d38c3@conf.researchr.org
CREATED:20230917T160358Z
SUMMARY:[SPLASH OOPSLA] Hybrid Multiparty Session Types: Compositionality for Protocol Specification through Endpoint Projection - Lorenzo Gheri\, Nobuko Yoshida
DESCRIPTION:Multiparty session types (MPST) are a specification and verification framework for distributed message-passing systems. The communication protocol of the system is specified as a \emph{global type}\, from which a collection of \emph{local types} (local process implementations) is obtained by \emph{endpoint projection}. A global type is a single disciplining entity for the whole system\, specified by \emph{one designer} that has full knowledge of the communication protocol. On the other hand\, distributed systems are often described in terms of their \emph{components}: a different designer is in charge of providing a subprotocol for each component. The problem of modular specification of global protocols has been addressed in the literature\, but the state of the art focuses only on dual input/output compatibility. Our work overcomes this limitation. We propose the first MPST theory of \emph{multiparty compositionality for distributed protocol specification} that is semantics-preserving\, allows the composition of two or more components\, and retains full MPST expressiveness. We introduce \emph{hybrid types} for describing subprotocols interacting with each other\, define a novel \emph{compatibility relation}\, explicitly describe an algorithm for composing multiple subprotocols into a \emph{well-formed global type}\, and prove that compositionality preserves projection\, thus retaining semantic guarantees\, such as liveness and deadlock freedom. Finally\, we test our work against real-world case studies and we smoothly extend our novel compatibility to MPST with delegation and explicit connections.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T151800Z
DTEND:20231027T153600Z
DTSTAMP:20231021T100632Z
UID:12b4ac75-9005-4026-a5cb-24b68785f818@conf.researchr.org
CREATED:20230917T160358Z
SUMMARY:[SPLASH OOPSLA] Mechanizing Session-Types using a Structural View: Enforcing Linearity without Linearity - Chuta Sano\, Ryan Kavanagh\, Brigitte Pientka
DESCRIPTION:Session types employ a linear type system that ensures that communication channels cannot be implicitly copied or discarded. As a result\, many mechanizations of these systems require modeling channel contexts and carefully ensuring that they treat channels linearly. We demonstrate a technique that localizes linearity conditions as additional predicates embedded within type judgments\, which allows us to use structural typing contexts instead of linear ones. This technique is especially relevant when leveraging (weak) higher-order abstract syntax to handle channel mobility and the intricate binding structures that arise in session-typed systems. Following this approach\, we mechanize a session-typed system based on classical linear logic and its type preservation proof in the proof assistant Beluga\, which uses the logical framework LF as its encoding language. We also prove adequacy for our encoding. This shows the tractability and effectiveness of our approach in modelling substructural systems such as session-typed languages.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T153600Z
DTEND:20231027T155400Z
DTSTAMP:20231021T100632Z
UID:298fafd4-0216-4e52-b896-b46a259ee76d@conf.researchr.org
CREATED:20230917T160358Z
SUMMARY:[SPLASH OOPSLA] Message Chains for Distributed System Verification - Federico Mora\, Ankush Desai\, Elizabeth Polgreen\, Sanjit A. Seshia
DESCRIPTION:Verification of asynchronous distributed programs is challenging due to the need to reason about numerous control paths resulting from the myriad interleaving of messages and failures. In this paper\, we propose an automated bookkeeping method based on message chains. Message chains reveal structure in asynchronous distributed system executions and can help programmers verify their systems at the message passing level of abstraction. To evaluate our contributions empirically we build a verification prototype for the P programming language that integrates message chains. We use it to verify 16 benchmarks from related work\, one new benchmark that exemplifies the kinds of systems our method focuses on\, and two industrial benchmarks. We find that message chains are able to simplify existing proofs and our prototype performs comparably to existing work in terms of runtime. We extend our work with support for specification mining and find that message chains provide enough structure to allow existing learning and program synthesis tools to automatically infer meaningful specifications using only execution examples.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T155400Z
DTEND:20231027T161200Z
DTSTAMP:20231021T100632Z
UID:8eb6e706-0cd5-43d5-b4a6-e5f8a3ac1fdb@conf.researchr.org
CREATED:20230917T160358Z
SUMMARY:[SPLASH OOPSLA] Randomized Testing of Byzantine Fault Tolerant Algorithms - Levin N. Winter\, Florena Buse\, Daan de Graaf\, Klaus von Gleissenthall\, Burcu Kulahcioglu Ozkan
DESCRIPTION:Byzantine fault-tolerant algorithms promise agreement on a correct value\, even if a subset of processes can deviate from the algorithm arbitrarily. While these algorithms provide strong guarantees in theory\, in practice\, protocol bugs and implementation mistakes may still cause them to go wrong. This paper introduces ByzzFuzz\, a simple yet effective method for automatically finding errors in implementations of Byzantine fault-tolerant algorithms through randomized testing. ByzzFuzz detects fault-tolerance bugs by injecting randomly generated network and process faults into their executions. To navigate the space of possible process faults\, ByzzFuzz introduces small-scope message mutations which mutate the contents of the protocol messages by applying small changes to the original message either in value (e.g.\, by incrementing the round number) or in time (e.g.\, by repeating a proposal value from a previous message). We find that small-scope mutations\, combined with insights from the testing and fuzzing literature\, are effective at uncovering protocol logic and implementation bugs in real-world fault-tolerant systems. \nWe implemented ByzzFuzz and applied it to test the production implementations of two popular blockchain systems\, Tendermint and Ripple\, and an implementation of the seminal PBFT protocol. ByzzFuzz detected several bugs in the implementation of PBFT\, a potential liveness violation in Tendermint\, and materialized two theoretically described vulnerabilities in Ripple’s XRP Ledger Consensus Algorithm. Moreover\, we discovered a previously unknown fault-tolerance bug in the production implementation of Ripple\, which is confirmed by the developers and fixed.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T161200Z
DTEND:20231027T163000Z
DTSTAMP:20231021T100632Z
UID:b352034d-90c5-4690-a8c3-c319957e1b09@conf.researchr.org
CREATED:20230917T160358Z
SUMMARY:[SPLASH OOPSLA] Validating IoT Devices with Rate-Based Session Types - Grant Iraci\, Cheng-En Chuang\, Raymond Hu\, Lukasz Ziarek
DESCRIPTION:We develop a session types based framework for implementing and validating rate-based message passing systems in Internet of Things (IoT) domains. To model the indefinite repetition present in many embedded and IoT systems\, we introduce a timed process calculus with a periodic recursion primitive. This allows us to model rate-based computations and communications inherent to these application domains. We introduce a definition of rate based session types in a binary session types setting and a new compatibility relationship\, which we call rate compatibility. Programs which type check enjoy the standard session types guarantees as well as rate error freedom — meaning processes which exchanges messages do so at the same rate. Rate compatibility is defined through a new notion of type expansion\, a relation that allows communication between processes of differing periods by synthesizing and checking a common superperiod type. We prove type preservation and rate error freedom for our system\, and show a decidable method for type checking based on computing superperiods for a collection of processes. We implement a prototype of our type system including rate compatibility via an embedding into the native type system of Rust. We apply this framework to a range of examples from our target domain such as Android software sensors\, wearable devices\, and sound processing.
LOCATION:Room I - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T150000Z
DTEND:20231027T151800Z
DTSTAMP:20231021T100632Z
UID:c4cb396b-6042-47a6-9a31-ce172062d95d@conf.researchr.org
CREATED:20230918T155518Z
SUMMARY:[SPLASH OOPSLA] Aliasing Limits on Translating C to Safe Rust - Mehmet Emre\, Peter Boyland\, Aesha Parekh\, Ryan Schroeder\, Kyle Dewey\, Ben Hardekopf
DESCRIPTION:The Rust language was created to provide safe low-level systems programming. There is both industrial and academic interest in the problem of (semi-)automatically translating C code to Rust in order to exploit Rust’s safety guarantees. We study the effectiveness and limitations of existing techniques for automatically translating unsafe raw pointers (in Rust programs translated from C) into safe Rust references via ownership and lifetime inference. Our novel evaluation methodology enables our study to extend beyond prior studies\, and to discover new information contradicting the conclusions of prior studies. We find that existing translation methods are severely limited by a lack of precision in the Rust compiler’s safety checker\, causing many safe pointer manipulations to be labeled as potentially unsafe. Leveraging this information\, we propose methods for improving translation\, based on encoding the results of a more precise analysis in a manner that is understandable to an unmodified Rust compiler. We implement one of our proposed methods\, increasing the number of pointers that can be translated to safe Rust references by 75% over the baseline (from 12% to 21% of all pointers).
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T151800Z
DTEND:20231027T153600Z
DTSTAMP:20231021T100632Z
UID:17d2d6fe-0334-4e9f-9e70-eac06bc37240@conf.researchr.org
CREATED:20230918T155518Z
SUMMARY:[SPLASH OOPSLA] Adventure of a Lifetime: Extract Method Refactoring for Rust - Sewen Thy\, Andreea Costea\, Kiran Gopinathan\, Ilya Sergey
DESCRIPTION:We present a design and implementation of the automated "Extract Method" refactoring for Rust programs. Even though Extract Method is one of the most well-studied and widely used in practice automated refactorings\, featured in all major IDEs for all popular programming languages\, implementing it soundly for Rust is surprisingly non-trivial due to the restrictions of the Rust's ownership and lifetime-based type system. \nIn this work\, we provide a systematic decomposition of the Extract Method refactoring for Rust programs into a series of program transformations\, each concerned with satisfying a particular aspect of Rust type safety\, eventually producing a well-typed Rust program. Our key discovery is the formulation of Extract Method as a composition of naive function hoisting and a series of automated program repair procedures that progressively make the resulting program "more well-typed" by relying on the corresponding repair oracles. Those oracles include a novel static intra-procedural ownership analysis that infers correct sharing annotations for the extracted function's parameters\, and the lifetime checker of rustc\, Rust's reference compiler. \nWe implemented our approach in a tool called REM—an automated Extract Method refactoring built on top of IntelliJ IDEA plugin for Rust. Our extensive evaluation on a corpus of changes in five popular Rust projects shows that REM (a) can extract a larger class of feature-rich code fragments into semantically correct functions than other existing refactoring tools\, (b) can reproduce method extractions performed manually by human developers in the past\, and (c) is efficient enough to be used in interactive development.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T153600Z
DTEND:20231027T155400Z
DTSTAMP:20231021T100632Z
UID:dde72286-7c1b-462a-8775-4a76223d5504@conf.researchr.org
CREATED:20230918T155518Z
SUMMARY:[SPLASH OOPSLA] Inductive Program Synthesis Guided by Observational Program Similarity - Jack Feser\, Işıl Dillig\, Armando Solar-Lezama
DESCRIPTION:We present a new general-purpose synthesis technique for generating programs from input-output examples. Our method\, called metric program synthesis\, relaxes the observational equivalence idea (used widely in bottom-up enumerative synthesis) into a weaker notion of observational similarity\, with the goal of reducing the search space that the synthesizer needs to explore. Our method clusters programs into equivalence classes based on an expert-provided distance metric and constructs a version space that compactly represents “approximately correct” programs. Then\, given a “close enough” program sampled from this version space\, our approach uses a distance-guided repair algorithm to find a program that exactly matches the given input-output examples. We have implemented our proposed metric program synthesis technique in a tool called SyMetric and evaluate it in three different domains considered in prior work. Our evaluation shows that SyMetric outperforms other domain-agnostic synthesizers that use observational equivalence and that it achieves results competitive with domain-specific synthesizers that are either designed for or trained on those domains.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T155400Z
DTEND:20231027T161200Z
DTSTAMP:20231021T100632Z
UID:fce7b547-ed23-423b-a1e5-f1524c2989cb@conf.researchr.org
CREATED:20230918T155518Z
SUMMARY:[SPLASH OOPSLA] Automated Translation of Functional Big Data Queries to SQL - Guoqiang Zhang\, Benjamin Mariano\, Xipeng Shen\, Işıl Dillig
DESCRIPTION:Big data analytics frameworks like Apache Spark and Flink enable users to implement queries over large\, distributed databases using functional APIs. In recent years\, these APIs have grown in popularity because their functional interfaces abstract away much of the minutiae of distributed programming required by traditional query languages like SQL. However\, the convenience of these APIs comes at a cost because functional queries are often less efficient than their SQL counterparts. Motivated by this observation\, we present a new technique for automatically transpiling functional queries to SQL. While our approach is based on the standard paradigm of counterexample-guided inductive synthesis\, it uses a novel column-wise decomposition technique to split the synthesis task into smaller subquery synthesis problems. We have implemented this approach as a new tool called RDD2SQL for translating Spark RDD queries to SQL and empirically evaluate the effectiveness of RDD2SQL on a set of real-world RDD queries. Our results show that (1) most RDD queries can be translated to SQL\, (2) our tool is very effective at automating this translation\, and (3) performing this translation offers significant performance benefits.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T161200Z
DTEND:20231027T163000Z
DTSTAMP:20231021T100632Z
UID:293a1c88-5bf0-4095-9b09-f742daf94a41@conf.researchr.org
CREATED:20230918T155518Z
SUMMARY:[SPLASH OOPSLA] User-Customizable Transpilation of Scripting Languages - Bo Wang\, Aashish Kolluri\, Ivica Nikolić\, Teodora Baluta\, Prateek Saxena
DESCRIPTION:A transpiler converts code from one programming language to another. Many practical uses of transpilers require the user to be able to guide or customize the program produced from a given input program. This customizability is important for satisfying many application-specific goals for the produced code such as ensuring performance\, readability\, ease of exposition or maintainability\, compatibility with external environment or analysis tools\, and so on. Conventional transpilers are deterministic rule-driven systems often written without offering customizability per user and per program. Recent advances in transpilers based on neural networks offer some customizability to users\, e.g. through interactive prompts\, but they are still difficult to precisely control the production of a desired output. Both conventional and neural transpilation also suffer from the “last mile” problem: they produce correct code on average\, i.e.\, on most parts of a given program\, but not necessarily for all parts of it. We propose a new transpilation approach that offers fine-grained customizability and reusability of transpilation rules created by others\, without burdening the user to understand the global semantics of the given source program. Our approach is mostly automatic and incremental\, i.e.\, constructs translation rules needed to transpile the given program as per the user’s guidance piece-by-piece. Users can rely on existing transpilation rules to translate most of the program correctly while focusing their effort locally\, only on parts that are incorrect or need customization. This improves the correctness of the end result. We implement the transpiler as a tool called DuoGlot\, which translates Python to Javascript programs\, and evaluate it on the popular GeeksForGeeks benchmarks. DuoGlot achieves $90%$ translation accuracy and so it outperforms all existing translators (both handcrafted and neural-based)\, while it produces readable code. We evaluate DuoGlot on two additional benchmarks\, containing more challenging and longer programs\, and similarly observe improved accuracy compared to the other transpilers.
LOCATION:Room II - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T191648Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T150000Z
DTEND:20231027T151800Z
DTSTAMP:20231021T100632Z
UID:a1866662-a524-404b-a763-61fc47cd59d9@conf.researchr.org
CREATED:20230912T185650Z
SUMMARY:[SPLASH OOPSLA] Verification-Preserving Inlining in Automatic Separation Logic Verifiers - Thibault Dardinier\, Gaurav Parthasarathy\, Peter Müller
DESCRIPTION:Bounded verification has proved useful to detect bugs and to increase confidence in the correctness of a program. In contrast to unbounded verification\, reasoning about calls via (bounded) inlining and about loops via (bounded) unrolling does not require method specifications and loop invariants and\, therefore\, reduces the annotation overhead to the bare minimum\, namely specifications of the properties to be verified. For verifiers based on traditional program logics\, verification is preserved by inlining (and unrolling): successful unbounded verification of a program w.r.t. some annotation implies successful verification of the inlined program. That is\, any error detected in the inlined program reveals a true error in the original program. However\, this essential property might not hold for automatic separation logic verifiers such as Caper\, GRASShopper\, RefinedC\, Steel\, VeriFast\, and verifiers based on Viper. In this setting\, inlining generally changes the resources owned by method executions\, which may affect automatic proof search algorithms and introduce spurious errors. In this paper\, we present the first technique for verification-preserving inlining in automatic separation logic verifiers. We identify a semantic condition on programs and prove in Isabelle/HOL that it ensures verification-preserving inlining for state-of-the-art automatic separation logic verifiers. We also prove a dual result: successful verification of the inlined program ensures that there are method and loop annotations that enable the verification of the original program for bounded executions. To check our semantic condition automatically\, we present two approximations that can be checked syntactically and with a program verifier\, respectively. We implement these checks in Viper and demonstrate that they are effective for non-trivial examples from different verifiers.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T193117Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T151800Z
DTEND:20231027T153600Z
DTSTAMP:20231021T100632Z
UID:925063ad-85e5-422f-9253-6a76bb326c4c@conf.researchr.org
CREATED:20230912T185650Z
SUMMARY:[SPLASH OOPSLA] Leaf: Modularity for Temporary Sharing in Separation Logic - Travis Hance\, Jon Howell\, Oded Padon\, Bryan Parno
DESCRIPTION:In concurrent verification\, separation logic provides a strong story for handling both resources that are owned exclusively and resources that are shared persistently (i.e.\, forever). However\, the situation is more complicated for temporarily shared state\, where state might be shared and then later reclaimed as exclusive. We believe that a framework for temporarily-shared state should meet two key goals not adequately met by existing techniques. One\, it should allow and encourage users to verify new sharing strategies. Two\, it should provide an abstraction where users manipulate shared state in a way agnostic to the means with which it is shared. \nWe present Leaf\, a library in the Iris separation logic which accomplishes both of these goals by introducing a novel operator\, which we call guarding\, that allows one proposition to represent a shared version of another. We demonstrate that Leaf meets these two goals through a modular case study: we verify a reader-writer lock that supports shared state\, and a hash table built on top of it that uses shared state.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T193117Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T153600Z
DTEND:20231027T155400Z
DTSTAMP:20231021T100632Z
UID:1439b23b-1d71-4943-a05c-66fe8ed61122@conf.researchr.org
CREATED:20230912T185650Z
SUMMARY:[SPLASH OOPSLA] Proof Automation for Linearizability in Separation Logic - Ike Mulder\, Robbert Krebbers
DESCRIPTION:Recent advances in concurrent separation logic enabled the formal verification of increasingly sophisticated fine-grained (\emph{i.e.}\, lock-free) concurrent programs. For such programs\, the golden standard of correctness is \emph{linearizability}\, which expresses that concurrent executions always behave as some valid sequence of sequential executions. Compositional approaches to linearizability (such as contextual refinement and logical atomicity) make it possible to prove linearizability of whole programs or compound data structures (\emph{e.g.}\, a ticket lock) using proofs of linearizability of their individual components (\emph{e.g.}\, a counter). While powerful\, these approaches are also laborious—state-of-the-art tools such as Iris\, FCSL\, and Voila all require a form of interactive proof. \nThis paper develops proof automation for contextual refinement and logical atomicity in Iris. The key ingredient of our proof automation is a collection of proof rules whose application is directed by both the program and the logical state. This gives rise to effective proof search strategies that can prove linearizability of simple examples fully automatically. For more complex examples\, we ensure the proof automation cooperates well with interactive proof tactics by minimizing the use of backtracking. \nWe implement our proof automation in Coq by extending and generalizing Diaframe\, a proof automation extension for Iris. While the old version (Diaframe 1.0) was limited to ordinary Hoare triples\, the new version (Diaframe 2.0) is extensible in its support for program verification styles: our proof search strategies for contextual refinement and logical atomicity are implemented as modules for Diaframe 2.0. We evaluate our proof automation on a set of existing benchmarks and novel proofs\, showing that it provides significant reduction of proof work for both approaches to linearizability.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T193117Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T155400Z
DTEND:20231027T161200Z
DTSTAMP:20231021T100632Z
UID:602698f8-5e34-4005-b33a-9884aa9e28ca@conf.researchr.org
CREATED:20230912T185650Z
SUMMARY:[SPLASH OOPSLA] Modular Verification of Safe Memory Reclamation in Concurrent Separation Logic - Jaehwang Jung\, Janggun Lee\, Jaemin Choi\, Jaewoo Kim\, Sunho Park\, Jeehoon Kang
DESCRIPTION:Formal verification is an effective method to address the challenge of designing correct and efficient concurrent data structures. But verification efforts often ignore \emph{memory reclamation}\, which involves nontrivial synchronization between concurrent accesses and reclamation. When incorrectly implemented\, it may lead to critical safety errors such as use-after-free and the ABA problem. Semi-automatic safe memory reclamation schemes such as hazard pointers and RCU encapsulate the complexity of manual memory management in modular interfaces. However\, this modularity has not been carried over to formal verification. \nWe propose modular specifications of hazard pointers and RCU\, and formally verify realistic implementations of them in concurrent separation logic. Specifically\, we design abstract predicates for hazard pointers that capture the meaning of \emph{validating} the protection of nodes\, and those for RCU that support \emph{optimistic traversal} to possibly retired nodes. We demonstrate that the specifications indeed facilitate modular verification in three criteria: compositional verification\, general applicability\, and easy integration. In doing so\, we present the first formal verification of Harris's list\, the Harris-Michael list\, the Chase-Lev deque\, and RDCSS with reclamation. We report the Coq mechanization of all our results in the Iris separation logic framework.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T193117Z
END:VEVENT
BEGIN:VEVENT
DTSTART:20231027T161200Z
DTEND:20231027T163000Z
DTSTAMP:20231021T100632Z
UID:f0f6d125-2dfc-4a9f-a7d6-f1ea6718a5fe@conf.researchr.org
CREATED:20231020T193117Z
SUMMARY:[SPLASH OOPSLA] Functional collection programming with semi-ring dictionaries - Amir Shaikhha\, Mathieu Huot\, Jaclyn Smith\, Dan Olteanu
DESCRIPTION:This paper introduces semi-ring dictionaries\, a powerful class of compositional and purely functional collections that subsume other collection types such as sets\, multisets\, arrays\, vectors\, and matrices. We developed SDQL\, a statically typed language that can express relational algebra with aggregations\, linear algebra\, and functional collections over data such as relations and matrices using semi-ring dictionaries. Furthermore\, thanks to the algebraic structure behind these dictionaries\, SDQL unifies a wide range of optimizations commonly used in databases (DB) and linear algebra (LA). As a result\, SDQL enables efficient processing of hybrid DB and LA workloads\, by putting together optimizations that are otherwise confined to either DB systems or LA frameworks. We show experimentally that a handful of DB and LA workloads can take advantage of the SDQL language and optimizations. SDQL can be competitive with or outperforms a host of systems that are state of the art in their own domain: in-memory DB systems Typer and Tectorwise for (flat\, not nested) relational data\; SciPy for LA workloads\; sparse tensor compiler taco\; the Trance nested relational engine\; and the in-database machine learning engines LMFAO and Morpheus for hybrid DB/LA workloads over relational data.
LOCATION:Room XII - Av.Marginal n.8554, Cascais, Portugal
LAST-MODIFIED:20231020T193117Z
END:VEVENT
END:VCALENDAR
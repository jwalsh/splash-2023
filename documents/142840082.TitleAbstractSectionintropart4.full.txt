Title-Abstract. Section intro

of the expression rewriting technique can be done soundly. Then, in Sect. 5 we
introduce an abstract representation of expressions that can be tuned by the
parameters of a generic numerical abstract domain described in Sect. 6. Such a
generic abstract domain is then instantiated in Sect. 7, by making explicit the
heuristics used to symbolically simplify expressions. Finally, Sect. 8 describes
some aspects of our implementations and an evaluation of the introduced ab-
stract domain over several code excerpts from industrial code.

2 Preliminary Results on Modular Integer Arithmetic

modular arithmetic. First, we introduce the set of modulo specificationsğ•„ that

In this section, we give basic properties to reason on Euclidean division and


Symbolic transformation of expressions in modular arithmetic

5

denotes arithmetic operations without modulo. This is formalized in the follow-
ing definition:

is defined as follows: ğ•„â‰{[ğ‘™,ğ‘¢[âˆ£ğ‘™,ğ‘¢âˆˆâ„¤,ğ‘™<ğ‘¢}âˆª{â„¤}.
The setğ•„ contains two kinds of elements. Intervals of the form[ğ‘™,ğ‘¢[ denote
operations moduloğ‘¢âˆ’ğ‘™ with result in the interval[ğ‘™,ğ‘¢[, whereas the elementâ„¤
Definition 1. We define the modulo ofğ‘˜âˆˆâ„¤ by an element ofğ•„ as
ğ‘˜mod[ğ‘™,ğ‘¢[â‰ğ‘™+irem(ğ‘˜âˆ’ğ‘™,ğ‘¢âˆ’ğ‘™)
ğ‘˜modâ„¤
whereirem(ğ‘š,ğ‘›) denotes the remainder of the Euclidean division of the integer
ğ‘š by the strictly positive integerğ‘›, that is to say the unique integerğ‘Ÿ such that
0â‰¤ğ‘Ÿ<ğ‘› andğ‘› dividesğ‘šâˆ’ğ‘Ÿ.
In particular, when the integerğ‘˜ belongs to the interval[ğ‘™,ğ‘¢[ we haveğ‘˜mod
[ğ‘™,ğ‘¢[=ğ‘˜.
Definition 2. An elementğ‘šâˆˆğ•„ is said to beğ‘˜-splittable, withğ‘˜ a strictly
positive integer, ifğ‘š can be split inğ‘˜ sets of same cardinality. We defineğ•Šâˆ¶
â„•âˆ—â†’â„˜(ğ•„) such thatğ•Š(ğ‘˜) is the set of elements ofğ•„ that areğ‘˜-splittable. More
Example 1. The intervals[0,216[ and[âˆ’215,215[ both are216-splittable and28-
We use the notion ofğ‘˜-splittability to reason about the application of consec-
Property 1. Letğ‘›âˆˆâ„¤ be an integer. Let[ğ‘™,ğ‘¢[ andğ‘š be two elements ofğ•„.
Ifğ‘š is(ğ‘¢âˆ’ğ‘™)-splittable (i.e., ifğ‘šâˆˆğ•Š(ğ‘¢âˆ’ğ‘™)), then(ğ‘›modğ‘š)mod[ğ‘™,ğ‘¢[=
ğ‘›mod[ğ‘™,ğ‘¢[.
Property 2. Letğ‘›âˆˆâ„¤ be an integer. Let[ğ‘™1,ğ‘¢1[ and[ğ‘™2,ğ‘¢2[ be two elements ofğ•„
such that[ğ‘™1,ğ‘¢1[âŠ†[ğ‘™2,ğ‘¢2[. Then,(ğ‘›mod[ğ‘™1,ğ‘¢1[)mod[ğ‘™2,ğ‘¢2[=ğ‘›mod[ğ‘™1,ğ‘¢1[.
Property 3. Letğ‘›âˆˆâ„¤ be an integer. Let[ğ‘™1,ğ‘¢1[ and[ğ‘™2,ğ‘¢2[ be two elements of
ğ•„. We considerğ›¼â‰ğ‘™1mod[ğ‘™2,ğ‘¢2[. Ifğ›¼+ğ‘¢1âˆ’ğ‘™1â‰¤ğ‘¢2 and(ğ‘¢1âˆ’ğ‘™1)|(ğ›¼âˆ’ğ‘™1), then
we have(ğ‘›mod[ğ‘™1,ğ‘¢1[)mod[ğ‘™2,ğ‘¢2[=ğ‘›mod[ğ›¼,ğ›¼+ğ‘¢1âˆ’ğ‘™1[. This is pictured in

utive modulo computations. In particular, when two modulo operations follow
each other, the inner one can be ignored under some specific conditions. This is
formalized in the following property.

âˆ€ğ‘˜>0,ğ•Š(ğ‘˜)â‰{[ğ‘™,ğ‘¢[âˆˆğ•„âˆ£(ğ‘˜|(ğ‘¢âˆ’ğ‘™))}âˆª{â„¤}.

formally,

splittable.

â‰ğ‘˜

We now give two other properties to simplify consecutive modulo computa-

tions under some conditions.

Fig. 4.


6

J. Boillot, J. Feret.

ğ‘™1

[

ğ‘¢1

]

mod[ğ‘™2,ğ‘¢2[

[

ğ‘™2
mod[ğ‘™2,ğ‘¢2[

ğ›¼

[

ğ›¼+ğ‘¢1âˆ’ğ‘™1

]

ğ‘¢2

]

Fig. 4: Translation when applying consecutive modulos.

exprâ©´ğ‘‹
| [ğ‘,ğ‘]
| âˆ’expr
| exprâ‹„ expr
| exprâ‹“ expr
| expr mod[ğ‘™,ğ‘¢[
| bound_check(expr,[ğ‘™,ğ‘¢[)
stmtâ©´ğ‘‹â† expr
|
if exprâ‹ˆ0 then stmtâ¨¾ endif â‹ˆâˆˆ{=,â‰ ,<,â‰¤,â‰¥,>}
| while exprâ‹ˆ0 do stmtâ¨¾ done â‹ˆâˆˆ{=,â‰ ,<,â‰¤,â‰¥,>}
| stmtâ¨¾ stmt

ğ‘‹âˆˆğ’±
ğ‘,ğ‘âˆˆâ„¤,ğ‘â‰¤ğ‘
â‹„âˆˆ{+,Ã—,âˆ•}
ğ‘™,ğ‘¢âˆˆâ„¤,ğ‘™<ğ‘¢
ğ‘™,ğ‘¢âˆˆâ„¤,ğ‘™<ğ‘¢
ğ‘‹âˆˆğ’±

Fig. 5: Syntax of our extended language.

Note that Prop. 2 is a particular case of Prop. 3. Indeed, with the notations of

Prop. 3, if[ğ‘™1,ğ‘¢1[âŠ†[ğ‘™ğ‘¢2[ we haveğ›¼=ğ‘™1. Then,ğ›¼+ğ‘¢1âˆ’ğ‘™1=ğ‘¢1 andğ›¼âˆ’ğ‘™1=0.
So,ğ›¼+ğ‘¢1âˆ’ğ‘™1â‰¤ğ‘¢2 and(ğ‘¢1âˆ’ğ‘™1)|(ğ›¼âˆ’ğ‘™1). We can conclude, thanks to Prop. 3,
that(ğ‘›mod[ğ‘™1,ğ‘¢1[)mod[ğ‘™2,ğ‘¢2[=ğ‘›mod[ğ‘™1,ğ‘¢1[
Example 2. Letğ‘› be an integer inâ„¤. Then,
â€“ by Prop. 1,(ğ‘›mod[âˆ’215,215[)mod[0,28[=ğ‘›mod[0,28[,
â€“ because23âˆˆ[0,28[,23mod[0,28[=23,
â€“ by Prop. 2ğ‘›mod[0,28[)mod[0,216[=ğ‘›mod[0,28[,
â€“ by Prop. 3,(ğ‘›mod[2,4[)mod[10,20[=ğ‘›mod[12,14[ (withğ›¼=12
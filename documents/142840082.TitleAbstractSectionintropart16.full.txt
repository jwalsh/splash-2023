Title-Abstract. Section intro
ï¿½ğœŒâŠ†â„¦ğ‘’ âˆ§ âŸ¦ğ‘’âŸ§ğ‘‰ğœŒâŠ†{âŸ¦toExpr(ğ‘’â™¯)âŸ§ğ‘‰ğœŒ
ifğ‘š=â„¤,
âŸ¦toExpr(ğ‘’â™¯) mod[ğ‘™,ğ‘¢[âŸ§ğ‘‰ğœŒ ifğ‘š=[ğ‘™,ğ‘¢[.
By abuse of notation, we allow the syntactic sugarğ‘’ modâ„¤ that representsğ‘’.


22

J. Boillot, J. Feret.

property holds:

The soundness of these rewritings comes from Theorems. 1 and 3, as well as

Corollary. 1.

âŸ¨ğ‘…0,â„¦0âŸ©âŠ¨ğ‘’â‰¼â„¦ğ‘’toExpr(ğ‘’â™¯) modğ‘š.

6.3 Integration with a Numerical Abstract Domain
We introduce a new numerical abstract domain with expression abstraction,

Corollary 1 (of theorem 4). For all abstract elementğ‘…â™¯ and expressionğ‘’âˆˆ
expr, withâŸ¨ğ‘…0,â„¦0âŸ©â‰ğ›¾(ğ‘…â™¯), and(ğ‘’â™¯,ğ‘š,â„¦ğ‘’)â‰â¦…ğ‘’â¦†ğ‘…â™¯, the following rewriting
notedğ’Ÿâ™¯â„’, that is identical toğ’Ÿâ™¯ except for the assignment and guard statements.
For any expressionğ‘’âˆˆ expr and any abstract elementğ‘…â™¯âˆˆğ’Ÿâ™¯, let us denote
(ğ‘’â™¯,ğ‘š,â„¦ğ‘’)â‰â¦…ğ‘’â¦†ğ‘…â™¯. Then,
assignâ™¯â„’(ğ‘‹,ğ‘’)ğ‘…â™¯â‰âŸ¨âˆ…,â„¦ğ‘’âŸ©âŠ” assignâ™¯(ğ‘‹,toExpr(rmMod(ğ‘’â™¯,ğ‘š)ğ‘…â™¯))ğ‘…â™¯
guardâ™¯â„’(ğ‘’,â‹ˆ)ğ‘…â™¯â‰âŸ¨âˆ…,â„¦ğ‘’âŸ©âŠ” guardâ™¯(toExpr(rmMod(ğ‘’â™¯,ğ‘š)ğ‘…â™¯),â‹ˆ)ğ‘…â™¯
In this section, we provide more explicit definitions for theğœ„ and reduce prim-
During the expression abstraction, theğœ„ primitive is used multiple times, either
by intervals overâ„¤ as presented in [4]. However, this method lacks the ability to
to check thatğ‘‹â‰¥ğ‘Œ holds. Thus, a domain able to represent the range of vari-
abstract domain [20] that handles inequalities of the formÂ±ğ‘‹Â±ğ‘Œâ‰¤ğ‘ withğ‘‹,ğ‘Œ
variables andğ‘ a constant, or the polyhedron abstract domain [8] that keeps

ables and the inequalities between pairs of variable, as the pentagon domain [17],
is enough for our current study cases. However, it would be possible to use more
precise abstract domains such as the difference bound matrices domain [19] that
detects upper-bounds of the difference between pairs of variables, the octagon

represent relations between variables, which can be necessary to simplify modulo
computations. For instance, in the program example introduced at the beginning
of the paper Fig. 1, in order to suppress the modulo computations it is necessary

to verify that modulo computations and bound checks can be safely suppressed,
or to check that simplifications can be performed, as in the DivPosConst in-
ference rule. Thus, it appears that the more this primitive is precise, the more
translations of expression will be precise.

A first possibility would be to represent the possible values of every expression

trace of linear inequality properties. Although using relational domains might
be costly, it is possible to limit it by restraining the number of variables involved
in the numerical constraints by a method named packing [2].

7

Instantiation of the generic framework

itives of our parametric abstraction. The other components are supposed to be
defined in an underlying domain.

7.1 Intervalization


Symbolic transformation of expressions in modular arithmetic

23

7.2 Simplification of abstract expressions

heuristic which attempts to simplify abstract expressions without concealing
potential error alarms. The purpose of this function is to achieve maximum
expression canonization by using linear forms whenever possible.

We now introduce a reduce implementation, denoted as reduce0, that is a
The reduction reduce0(ğ‘’â™¯)ğ‘…â™¯ of an abstract expressionğ‘’â™¯, in the context of
an abstract elementğ‘…â™¯, is defined inductively and by cases, by the means of
Addition. Whenâ„’â–¡(0) (that is the translation of0cst) is summed with another
0cst is a neutral element of(expr,+). Also, when linear forms are summed, we

a set of inference rules. Their premises are mutually exclusive, except for the
NoReduce rule that is used only when no other rule can be applied.

abstract expression, the latter abstract expression is returned. This is because

return the canonical linear form of their sum. Lastly, when a linear form is added
to a convex join expression, the addition is distributed over the operands of the
convex join. In such case, it is possible to reduce both the new additions and
the resulting abstract expression in order to simplify them. Those behaviors are
formalized in the three following inference rules. If neither of the three can be
applied reduction is performed.

PlusZero

ğ‘–,ğ‘—âˆˆ{1,2}âˆ¶ğ‘–â‰ ğ‘—
ğ‘’â™¯ğ‘–=â„’â–¡(0)
reduce0(ğ‘’â™¯1âŠğ‘’â™¯2)ğ‘…â™¯â‰ğ‘’â™¯ğ‘—
ğ‘’â™¯1=â„’â–¡(ğ‘0+âˆ‘ğ‘‹ğ‘–âˆˆğ’±ğ‘ğ‘–ğ‘‹ğ‘–)
ğ‘’â™¯1â‰ â„’â–¡(0)
ğ‘’â™¯2=â„’â–¡(ğ‘0+âˆ‘ğ‘‹ğ‘–âˆˆğ’±ğ‘ğ‘–ğ‘‹ğ‘–)
ï¿½â™¯2â‰ â„’â–¡(0)
reduce0(ğ‘’â™¯1âŠğ‘’â™¯2)ğ‘…â™¯â‰â„’â–¡((ğ‘0+ğ‘0)+âˆ‘ğ‘‹ğ‘–âˆˆğ’±(ğ‘ğ‘–+ğ‘ğ‘–)ğ‘‹ğ‘–)
ğ‘–,ğ‘—âˆˆ{1,2}ğ‘–â‰ ğ‘—
ğ‘’â™¯ğ‘—=â„’â–¡(ğ›¼0+âˆ‘ğ‘‹ğ‘–âˆˆğ’±ğ‘ğ‘–ğ‘‹ğ‘–)
ğ‘’â™¯ğ‘—â‰ â„’â–¡(0ï¿½ï¿½ğ‘–=ğ‘’â™¯ğ‘–,1â‹“â–¡ï¿½â™¯ğ‘–,2
ğ‘’â€²â™¯1â‰ reduce0(ğ‘’â™¯ğ‘–,1âŠğ‘’â™¯ğ‘—)ğ‘…â™¯
ğ‘’â€²â™¯2â‰ reduce0(ğ‘’â™¯ğ‘–,2âŠğ‘’â™¯ğ‘—)ğ‘…â™¯
reduce0(ğ‘’â™¯1âŠğ‘’â™¯2)ğ‘…â™¯â‰ reduce0(ğ‘’â€²â™¯1 â‹“â–¡ğ‘’â€²â™¯2)ğ‘…â™¯

PlusLinearForms

PlusConvexJoin

Multiplication. Multiplying a linear form by a
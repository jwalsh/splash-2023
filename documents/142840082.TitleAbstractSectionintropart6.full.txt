Title-Abstract. Section intro
 no
error either. It provides an arbitrary value in the corresponding interval. Clas-
sical arithmetic operators and modulo consist in applying the corresponding
operations element-wise while propagating the errors potentially raised when
evaluating their sub-expressions. Additionally, the result of every division be-
tween two integers is truncated, that is rounded towards zero raising the

errorğœ”ğ‘‘ when the denominator can take the value0. The convex join operator
â‹“ outputs any value between the potential values of its operands and propagates
ues while raising the errorğœ”ğ‘œ when they do not fit in the interval given as an
It is worth to note that division by0 and overflows are handled differently:
executions that perform divisions by0 are halted (they produce no memory
ğ’Ÿ collects both sets of memory states and errors. Thus is defined as follows:
It is equipped with the component-wise joinâŠ” and orderâŠ‘.
The concrete semantics of a statement,â¦ƒ stmtâ¦„âˆ¶ğ’Ÿâ†’ğ’Ÿ, maps each element
of the semantics domainğœŒâˆˆğ’Ÿ to another one. For a given statement, it applies

states), whereas those that cause overflows are continued without modifying the
current value. It corresponds to user-defined semantics assumptions [1], which
are more specific than C standard which assumes the result is non-deterministic.

We now define the concrete semantics of statements. The semantics domain

ğ’Ÿâ‰â„˜(â„°)Ã—â„˜(â„¦).


9

Fig. 7: Concrete semantics of statements.

the elements of the set given as an argument.

Symbolic transformation of expressions in modular arithmetic

â¦ƒğ‘‹â†ğ‘’â¦„âŸ¨ğ‘…0,â„¦0âŸ©â‰âŸ¨âˆ…,â„¦0âŸ©âŠ”â¨†
ğœŒâˆˆğ‘…0{âŸ¨{ğœŒ[ğ‘‹â†¦ğ‘£]},âŸ¦ğ‘’âŸ§â„¦ğœŒâŸ©||||ğ‘£âˆˆâŸ¦ğ‘’âŸ§ğ‘‰ğœŒ}
â¦ƒğ‘’â‹ˆ0?â¦„âŸ¨ğ‘…0,â„¦0âŸ©â‰âŸ¨âˆ…,â„¦0âŸ©âŠ”â¨†
ğœŒâˆˆğ‘…0{âŸ¨{ï¿½ï¿½ï¿½ï¿½âŸ§â„¦ğœŒâŸ©||||âˆƒğ‘£ï¿½ï¿½ï¿½ğ‘’âŸ§ğ‘‰ğœŒ,ğ‘£â‹ˆ0}
â¦ƒğ‘ 1â¨¾ğ‘ 2â¦„â‰â¦ƒğ‘ 2â¦„â—¦â¦ƒğ‘ 1â¦„
â¦ƒ ifğ‘’â‹ˆ0 thenğ‘ â¨¾ endifâ¦„âŸ¨ğ‘…0,â„¦0âŸ©â‰(â¦ƒğ‘ â¦„â—¦â¦ƒğ‘’â‹ˆ0?â¦„)âŸ¨ğ‘…0,â„¦0âŸ©âŠ”â¦ƒğ‘’Ì¸â‹ˆ0?â¦„âŸ¨ğ‘…0,â„¦0âŸ©
â¦ƒ whileğ‘’â‹ˆ0 doğ‘ â¨¾ doneâ¦„âŸ¨ğ‘…0,â„¦0âŸ©â‰â¦ƒğ‘’Ì¸â‹ˆ0?â¦„(â¨†
ğ‘›âˆˆâ„•(â¦ƒğ‘ â¦„â—¦â¦ƒğ‘’â‹ˆ0?â¦„)ğ‘›âŸ¨ğ‘…0,â„¦0âŸ©)
tial errors. It is defined by induction over the Fig. 7. The operatorâ¨†
refers to the iteration of the binary associative and commutative operatorâŠ” over
expressionğ‘’âˆˆ expr to a variableğ‘‹âˆˆğ’±, is obtained by considering each potential
ğœŒ[ğ‘‹â†ğ‘¥] denotes the function equal toğœŒ onğ’±â§µ{ğ‘‹} and that mapsğ‘‹ toğ‘¥. The

memory state before the execution of the assignment and each potential value
for the expression in that memory state ; for each combination, the memory
state is updated by taking into account the potential value of the expression.

the transformation over the possible memory states and accumulates the poten-

Roughly speaking, the set of potential memory states, after assigning an

evaluation of the expression can also yield errors, which are also collected. The
semantics of the sequential composition of two statements is the composition of
their semantics. Lastly, the semantics of conditional branching and loops rely on
the handling of guarding conditions: the execution of the guard restricts the set
of memory states to those that satisfy the corresponding condition. The potential
errors raised when evaluating the expression are also collected. The semantics
of conditional branching apply the semantics of the true branch on the result of
the application of the guard, and join it to the result of the application of the
negation of the guard. Lastly, the semantics of loops is obtained by unfolding
the loop according to its number of iterations.

4 Soundness requirements of expression rewriting

by a set of error alarms. Rewriting an expression may rely on some conditions
about the current state of the system. Additionally, it can simplify some parts
of the initial expression, which could potentially raise some error alarms. The
set of these error alarms are reported as side-conditions.

We now introduce a rewriting order over expressions, notedâ‰¼, and parameterized
Definition 3. The relationâ‰¼â„¦1, withâ„¦1âˆˆâ„˜(â„¦) a set of potential error alarms,
âŸ¨ğ‘…0,â„¦0âŸ©âŠ¨ğ‘’1â‰¼â„¦1ğ‘’2 â‰ âˆ€ğœŒâˆˆğ‘…0,âŸ¦ğ‘’1âŸ§ğ‘‰ğœŒâŠ†âŸ¦ğ‘’2âŸ§ğ‘‰ğœŒ âˆ§âŸ¦ğ‘’1âŸ§â„¦ğœŒâŠ†âŸ¦ğ‘’2âŸ§â„¦ğœŒâˆªâ„¦1

is defined as follows:


withâŸ¨ğ‘…0,â„¦0âŸ©âˆˆğ’Ÿ a semantics element andğ‘’1,ğ‘’2âˆˆ expr two expressions.
The definition of the rewriting relationâ‰¼â„¦1 is based on the semantics of
expressions. Given a semantics elementâŸ¨ğ‘…0,â„¦0âŸ©âˆˆğ’Ÿ, an expressionğ‘’1 can be
rewritten in the expressionğ‘’2 if and only if, in every memory stateğœŒâˆˆğ‘…0, the
potential values of the expressionğ‘’1 are all potential values of the expression
ğ‘’2. Yet, simplifications of the expressionğ‘’1 may hide error alarms, which are
reported
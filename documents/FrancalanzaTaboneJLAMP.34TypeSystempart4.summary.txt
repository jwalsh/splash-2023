

This section discusses the type system used in Elixir modules. It explains that the function information environment, Σ, is well-formed, meaning that all functions mapped (f/n ∈ dom(Σ)) observe the condition that the body of the function f/n is closed, i.e., for Σ(f/n) = Ω, fv(Ω.body) (Ω.params ∪ {Ω.dual}) = ∅. It then explains that session typechecking is initiated by analysing an Elixir module, rule [tModule], which uses three helper functions to check each public function. The function functions(D) returns a list of all function names (and arity) of the public functions (D) to be checked individually, the function sessions(D) obtains a mapping of all the public functions to their expected session types stored in ∆, and the helper function details(-) populates the function information environment (Σ). The highlighted term typing judgement is then detailed, which states that the term t can produce a value of type T after following an interaction protocol starting from the initial session type S up to the residual session type S' while interacting with a dual process with pid identifier w. The receive construct is typechecked using the [tBranch] rule, which expects an (external) branching session type &..., where each branch in the session type must match with a corresponding branch in the receive construct. Finally, the definition of Simple Patterns is provided, which states that the predicate simplepat(p, T) only accepts patterns that exclusively contain variables and top-level tuples.
Title-Abstract. Section intro

We finish this preliminary results section, with few examples about modulo

computations.

3 Syntax and Semantics of the Language
3.1 Syntax of the Language
The syntax of our language is introduced in Fig. 5. The analysis that is described
in this paper only refines the result of integer computations. Thus, the descrip-


Symbolic transformation of expressions in modular arithmetic

7

tion of pointers and floating point arithmetic is omitted. We indeed suppose
that lvalue resolution has been partially solved (see [2, Sect. 6.1.3]) and that the
abstraction presented here assigns no information to the value of floating point
variables (which are handled by some other of the analyzer).
We focus on integer expressions, which are made of variables, constant inter-
vals, classical arithmetic operations, modulo within a constant modular ring,

and bound checks. A specific operatorâ‹“ is added to our extended syntax to rep-
For example,. if it is defined, the value ofğ‘… is between the
ğ‘Œ0 andğ‘Œ1, regardless of their order. We then denoteğ‘…ğ‘Œ0â‹“ğ‘Œ1. Assuming we
can establish thatğ‘Œ0â‰¤ğ‘Œ1, it follows thatğ‘Œ0ï¿½ï¿½ï¿½â‰¤ğ‘Œ1.
The variables involved in the program belong to a finite set, denotedğ’±.

resent the value of some sub-expressions. This operator represents the convex
join of two integer expressions, that is any value between its operands. This is
especially helpful to deal with expressions involved in interpolation procedures.

We use interval constants to represent constants or to model non-determinism
that may be due to some unknown inputs or potentially imprecise abstraction.
Implicit and explicit casts have been decomposed by means of two operators:
as it will be seen in the description of the semantics, the bound check operator
bound_check checks whether the value of an expression does not overflow, and
the modulo operator mod extracts the remainder of the Euclidean division.
Lastly, we assume that bit shifting has been replaced with equivalent arithmetications.

Stat assignments, sequential composition, conditional branch-
ing (we only consider positive branches, negative ones can be encoded conse-
quently), and loops. The conditions of branching and loops compare expressions

with the value0. This toy language is enough to encode the semantics of the
For the rest of the paper, every constant expression of the form[ğ›¼,ğ›¼] with
ğ›¼âˆˆâ„¤ is denotedğ›¼cst.

integer arithmetic restriction of real-life programming languages like C.

3.2 Concrete Semantics of the Language
We now concrete semantics of our language is a mathematical
expression of its behaviors. It is worth noting that, due to the use of intervals
and convex join operators, the evaluation of an expression may induce non-
determinism. Additionally, our semantics tracks erroneous computations.

We introduce a set of possible errors that we noteâ„¦. We assume thatâ„¦
contains in particular two distinct elementsğœ”ğ‘‘ andğœ”ğ‘œ: the errorğœ”ğ‘‘ stands for a
division by zero the errorğœ”ğ‘œ denotes a bound check failure. The other
elements ofâ„¦ can be raised by the other domains of the analyzer, especially
A memory state is a function that maps each variable from the setğ’± to an inï¿½. The set of all memory denï¿½ï¿½. The concrete semantics
ï¿½ exprâŸ§âˆˆâ„°â†’(â„˜(â„¤)Ã—â„˜(â„¦)) of an expression maps a memory state to sets of
values and errors. To simplify the formulas, given an expressionğ‘’âˆˆ a
memory stateğœŒâˆˆâ„°, the first component ofâŸ¦ğ‘’âŸ§ï¿½ is often writtenâŸ¦ğ‘’âŸ§ğ‘‰ğœŒâˆˆâ„˜(â„¤),

during the resolution lvalues.


8

J. Boillot, J. Feret.

âŸ¦ğ‘‹ï¿½ğœŒâ‰ âŸ¨{ğœŒ(ğ‘‹)},âˆ…âŸ©
âŸ¦ï¿½ï¿½]ï¿½ğœŒâ‰âŸ¨ï¿½ï¿½âˆˆâ„¤âˆ£ï¿½â‰¤ğ‘¥â‰¤ğ‘},âˆ…ï¿½
âŸ¦âˆ’ï¿½âŸ§ï¿½ï¿½âŸ¨{âˆ’ğ‘¥âˆ£ğ‘¥âˆˆâŸ¦ğ‘’âŸ§ğ‘‰ğœŒ},âŸ¦ğ‘’âŸ§â„¦ğœŒâŸ©
âŸ¦ğ‘’1+ğ‘’2âŸ§ğœŒâ‰ï¿½ğ‘¥+ğ‘¦âˆ£ğ‘¥âˆˆâŸ¦ğ‘’1âŸ§ğ‘‰ğœŒ,ğ‘¦ï¿½ï¿½ï¿½ğ‘’2âŸ§ğ‘‰ğœŒ},âŸ¦ğ‘’1âŸ§â„¦ğœŒâˆªâŸ¦ğ‘’2âŸ§â„¦ğœŒâŸ©
âŸ¦ğ‘’1Ã—ğ‘’2âŸ§ğœŒâ‰âŸ¨{ğ‘¥Ã—ğ‘¦âˆ£ğ‘¥âˆˆâŸ¦ğ‘’1âŸ§ğ‘‰ğœŒ,ğ‘¦âˆˆâŸ¦ğ‘’2âŸ§ğ‘‰ğœŒ},âŸ¦ğ‘’1âŸ§â„¦ğœŒâˆªâŸ¦ï¿½âŸ§â„¦ğœŒâŸ©
âŸ¦ğ‘’1âˆ•ğ‘’2âŸ§ğœŒâ‰âŸ¨{truncate(ğ‘¥âˆ•ğ‘¦)âˆ£ğ‘¥âˆˆâŸ¦ğ‘’1âŸ§ğ‘‰ğœŒ,ğ‘¦âˆˆâŸ¦ğ‘’2âŸ§ğ‘‰ğœŒ,ğ‘¦â‰ 0},âŸ¦ğ‘’1âŸ§â„¦ğœŒâˆªâŸ¦ğ‘’2âŸ§â„¦ğœŒâˆªâ„¦1âŸ©
withâ„¦1â‰{{ğœ”ï¿½
if0âˆˆâŸ¦ğ‘’2âŸ§ğ‘‰ğœŒ
âˆ…
âŸ¦ğ‘’1â‹“ğ‘’2âŸ§ğœŒâ‰âŸ¨{ğ‘§âˆˆâ„¤||||||||ğ‘¥âˆˆâŸ¦ğ‘’1âŸ§ğ‘‰ğœŒ,ğ‘¦âˆˆâŸ¦ğ‘’2âŸ§ğ‘‰ğœŒ
},âŸ¦ğ‘’1âŸ§â„¦ğœŒâˆªâŸ¦ğ‘’2âŸ§â„¦ğœŒâŸ©
ğ‘¥â‰¤ğ‘§â‰¤ğ‘¦ âˆ¨ğ‘¦â‰¤ğ‘§â‰¤ğ‘¥
âŸ¦ğ‘’ mod[ğ‘™,ğ‘¢[âŸ§ğœŒâ‰âŸ¨{ğ‘¥mod[ğ‘™,ğ‘¢[âˆ£ğ‘¥âˆˆâŸ¦ğ‘’âŸ§ğ‘‰ğœŒ},âŸ¦ğ‘’âŸ§â„¦ğœŒâŸ©
âŸ¦ bound_check(ğ‘’,[ğ‘™,ğ‘¢[)âŸ§ğœŒâ‰âŸ¨âŸ¦ğ‘’âŸ§ğ‘‰ğœŒ,âŸ¦ğ‘’âŸ§â„¦ğœŒâˆªâ„¦1âŸ© withâ„¦1â‰{{ğœ”ğ‘œ}
ifâŸ¦ğ‘’âŸ§ğ‘‰ğœŒâŠˆ[ğ‘™,ğ‘¢[
âˆ…
while the second one is writtenâŸ¦ğ‘’âŸ§â„¦ğœŒâˆˆâ„˜(â„¦). These notations are used in the

Fig. 6: Concrete semantics of expressions.

otherwise

otherwise

inductive definition given in Fig. 6 and also until the rest of the paper.

argument.

the errors, but does not raise new ones. Finally, bound-checking propagates val-

The evaluation of a variable raises no error, it only gives the value that is
fetched from the memory state. The evaluation of an interval
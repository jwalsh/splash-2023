

This paper introduces a novel debugging technique for static analysis implementations called cross-level debugging. This technique moves debugging features such as stepping and breakpoints to the base-layer (i.e., analyzed program), while still making interactions with the meta-layer (i.e., analysis implementation) possible. To this end, the authors introduce novel conditional breakpoints that express conditions, which they call meta-predicates, about the current analysisâ€™ state. They integrated this debugging technique in a framework for implementing modular abstract interpretation-based static analyses called MAF. Through a detailed case study on 4 real-world bugs taken from the repository of MAF, they demonstrate how cross-level debugging helps analysis developers in locating and solving bugs.

The paper discusses the design of an analysis-tailored debugger, which consists of four parts: the code being analyzed, a graph of components and their dependencies, an overview of the global store, and a visualisation of the worklist algorithm. The debugger provides two types of stepping and breakpoints are represented as expressions in the analyzed program. Meta-predicates are split into three categories: store-based, worklist-based and lattice-based. Store-based meta-predicates express conditions on the state of the global store, worklist-based meta-predicates express conditions on the state of the worklist, and lattice-based meta-predicates express conditions on the lattice values of the analyzed program.

The paper also discusses the implementation of abstract definitional interpreters, which are used to derive static analyses. It explains how memory abstraction is used to analyze programs with variables, and how global store widening can reduce the state space from an exponential to a cubic one. It also introduces the concept of effect-driven modular static analysis, which splits the program under analysis into components that are analyzed separately from each other. Finally, it explains how the exact components of a program can depend on each other through shared variables or return values.

The paper was evaluated by querying the MAF repository on Github for soundness related bugs and selecting 4 real-world soundness bugs. It also introduces a synthetic bug to study the effectiveness of the worklist meta-predicates. The debugger was found to be effective for most bugs related to changes of store addresses and their contents. It was argued that the approach is flexible enough to support other classes of bugs in future work.

Finally, the paper provides an overview of the meta-predicates available in the debugger. These predicates are divided into two categories: store predicates and lattice predicates. The store predicates allow for expressing conditional breakpoints that break on the absence of a particular store address. The second predicate, called store:changed?, returns true whenever a particular address in the store has changed since the last break. The lattice predicates provide an interface to the abstract lattice operations and are divided into two sub-categories: type-checking predicates, and reified abstract operations. Finally, the worklist predicates provide information about the current state of the worklist. Examples of conditional breakpoints are provided to illustrate the synergy between the different categories of meta-predicates.

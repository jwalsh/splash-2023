Title-Abstract. Section intro
 ∈ Δ. We leave ‘good’ undeﬁned, but consider False and  −∗  bad choices
since they will make the proof automation get stuck, or loop.

The format of abduction hints directly represents hints of Category 2, but what about Category 1?
Category 1 is encoded by performing a technical trick by Mulder et al. [2022], relying on the fact
that  ′ ⊢  implies True ∗ ′ ⊢ . Since Δ ⊢ True vacuously holds, we can pretend to have True ∈ Δ
for the purpose of ﬁtting Category 1 into Category 2. To account for the case where a priority of
rules is desired (some Category 1 rules should be tried either before or after Category 2 rules), we
deﬁne two syntactical markers 0 ≜ True and 1 ≜ True. Our proof search strategy will always ﬁnd
0 ∈ Δ before any actual hypothesis in Δ, while 1 ∈ Δ will always be found last. This technique is
similar to techniques by Gonthier et al. [2011], where multiple equivalent deﬁnitions are used to
obtain proof automation rules with diﬀerent priorities.

The proof search strategy proceeds as follows. If our goal is Δ ⊢ , use type classes to ﬁnd  ∈ Δ
and  ′ such that  ∗ [ ′] (cid:25. Continue with goal Δ′ ⊢  ′, where Δ′ is obtained from context Δ
by removing , unless  is persistent or equal to 0 or 

As an example, these abduction hints implement two cases of the strategy for logical atomicity:

abduct-wp-val

0 ∗(cid:2) |⇛⊤ ⊤ Φ (cid:3) (cid:25) wp  {Φ}

abduct-sym-ex-logatom

⊢ ⟨®. ⟩  ⟨. Ψ⟩ E

0 ∗h(cid:10) ®.  | .  ⇛ wp  [] {Φ}(cid:11)⊤\Ei (cid:25) wp  [] {Φ}

Both rules will be directly applied (indicated by 0) if the goal matches the conclusion and the
side-conditions can be solved. After applying a rule, the goal will be replaced by the part between

Proc. ACM Program. Lang., Vol. 7, No. OOPSLA1, Article 91. Publication date: April 2023.


91:20

Ike Mulder and Robbert Krebbers

square brackets [ and ]. To make Diaframe 2.0 use these hints, one provides type class instances of
above form—which requires a proof of the claimed entailment. Hints thus serve two purposes: they
both implement the proof search strategy and prove it sound.

4.2 Near-Applicability

Diaframe 2.0 can apply abduction hints when the logical state or current goal nearly matches a rule.
Let us demonstrate this on the rule rec-apply from §3.3 to apply Löb induction hypotheses. This
rule is monolithic since it takes care of two tasks: apply a weakest precondition below an evaluation
context  in the goal, and ﬁnd a weakest precondition below a magic wand in the context Δ. In the
implementation in Diaframe 2.0, this rule is decomposed in separate hints for each task:

abduct-wp-bind

wp  {Φ} ∗(cid:2)∀. Φ  −∗ wp  [] {Ψ}(cid:3) (cid:25) wp  [] {Ψ}

abduct-wand

 ∗ [ ′] (cid:25) 

( −∗  ) ∗ [ ∗  ′] (cid:25) 

The key hypothesis wp  {Φ} of abduct-wp-bind does not precisely match the induction hypothesis
(cid:31)(Δ −∗ wp  {Φ}) that was generated by Löb. To address this, abduction hints are closed under the
connectives of separation logic by recursive rules such as abduct-wand (similar recursive rules
exist for other connectives of separation logic, e.g., universal quantiﬁcation). The recursive rules
ensure that every abduction hint  ∗ [ ′] (cid:25)  is not just relevant when  ∈ Δ, but also when for
example ( −∗ ) ∈ Δ or (1 −∗ 2 −∗ ( ∗ )) ∈ Δ.

These two rules also come in handy for situations besides rec-apply. For example, abduct-wand
and similar recursive rules are used for Löb induction in reﬁnement proofs. The abduction hint
abduct-wp-bind is useful when verifying examples with higher-order functions. There, one might
have a speciﬁ a closure in the proof context, and abduct-wp-bind makes it possible to
use this speciﬁcation in any evaluation context.

4.3 Transformer Hints for Modalities

This section deﬁnes transformer hints, which capture rules in Category 3. We show how these
hints support the introduction of the (cid:31) and ⊲ modalities. Transformer hints come in two ﬂavors—
hypothesis and context transformer hints:4

, T →∼hyp [T ′] ≜ T ′ ⊢ ( −∗ T )

Δ, T →∼ctx [] ≜ (Δ ⊢ ) =⇒ (Δ ⊢ T )

Like before, terms between brackets are outputs of type class search, the other terms are inputs. We
use the class T to indicate goals on which transformer hints should be used—this class is disjoint
from ordinary goals  on which abduction hints should be used. Examples of transformer hints are
the introduction rules for the later (⊲) and persistence ((cid:31)) modalities:

⊲ , ⊲ 

→∼hyp [⊲( −∗ )]

no  ∈ Δ preﬁxed by ⊲

all  ∈ Δ are persistent

Δ, ⊲ 

→∼ctx []

Δ, (cid:31) 

→∼ctx []

If we are proving a goal of shape Δ ⊢ T, the proof search strategy takes the following steps:

→
∼ hyp [ T′ ] is logically equivalent to an abduction hint  ∗ [ T′ ] (cid:25) T.
4One might note that a hypothesis transformer hint , T
While logically equivalent, these hints are diﬀerent operationally. Hypothesis transformer hints only act on the head-
symbol/modality of hypothesis , while abduction hints will look beneath connectives of  using rules like abduct-wand,
as explained in §4.2.

Proc. ACM Program. Lang., Vol. 7, No. OOPSLA1, Article 91. Publication date: April 2023.


Proof Automation for Linearizability in Separation Logic

91:21

(1) Find  ∈ Δ and T ′ such that , T →∼hyp [T ′]. Continue with goal Δ′ ⊢ T ′, where Δ′ is the
context Δ in which  is removed. Unlike abduction hints,  is also removed if it is persistent,
and 0 and 1 are not detected by these hints.

(2) Otherwise, ﬁnd  such that Δ, T →∼ctx []. Continue with goal Δ ⊢ .

One can check that the transformer hints for the later modality ﬁrst ‘revert’ and strip the later oﬀ
of all hypotheses with a later, and only then introduce the later modality.

4.4 Transformer Hints for Other Rules

In §4.3, we saw that transformer hints are ﬂexible enough to support the introduction of modalities
Title-Abstract. Section intro
point of this function. Hence, we replace the function

state just before interpreting the loop. This does not change the result of the
concrete iterations.

We can now state the soundness of the abstract semantics.


14

J. Boillot, J. Feret.

Theorem 2. LetâŸ¨ğ‘…0,â„¦0âŸ©âˆˆğ’Ÿ be a semantics state. Letğ‘…â™¯âˆˆğ’Ÿâ™¯ be an abstract
state. Letğ‘ âˆˆ stmt be a statement. ThenâŸ¨ğ‘…0,â„¦0âŸ©âŠ‘ğ›¾(ğ‘…â™¯) âŸ¹ â¦ƒğ‘ â¦„âŸ¨ğ‘…0,â„¦0âŸ©âŠ‘
ğ›¾(â¦ƒğ‘ â¦„â™¯ğ‘…â™¯
Thm. 2 states that the abstract semantics ignores no concrete behavior. Nev-

ertheless, it may introduce fictitious ones due to the abstraction.

(that are linear forms).

nothing has to be When the abstract expression is a constant, the modulo
computation can be directly applied on the constant. Lastly, if the value of the
abstract expression ranges within the interval of the, then the modulo
computation can be safely discarded. In all other cases, no information can be

This way, the opposite of a linear form is obtained by taking the opposite

6.1 Primitives over abstract expressions
We now introduce two primitives that operate over abstract expressions.

Theopposite function pushes unary minus to the leafs of abstract expressions 6. The functionoppositeâˆ¶ exprâ™¯â†’ exprâ™¯ is defined inductively as
follows: opposite(â„’â–¡(ğ‘0+âˆ‘ğ‘‹ğ‘–âˆˆğ’±ğ‘ğ‘–ğ‘‹ğ‘–))â‰â„’â–¡(âˆ’ğ‘0+âˆ‘ğ‘‹ğ‘–âˆˆğ’±(âˆ’ğ‘ğ‘–)ğ‘‹ğ‘–)
opposite(ğ‘’â™¯1âŠğ‘’â™¯2)â‰opposite(ğ‘’â™¯1)âŠopposite(ğ‘’â™¯2)
opposite(ğ‘’â™¯1âŠ ğ‘’â™¯2)â‰opposite(ğ‘’â™¯1)âŠ ğ‘’â™¯2
opposite(ğ‘’â™¯1â§„ğ‘’â™¯2)â‰opposite(ğ‘’â™¯1)â§„ğ‘’â™¯2
opposite(ğ‘’â™¯1â‹“â–¡ğ‘’â™¯2)â‰opposite(ğ‘’â™¯1)â‹“â–¡opposite(ğ‘’â™¯2)
of each coefficient. The functionopposite propagates over the sub-expressions
of theâŠ and theâ‹“â–¡ operators. Lastly, the opposite of a product or a quotient
Definition 7. For any abstract expressionğ‘’â™¯âˆˆ exprâ™¯ and any modulo specifica-
tionğ‘šâˆˆğ•„, the functionrmMod(ğ‘’,ğ‘š)âˆ¶ğ’Ÿâ™¯â†’ exprâ™¯ is defined as follows:
ifğ‘š=â„¤,
else ifğ‘’â™¯=ï¿½â–¡(ğ›¼) withğ›¼âˆˆâ„¤,
rmMod(ğ‘’â™¯,ğ‘š)ğ‘…â™¯â‰
else ifğœ„(toExpr(ğ‘’â™¯))ğ‘…â™¯âŠ†ğ‘š,
otherwise, withï¿½=[ğ‘™,ğ‘¢[.
In the, if the modulo specification is equal to the setâ„¤,

We now introduce an operator to propagate a modulo computation over an
abstract expression. Given an abstract expression and a modulo specification, it
applies the modulo on the expression.

between two sub-expressions is obtained by propagating it to only one of them
(the first one has been chosen arbitrarily).

ğ‘’â™¯
â„’â–¡(ğ›¼modğ‘š)
ğ‘’â™¯

reduce(â„’â–¡(ğ‘™)â‹“â–¡â„’â–¡(ğ‘¢âˆ’1))ğ‘…â™¯

â§âªâªâ¨âªâªâ©


Symbolic transformation of expressions in modular arithmetic

15

Moreover, this rewrite does not hide any potential error alarms.

Example 5. We give two examples of elimination of modulo computations. We

ulo computation can be eliminated without modifying the abstract

case, the result of the modulo computation cannot be described precisely as
an abstract expression. It is then soundly replaced by the abstract expression

it is a parameter of our abstraction.

kept about the expression. It is then replaced with the interval of the modular
ring ( precisely).

The following theorem states that any abstract expression that is evaluated
over a modular ring can be rewritten in the expression in which the modulo

computation has been forced, that is to say the output of the functionrmMod.
Theorem 3. For all abstract valueğ‘…â™¯âˆˆğ’Ÿâ™¯, abstract expressionğ‘’â™¯âˆˆ exprâ™¯, and
potential modular ringğ‘šâˆˆğ•„, the following property holds,
ğ›¾(ğ‘…â™¯)âŠ¨toExpr(ğ‘’â™¯) modğ‘šâ‰¼âˆ…toExpr(rmMod(ğ‘’â™¯,ğ‘š)).
compute the result of the abstract expressionâ„’â–¡(0) â‹“â–¡â„’â–¡(25), that intuitively
denotes the interval[0,25], respectively modulo[0,28[ and[10,26[. We as-
sume that the primitiveğœ„ provides the exact range of this expression, that
is to say thatğœ„(toExpr(â„’â–¡(0) â‹“â–¡ â„’â–¡(25)))ğ‘…â™¯ = ğœ„(0cstâ‹“25cst) = [0,25]. Since
the interval[0,25] is included in the interval[0,28[, the corresponding mod-
We obtainrmMod(â„’â–¡(0) â‹“â–¡â„’â–¡(25),[0,28[)ğ‘…â™¯=â„’â–¡(0) â‹“â–¡â„’â–¡(25). In the second
reduce(â„’â–¡(10)â‹“â–¡â„’â–¡(25))ğ‘…â™¯. We keep the primitive reduce uninterpreted, since
pressions into abstract ones. Given an expressionğ‘’âˆˆ expr, its translationâ¦…ğ‘’â¦†âˆ¶
ğ’Ÿâ™¯â†’ exprâ™¯Ã—ğ•„Ã—â„˜(â„¦) function that maps an abstract elementğ‘…â™¯ to a
triple(ğ‘’â™¯,ğ‘š,â„¦ğ‘’). Remember that abstract expressions do not have modulo oper-
ators. However, the elementğ‘šâˆˆğ•„ stands for a modulo computation to be ap-
must be translated conservatively. This can be done thanks to thermMod opera-
â„¦ğ‘’. The translation is only valid for the semantics states satisfying the property
ğ‘…â™¯ (i.e., for the states inğ›¾(ğ‘…â™¯)). Thus, the abstract elementğ‘…â™¯ should be used
The translationâ¦…ğ‘’â¦†ğ‘…â™¯ of an expressionğ‘’, in the context of an abstract ele-
mentğ‘…â™¯, is defined inductively and by cases by the means of a set of inference
cients are set to0, except the one corresponding to the variable which is set to1.

6.2 Translation from Classical to Abstract Expressions
We now have all the material needed to define the translation of classical ex-

plied on the potential values of the abstract expression. This way, the outermost
modulo computation can be kept precisely, whereas inner modulo computations

tor, yet it may yield a loss of information. Bound checks also cannot be described
in abstract expressions, so potential bound check failures are reported in the set

to drive the translation process to get a more accurate result.

rules.

Variable. A variable is replaced by a linear combination where all the coeffi
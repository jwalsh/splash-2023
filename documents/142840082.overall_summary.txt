

This paper presents a framework for the symbolic transformation of expressions in modular arithmetic. It introduces two primitives, the opposite function and the rmMod function, which operate over abstract expressions. Theorem 3 states that any abstract expression that is evaluated over a modular ring can be rewritten in the expression in which the modulo computation has been forced. Additionally, the paper introduces an intermediate language inspired by the one used in symbolic constant propagation, which allows modulo computations and bound checks. It also explains how the language describes two kinds of error alarms: divisions by zero and failed bound checks.

The paper also introduces a generic framework for the symbolic transformation of expressions in modular arithmetic. It provides more explicit definitions for the θ primitive and reduces primitive of the parametric abstraction. The other components are supposed to be defined in an underlying domain. It then introduces an intervalization heuristic which attempts to simplify abstract expressions without concealing potential error alarms. The purpose of this function is to achieve maximum expression canonization by using linear forms whenever possible. It then introduces a reduce implementation, denoted as reduce0, that is a set of inference rules. Their premises are mutually exclusive, except for the NoReduce rule that is used only when no other rule can be applied.

The paper also provides formalized inference rules for the symbolic transformation of expressions in modular arithmetic. The rules are divided into four categories: DivPosConst, DivNegConst, BoundCheckMod, BoundCheckNoMod, ModPlusExpr, ModMultExpr, and ModIdentity. The first two rules, DivPosConst and DivNegConst, are applied when neither of the rules can be applied. The BoundCheckMod and BoundCheckNoMod rules are used to check the bounds of the bound check expression and collect any potential errors. The ModPlusExpr and ModMultExpr rules are used to propagate the outermost modulo computation of the main expression when the modulo specifications of the two abstract translations of the operands are compatible with the outermost modulo computation. The ModIdentity rule is used to simplify the modulo computations when the outermost modulo interval is large enough and compatible with the modular ring of the translated sub-expression. Lastly, the primitivermMod is used to eliminate the outermost modulo of the main expression when no other rules can be applied.

The paper also provides an overview of the application of the modulo operation in the context of abstract expressions interpreted in ℤ. It explains how the Plus2Const, PlusConst, PlusEqZero, MultZeroConst, MultNegConst, MultNoMod, Mult2Const, and MultPosConst inference rules can be applied to reduce the modulo computations in both arguments translations. It also explains how the thermMod operator can be used to suppress the modulo computations in both arguments translations. Finally, it explains how the reduce parametric operator can be used to potentially simplify the resulting abstract expression.

The paper also introduces a static analyzer that checks for the absence of run-time errors in embedded critical software. The analyzer is parameterized by an auxiliary numerical abstract domain which is used to compute and represent numerical properties of program instructions. Symbolic methods have been developed to keep relations between variables by reasoning directly over the arithmetic expressions and to apply sound program transformations on-the-fly to ease the analysis. This paper presents symbolic enhancement techniques similar to the ones described in [21], but that allow safe modulo elimination when it is possible. Examples are provided to demonstrate the effects of the new abstract domain.

The paper also provides an implementation of the approach proposed in the paper in the Astrée static analyzer and a toy abstract interpreter. It also provides an evaluation of the accuracy and overhead cost of the new abstract domain in the presence of modulo computations. The results show that the overhead cost is compensated by the increase in accuracy, reducing the time spent in other domains. The reduction operator can be easily tuned.

Lastly, the paper provides a theorem that states that the evaluation of a translated expression keeps all the possible values of the evaluation of the original expression. It also states that the set of potential error alarms returned by the translation contains at least all the potential error alarms of the evaluation of the original expression. This is a stronger statement than the one needed to rewrite expressions, and is formalized in the inference rule given in the section.

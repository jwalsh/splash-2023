

This section compares ElixirST with other type systems and implementations for Elixir. Cassola et al. [13, 25] presented a gradual type system for Elixir that statically typechecks the functional part of Elixir modules. Gradient [26] and TypeCheck [27] are implementations that add dynamic type validations to Elixir programs. Harrison [28] and Christakis and Sagonas [29] analyse Core Erlang code to detect errors related to message-passing. Svensson et al. [31] presented a type system for Erlang that captures an LTS defined over systems of concurrent actors. Mostrous and Vasconcelos [19] introduced session types to a fragment of Core Erlang, but there is no implementation for it. Neykova and Yoshida [32] use the Scribble [33] language to write multiparty session type (MPST) [16] protocols to monitor processes' actions. Fowler [34] presented an MPST implementation for Erlang, and Neykova and Yoshida [35] extended it to provide a recovery strategy for failed processes. Scalas and Yoshida [36] applied binary session types to the Scala language, and Bartolo Burl`o et al. [24] extended it to monitor one side of an interaction statically and the other side dynamically. Harvey et al. [39] presented a new actor-based language, called EnsembleS, which offers session types as a native feature of the language. There have been several binary [40, 41] and multiparty [42, 43] session type implementations for Rust, and Padovani [44] created a binary session type library for OCaml. Kamburjan et al. [47, 48] added session types to ABS, which is an AO language that uses futures to resolve the results derived from method invocations. Deâ€™Liguoro and Padovani [49] introduced a mailbox calculus which considers mailboxes as first-class citizens, and Fowler et al. [50] built on this to implement mailbox types within a practical concurrent programming language. ElixirST only supports a limited form of spawning and does not allow processes to hand over the remaining session to other processes.